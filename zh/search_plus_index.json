{"./":{"url":"./","title":"简介","keywords":"","body":"MaixPy 文档简介 网站导航 地址 MaixPy 唯一官方文档官网 官网: maixpy.sipeed.com中文站: cn.maixpy.sipeed.com MaixPy 例程仓库 github： github/maixpy_script 国内：gitee/maixpy_scripts MaixPy 源码 github: MaixPy 开发板资料下载 dl.sipeed.com Sipeed WIKI wiki.sipeed.com 关于 MaixPy MaixPy 是将 Micropython 移植到 K210（一款 64 位双核带硬件 FPU、卷积加速器、FFT、Sha256 的 RISC-V CPU ） 的一个项目， 支持 MCU 常规操作， 更集成了硬件加速的 AI 机器视觉和麦克风阵列，1TOPS 算力 核心模块却不到￥50， 以快速开发具有极低成本和体积实用的 AIOT 领域智能应用。 MicroPython 是基于 Python3 的语法做的一款解析器，包含了 Python3 的大多数基础语法， 主要运行在性能和内存有限的嵌入式芯片上。（注意 Micropython 不包含 Python3 的所有语法） MaixPy 让我们在 K210 上编程更加简单快捷， 我们也将源代码开源在 github 上 使用 MaixPy 可以做很多有趣的事情， 具体可以看这里 简洁的代码实例 比如我们需要扫描 I2C 总线上的设备，不需要复杂的开发环境和工程，只需要通过串口发送如下代码即可实现： from machine import I2C # 导入内置库 i2c = I2C(I2C.I2C0, freq=100000, scl=28, sda=29) # 定义一个I2C对象， 使用I2C0, 频率100kHz，SCL引脚是IO28, SDA 引脚是IO29 devices = i2c.scan() # 调用函数扫描设备 print(devices) # 打印设备 同样，我们需要实现一个呼吸灯，只需要如下代码： from machine import Timer,PWM from board import board_info import time tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PWM) ch = PWM(tim, freq=500000, duty=50, pin=board_info.LED_G) duty=0 dir = True while True: if dir: duty += 10 else: duty -= 10 if duty>100: duty = 100 dir = False elif duty 实时拍照： import sensor import image import lcd lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) while True: img=sensor.snapshot() lcd.display(img) 这篇文档的内容 所有关于 MaixPy 的内容， 包括： 如何选择并得到一款合适自己的模块或者开发板 如何开始上手使用 库和接口（API）文档查询 详细的一步一步手把手教程 来自社区的分享（教程或开源项目） 为了在学习过程中避免遇到难以解决的问题，请务必按照左边目录结构从上到下阅读，特别是写在前面的章节，不要跳过 可以运行MaixPy的开发板 首先我们需要选择一款适合自己的开发板，各个型号的 MaixPy 型号请点击：开发板与配件选购指南，同时目录下也有对应开发板的硬件参数和资料 要获得这些板子，可以访问Sipeed（矽速）官网www.sipeed.com，或者官方淘宝店 MaixPy 源码 MaixPy 源码是指 运行在 K210 上的 Micropython 语法解析器， 使用 C语言 编写，如果只是想使用 MaixPy，不需要了解源码； 如果想参与开发 MaixPy 的内置功能，可以下载进行开发，欢迎大家提交 PR MaixPy 源码托管在 github 本项目主要由 ©Sipeed Co.,Ltd. 维护， 并接受来自开源社区的贡献， 具体贡献这见贡献者列表 MaixPy 文档源码 文档源码托管在 github，如果文档有错别字或者改进可以提交PR，PR通过后，文档也会随之更新 注意： 在编辑文档前必须看文档编写规范， 只有符合文档规范的修改才会被通过 反馈 关于本文档或者功能或者源码方面的问题，也欢迎提交issue: 反馈 交流 有问题尽量到上面的反馈地址提交issue，方便留下记录，其他人也可以查阅，提交前搜索一下是否有人提过相同问题 以下交流方式提供辅助： 交流方式 地址 issue https://github.com/sipeed/MaixPy/issues BBS https://bbs.sipeed.com MaixPy AI QQ 交流群 878189804 MaixPy AI QQ 交流群(二群) 1129095405 telgram https://t.me/sipeed E-mail(商业合作) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"others/what_maix_do.html":{"url":"others/what_maix_do.html","title":"What can MaixPy do?","keywords":"","body":"Powerful Maix Board(k210) Can Do Most of them integrated to MaixPy, or some of them include in Maixduino or from other developers Face recognition draw picture Turorial Openmv and Record video MobileNet Face detection NES gamer emulator MNIST Play video Feature map display GBA game emulator Game Quake I source code Game Doom source code MMD 3D rendering your browser does not support the video tag source code Gimbal face track Mic array LittlevGL FFT spectrum powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/how_to_read.html":{"url":"get_started/how_to_read.html","title":"Before read","keywords":"","body":"How to use (/read) this article correctly Note: Currently the only official document website: maixpy.sipeed.com On start, you can read carefully from the top to the next page according to the directory on the left sidebar. Then you can learn how to update the firmware, how to coding, and you must learn how to use serial terminal Every module's doc contains examples at the end of page, or you can find examples here, you can try them out ~ Finally, the interface and parameters of the module are consulted according to their own needs during use. There is a search box in the upper left corner, which can be used well. You can also use the browser's page search function, ie press Ctrl+F, then enter the content to search and press the enter key If you can't find you want, don't worry, you can go to github's issue (issue) Is there any mention of the page (/search)? If you don't have one, you can create a new issue or contact technical support. If pages load slowly, refresh or just wait, or change your network Doc pages generated by gitbook, there may be some error occur when click too fast but network speed not enough, just take care of the url( path ), for example: Wrong url: http://localhost:4000/zh/zh/get_started/how_to_read.html Correct url: http://localhost:4000/zh/get_started/how_to_read.html so just change the wrong url, or just back to (maixpy.sipeed.com) refresh page In addition, you need to note when asking questions on github or forums: Ask questions to provide complete steps to reproduce the problem, so that developers can test the problem and solve it! For common problems, please see Common Problems powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/get_hardware.html":{"url":"get_started/get_hardware.html","title":"Get Hardware","keywords":"","body":"Getting a development board Get your favorite hardware from Sipeed's official Taobao store or from Seeed Studio Required hardware A development board See boards in Wiki And get your favorite hardware from Sipeed's official Taobao store or from Seeed Studio USB Type C cable Type-C is chosen because it's reversible and it's very friendly for development. If you're buying from the official Taobao store, you can ask them to include it with your order. Type-C cables are also very common with Android phones. Screen By default, the LCD (24-pin interface) of the st7789 driver chip is used with a resolution of 320x240. If you're buying from the official Taobao store, you can ask them to include it with your order. Camera MaixPy devices support the ov2640 camera by default(or gc0328 or ov7740), and are often bundled with Maix devices. The ov2640 cameras bundled with Maix device are typically offered with two different lens options; a larger focusable fisheye lens, or a smaller fixed-focus lens. If you're buying from the official Taobao store, you can order a specific camera with your order. Micro SD Card (TF Card) (optional) Some Flash memory within the the device is reserved for a file system, but this internal memory is very slow! For quicker operation and additional storage, you can insert a Micro SD card or a TF card into the card slot available on most Maix devices. When purchasing a memory card, try to choose a new fast Micro SD card, such as a SD 2 generation protocol, Class10 memory card. Of course, the quality of SD cards on the market is uneven, and the SPI mode may not be compatible. Try to buy a regular card. Or maybe you should customize the driver code ~~ As shown below, the two cards on the left are not supported by the MaixPy driver. Both the middle and the right cards are supported, but the class10 card in the middle is the fastest(and tested maximum capacity is 128GB). ST-Link (used to update the firmware of the STM32 on the development board Maix Go) (optional) If you purchase a Maix Go, it has an embedded STM32 chip to simulate the USB-to-Serial converter, as well as JTAG. If you want to upgrade its firmware later on, it is recommended to buy an ST-Link programmer. JTAG Debugger (optional) The K210 chip supports JTAG debugging. If you need to debug, you will need to use the JTAG debugger. Please check the Sipeed Taobao store or SeeedStudio.com to buy one. If you are using a Maix Go development board, you won't need to purchase the JTAG debugger separately as it has an integrated STM32 chip that can emulate JTAG (STM32 uses CMSIS-DAP or open-ec firmware). open-ec firmware is currently not supported, although support will be added later. Please refer to the open-ec GitHub project page for more information. powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/prepare_knowledge.html":{"url":"get_started/prepare_knowledge.html","title":"Prepare knowledge","keywords":"","body":"Basic knowledge To get started with MaixPy，we recommend at least the following basics: With patience, calm down and study the technology, read the documentation and then write the code. Have Python or Micropython knowledge, we will use Python basic grammar. If you don't know anything about Python but you have programmed before, please search for Python basics first. If you've never programmed before, this documentation will be hard to understand. Make sure to learn, at least, basic Python before reading it. Can understand the basic circuit diagram Learn Micropython here： MicroPython Language Introduction General differences between MicroPython and Python can be found here：MicroPython vs CPython（Python3 查看 If you don't follow the previous points, then be prepared to struggle while developing, it will be extremely difficult! powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/install_driver.html":{"url":"get_started/install_driver.html","title":"Install driver","keywords":"","body":"Install driver We need to install the serial port driver as the board is connected to the computer through the USB to serial converter. Install the driver according to the board's USB to serial port chip model. In you are using Linux or Mac and you don't want to use sudo every time, add yourself to the dialout users group with the following command: sudo usermod -a -G dialout $(whoami) For Dan Dock or Maix Bit The CH340 chip is being used, Linux does not need to install the driver as the system already comes with it. Execute ls /dev/ttyUSB* to check if the device is found. If using Windows, search and download the drivers on the Internet, then open Device manager and look if the serial port is listed. For Maix Go An STM32 is being used to implement the serial port and the JTAG functionality. By default, this STM32 chip is running a build of the open-ec firmware. If everything is right, one or two serial ports will appear. In linux the following two serial ports will appear: /dev/ttyUSB0 and /dev/ttyUSB1. Please use /dev/ttyUSB1 when downloading and accessing the serial port. Windows is similar. If you need to re-burn this firmware, you can download it from GitHub or open-ec firmware, then use the STM32's SW pins (GND, SWDIO, SWCLK) from the ST-LINK connection board for programming. (The STM32 on the current version of the Go board does not support serial port burning. It can only be burned using ST-LINK. Please purchase it if you need it, or use a board with IO simulation such as the Raspberry Pi)) Currently, open-ec cannot simulate JTAG to debug the board. Use CMSIS-DAP to do so. You can download it from the official website and then burn it using an ST-LINK. Afterwards, /dev/ttyACM0 will appear under linux. ST-LINK has a very complete description of the burning method of STM32, please search for yourself. Please note that updating the firmware of STM32 is not the same as updating the MaixPy firmware. Generally, you do not need to update the firmware of STM32. The default is enough. STM32 is just a USB to serial port tool! Do not be confused. For the new Maixduino and Maix Bit versions that come with a microphone (using a CH552 chip) For the boards with a CH552 chip, to get the USB serial port, FT2232 drivers need to be installed. Search yourself for FT2232 drivers. In those boards, the JTAG function is not available. powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/upgrade_firmware.html":{"url":"get_started/upgrade_firmware.html","title":"Upgrade firmware","keywords":"","body":"Upgrade MaixPy firmware Connecting the board Connect the Type C cable, one end to the development board, one end to the computer. Install driver Install driver as described above Get the upgrade tool Download kflash_gui and you will get a zip file. kflash_gui is cross-platform, it can work on multiple systems (including Windows, Linux, MacOS or even Raspberry Pi) Extract the downloaded file to a folder, then double-click kflash_gui.exe to run the app. Or use terminal toolpip3 install kflash kflash --help kflash -p /dev/ttyUSB0 -b 1500000 -B goE maixpy.bin Get firmware The release version of the firmware is downloaded from the GitHub page The automated builds can be downloaded from here Firmware files have the .bin or .kfpkg extension You can pack kfpkg file with kflash_gui, or manually according to this kfpkg doc Firmware naming instructions: maixpy_v*.bin： Full version of MaixPy firmware (MicroPython + OpenMV API etc.) maixpy_v*_with_lvgl.bin： MaixPy firmware, with LVGL version. (LVGL is an embedded GUI framework, you need to use when writing the interface) maixpy_v0.3.1_minimum.bin： MaixPy firmware minimum set, not supported ´by MaixPy IDE, does not contain OpenMVrelated algorithms face_model_at_0x300000.kfpkg： Face model, placed in address 0x300000, can be downloaded multiple times without conflict elf.7z： elf file, ordinary users do not care, used for crash debugging Upload firmwre to the development board Open kflash_gui Select the firmware, set the options and then click to download. For more features, or instructions on how to use the tool, check the kflash_gui project page For the early Maix Go， if the download fails, try holding the three-phase dial to the down location during the download procedure. powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/serial_tools.html":{"url":"get_started/serial_tools.html","title":"terminal tools","keywords":"","body":"Serial terminal tools Connecting hardware Connect development board to computer with Type C cable Check if the device has been properly identified: Under Linux can ls /dev/ttyUSB* or ls /dev/ttyACM* to see, if not you can ls /dev come look for the specific device name with the relevant serial chip and drive， and you can use sudo dmesg to find device mount message If Windows, just open Device Manager to view If the device is not found, you need to confirm if the driver is installed and if the connection is good. Using the serial port tool Linux Use minicom(recommend) or screen etc. minicom sudo apt update sudo apt install minicom sudo minicom -s # Then set the serial port number according to the prompt and the baud rate is 115200. Do not know how to search using the search tool. # Set Backspace to DEL function # Set linewrap to Yes sudo minicom Note that minicom's default configuration file save requires sudo permission, so use sudo minicom -s Press A to select device Press E to set the baud rate, the baud rate needs to be set 115200 Here press A and R to set the settings the same as screenshot did, the first setting is for pye, second for display long line After setting save and exit, next time do not need to set up is required, just execute sudo minicom, if you do not want to use sudo every time, execute sudo usermod -a -G dialout $(whoami) to add user to the dialout user groups, then log off or reboot should be execute in order to take effect, note that if change the configuration by sudo minicom -s, the sudo is still needed After entering minicom, click the Enter button or the reset button of dev board to see the interactive interface of MaixPy. Input help(), you can view help To exit minicom, press Ctrl+A X, press Enter confirm to exit Furthermore, you can sepecify device by -D parameter, e.g. minicom -D /dev/ttyUSB1 -b 115200 Windows Use tools like putty or xshell Then select the serial port mode, then set the serial port and baud rate to open the serial port. Then click the Enter button to see the interactive interface of MaixPy. >>> Input help(), you can view help picture from laurentopia's tutorial powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/maixpyide.html":{"url":"get_started/maixpyide.html","title":"Install MaixPyIDE(optional)","keywords":"","body":"MaixPy IDE MaixPy uses the Micropython syntax, and unlike other languages like C, it doesn't need to be compiled. In fact, you don't even need the IDE to use it, you can use the serial terminal. Using the IDE will facilitate real-time editing of the script on the computer, as well as being able to view the camera images in real time, and save files to the development board. Of course, using the IDE will take some resources from the board (for the transmission and debugging), MaixPy firmware To use the MaixPy IDE , the firmware must be at least v0.3.1, otherwise it won't connect. Check the firmware and IDE version before using it, to ensure normal operation. Download the installation package dl.sipeed.com Check the latest version by reading the readme.txt file. Use CDN link if download too slowly. Installation Using the installer (Recommended, simple and convenient) For Windows run the installer directly by double-clicking the file. For Linux you will need to give the file permission and execute it using the command line: chmod +x maixpy-ide-linux-x86_64-0.2.2.run ./maixpy-ide-linux-x86_64-0.2.2.run Using a compressed package (7z) Extract the file to a folder If your system does not support 7z， you will need to download 7z and install it. If on Linux, you can use the terminal to decompress the file: sudo apt install p7zip-full 7z x maixpy-ide-linux-x86_64-0.2.2-installer-archive.7z -r -omaixpy-ide # `-o` is immediately followed by the decompressed path, there is no space in between. After decompression, execute: On Windows： Double-click maixpyide to execute. You might want to right-click and pin it to the taskbar or start menu. On Linux： Use the following commands:chmod +x setup.sh ./setup.sh ./bin/maipyide.sh Test run Open the IDE and select the model number of the development board in the upper toolbar. Tool-> Select Board Click on connect to make a connection with the MaixPy IDE After the connection is successful, the button will turn from green to red. Below the connection button is the Run button, which will execute the current py file opened in the editor. Click the Run button again to stop the execution. Uploading files You will find ways to upload files in the Tool dropdown menu. Note Only open one serial port connection at a time, make sure to close the previous connection before opening a new one. And try to upgrade firmware or IDE if connect fail. Find the cause according to the error message When the program runs error, a message box will prompt the error, but the error information may not be complete, please find more detailed error information in the terminal output If necessary, disconnect the IDE and run the program using the serial terminal(maybe you need save as file then run this file) only to view the print for troubleshooting If you submit an issue (bbs, group, github issue, etc.), in order to resolve the issue quickly, be sure to bring the complete information described above powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/power_on.html":{"url":"get_started/power_on.html","title":"Power on","keywords":"","body":"Power Connect hardware Connect development board to computer with Type C cable Check if the device has been properly identified: Under Linux can ls /dev/ttyUSB* or ls /dev/ttyACM* to see, if not you can ls /dev come look for the specific device name with the relevant serial chip and drive， and you can use sudo dmesg to find device mount message If Windows, just open Device Manager to view If the device is not found, you need to confirm if the driver is installed and if the connection is good. Check firmware version Open serial terminal tool, push reset button of board, compare togithub or master branch to check firmware version e.g. [MaixPy] init end __ __ _____ __ __ _____ __ __ | \\/ | /\\ |_ _| \\ \\ / / | __ \\ \\ \\ / / | \\ / | / \\ | | \\ V / | |__) | \\ \\_/ / | |\\/| | / /\\ \\ | | > Version is v0.5.0-12-g284ce83, or you can get version by code: import sys sys.implementation.version Exevute script(code) Open terminal, after push down the reset button, we can see: >>> this means we can input code now, if no this symbol, type in Ctrl+C to cacel running script Then input hello world program >>> print(\"hello world\") hello world >>> Paste multiple lines of code If we need paste code like import os f = os.listdir() print(f) Copy code Type in Ctrl+E Paste code Type in Ctrl+D to execute code >>> paste mode; Ctrl-C to cancel, Ctrl-D to finish === import os === f = os.listdir() === print(f) ['boot.py','main.py', 'freq.conf'] >>> If code is too large, the serial port may lose data, which will cause a syntax error prompt. You can try more times powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/led_blink.html":{"url":"get_started/led_blink.html","title":"LED blink","keywords":"","body":"Lighting the LED The lighting program is the first program to learn all the development boards. Just like learning all programming languages, learning the hello world is a sacred meaning. Circuit diagram It is well known that lighting an LED requires a power supply, a resistor, and an LED bulb. On the Dan Dock development board, there are three LEDs, the lines are as follows: For example, we want to red light, i.e., LED_R connected to the LED, the LED can be seen in FIG positive 3.3V power supply has been connected, so long as we can LED_R LED lighting is low. Note that LED_R is an alias for this pin, which is actually a pin connected to the chip, such as Pin13(13) Config FPIOA(Field Programmable Input and Output Array) Before writing the program, we need to know that the corresponding pins of the on-chip peripherals (such as GPIO, I2C, etc.) of the hardware K210 used by MaixPy can be arbitrarily set. The STM32 on-chip peripherals and pin correspondences have been fixed. Some of the pins can be multiplexed, compared to the K210 with greater degrees of freedom. For example, I2C can use Pin11 and Pin12, or can be changed to any other pin. Code We control the LEDs and need to use GPIO The procedure is as follows: from Maix import GPIO fm.register(board_info.LED_R, fm.fpioa.GPIO0) led_r=GPIO(GPIO.GPIO0,GPIO.OUT) led_r.value(0) We only need to click the lines of the code one by one to the keyboard inside the terminal and press OK to execute. Among them, we start with the package Maix introduced GPIO this class; Front pin can be set K210, so we use .fm(fpioa manager) correspondence between peripherals and pin registration chip built-in object to this, here　fm.fpioa.GPIO0 is a GPIO Peripheral K210's ( Note the difference between GPIO (peripheral) and pin (real hardware pin)), so the fm.fpioa.GPIO0 registration to pin board_info.LED_R; Here board_info is a board type information can be entered in serial terminal board_info. then press TAB the button to see all the members, or just use pin number like 13. Then define a GPIO subject, specific parameters to see GPIO the module's documentation, look in the left sidebar. Use led_r.value(0) or led_r.value(1) to set high to low It is already possible to light up here. If you know the Python syntax, you can try to write a for loop to achieve LED flashing~ powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/edit_file.html":{"url":"get_started/edit_file.html","title":"Edit and execute files","keywords":"","body":"Editing, saving and executing files This section teaches you how to edit, save and execute files. REPL interface To keep things simple in the previous example, we entered code directly in the terminal at the Maix prompt which was executed immediately upon pressing the Enter key. Such interactive command line interfaces are often referred to as REPL（Read Eval Print Loop). MaixPy's REPL interface operates similar to most other command line interfaces except that the supported syntax is MicroPython While MaixPy's REPL interface is simple and convenient for small tasks, it soon becomes annoying to re-enter your code each time you want to run it. The solution is to save your code to a file, and then execute the file. The remainder of this page describes that process. MaixPy file system MaixPy devices have an internal file system which can access both internal and external memories. During boot, the device will mount any external memory cards formatted with either SPIFFS or FAT file systems, and add them to the internal file system as the /flash or /sd directories respectively. NOTES: SPIFFS cards are by default assigned to 3MB SPIFFS (starting at flash address 0xD00000). When detected at boot, SPIFFS devices automatically appear as the /flash directory within the device's internal file system. Currently the SPIFFS implementation in MaixPy does not support the creation of directories. FAT formatted SD (TF) cards are supported, but FAT32 or exFAT formatted cards are not currently supported. When detected at boot, FAT formatted cards will be automatically mounted and appear as the /sd directory in the device's internal file system. It should be noted that the root directory is only used to mount the SD card or SPIFFS flash card. All other file operations happen in the /flash or /sd directories, as determined by the format of the memory card discovered at boot time. Navigating the file system In MaixPy's REPL interface and in code the following os commands can be used to navigate directories and manage files. Command Description Example os.chdir() changes the current directory os.chdir(\"/flash\") os.listdir() list the files in the current directory os.listdir() os.listdir(path) list the files in another directory os.listdir(\"/sd\") os.getcwd() return the current working directory os.getcwd() os.rename(old_path, new_path) rename a file os.rename(\"./blue.py\", \"./aaah.py\") os.remove(path) remove a file os.remove(\"./herring.py\") For a complete list of os commands refer to the MicroPython documentation Editing and saving files There are a number of ways you can edit and save files described below as Methods A through C Method A: Edit and save files using the pye editor built into MaixPy MaixPy includes a built-in open source editor Micropython Editor(pye) At the REPL interface enter pye(\"hello.py\") to create a file and enter the edit mode. Keyboard shortcuts and other instructions can be found here Enter the following code: print(\"hello maixpy\") When you have finished editing, press Ctrl+S and then press Enter to save, and then press Ctrl+Q to exit the editor. Note : The pye editor has certain requirements of the connected terminal. For intuitive operation the BackSpace key should be configured to send Ctrl+?, otherwise the BackSpace key will function as Ctrl+H (ie: character replacement). Linux users are recommended to use minicom. Use sudo minicom -s to set the reference to the previous tutorial Windows users can use PuTTY which supports Backspace key configuration. Note Typing Shift-Backspace will cause PuTTY to send whichever code isn't configured as the default. Alternatively, Xshell users can use: File → Properties → Terminal → Keyboard, Change the delete and backspace sequences to ASCII 127. Method B: Read files to PC by uPyLoader, then download to board after editing This method uses the uPyLoader utility Download the executable: release Select the serial port and click the Connect button to connect the board The first time you run the software, you need to initialize it. Click File->Init transfer files to complete the initialization. This will create two files in the board, __upload.py and __download.py. Then double click file name to read and edit, then click the save button to download the file to board Method C: Read files to PC by rshell, edit, and then save back to board Install rshell first according to the doc of rshell sudo apt-get install python3-pip sudo pip3 install rshell rshell -p /dev/ttyUSB1 # select board serial Edit file ls /flash edit /flash/boot.py # the editor uses vim commands Execution of documents Once MicroPython files exist on the file system they may be executed using the following methods Method A: Execute using import At MaixPy's REPL interface simply enter: import hello then press Enter The hello.py file will run and should output hello maixpy But be careful, the import command can only be used once. If you want to execute the code more than once, please use Method B below. Method B: Execute using exec() Use exec() in a simple program to execute your file with open(\"hello.py\") as f: exec(f.read()) Method C: Execute using uPyLoader Just select the file, then click the execute button Method D: Execute files locally on PC using ampy ampy run script by command ampy run file_in_PC.py to execute files on PC (file won't transmit to board) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/upload_script.html":{"url":"get_started/upload_script.html","title":"Upload script","keywords":"","body":"Upload script to development board Earlier we came across the pye(\"filename.py\") command to open an editor that directly edits files in the file system. But slowly we will find that this method is only suitable for changing a small amount of code. When the amount of code is huge or we need to highlight support, it does not apply. We need to write the code on the computer and upload it to the board. There are currently several methods: Uploading scripts using the MaixPy IDE Open the MaixPy IDE and connect to the development board. Edit the file, then in the top Tools menu click Save opened file as boot.py to save the code to the development board's boot.py file. The next time the board is powered on, it will be automatically executed. You can also use the Send file option in the Tools menu to send the file. It will be saved to the development board with the same name. This script can also upload other small files. Uploading and running scripts using the graphical tool uPyLoader uPyLoader is an open source software that allows you to easily connect to MaixPy and upload, download, and execute files, monitor output, and more. Download the executable: release Select the serial port and click the Connect button to connect the board The first time you run the software you will need to initialize it. Click File -> Init transfer files to complete the initialization. This will create two files in the board, __upload.py and __download.py. On the left side select the file you want to upload and click Transfer to upload it to the board's file system. On the right side are the files inside the board, click List files to refresh the file list. To execute the script, simply select the file name and click on Execute. Click on View -> Terminal above to open the terminal to view the runtime output or send a command Using rshell tool Just as widh the linux, use the cp on rshell to copy the file to the development board. First, install rshell: sudo apt-get install python3-pip sudo pip3 install rshell rshell -p /dev/ttyUSB1 # choose the device according to your serial port Then copy file~ ls /flash cp ./test.py /flash/ # copies the file \"text.py\" from the computer to the root directory of the development board You can learn about other features of rshell in its project page. Using the command line tool ampy ampy is an open source, easy-to-use command line tool for uploading, downloading, and executing files. Note that this tool is running on the computer, not on the board. Use ampy --help to view help and information. The ampy run file_in_PC.py command also allows you to run the script directly on the board without uploading it previously. TF card copy After copying it to the TF card, execute import filename in the terminal to run the script. powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/boot.html":{"url":"get_started/boot.html","title":"Auto start","keywords":"","body":"Boot script If a memory card formatted with either a SPIFFS or FAT file system is detected at boot, MaixPy will look for a boot.py file in the root directory of that memory card. If boot.py is found, the system will immediately execute it. And then find main.py and execute it. If the main.py file is not found, the device will automatically create one on the memory card that offers a basic REPL command line interface. Edit the contents of the main.py file on the memory card to determine what the device does when it is reset or rebooted. Notes: Memory cards must be formatted with a SPIFFS or FAT filesystem, not FAT32. FAT memory cards will have a mount point of /sd, while SPIFFS cards will appear as /flash. powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/standard/":{"url":"libs/standard/","title":"Standard library","keywords":"","body":"standard libs cmath gc math sys ubinascii ucollections uctypes uerrno uheapq ujson uos ure uselect ustruct utime uzlib powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/standard/cmath.html":{"url":"libs/standard/cmath.html","title":"cmath","keywords":"","body":"cmath – mathematical functions for complex numbers This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: cmath. The cmath module provides some basic mathematical functions for working with complex numbers. Availability: not available on WiPy and ESP8266. Floating point support required for this module. Functions cos cmath.cos(z) Return the cosine of z. exp cmath.exp(z) Return the exponential of z. log cmath.log(z) Return the natural logarithm of z. The branch cut is along the negative real axis. log10 cmath.log10(z) Return the base-10 logarithm of z. The branch cut is along the negative real axis. phase cmath.phase(z) Returns the phase of the number z, in the range (-pi, +pi]. polar cmath.polar(z) Returns, as a tuple, the polar form of z. rect cmath.rect(r, phi) Returns the complex number with modulus r and phase phi. sin cmath.sin(z) Return the sine of z. sqrt cmath.sqrt(z) Return the square-root of z. Constants cmath.e base of the natural logarithm cmath.pi the ratio of a circle’s circumference to its diameter powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/standard/gc.html":{"url":"libs/standard/gc.html","title":"gc","keywords":"","body":"gc – control the garbage collector This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: gc. Functions gc.enable() Enable automatic garbage collection. gc.disable() Disable automatic garbage collection. Heap memory can still be allocated, and garbage collection can still be initiated manually using gc.collect(). gc.collect() Run a garbage collection. gc.mem_alloc() Return the number of bytes of heap RAM that are allocated. Difference to CPython This function is MicroPython extension. gc.mem_free() Return the number of bytes of available heap RAM, or -1 if this amount is not known. Difference to CPython This function is MicroPython extension. gc.threshold([amount]) Set or query the additional GC allocation threshold. Normally, a collection is triggered only when a new allocation cannot be satisfied, i.e. on an out-of-memory (OOM) condition. If this function is called, in addition to OOM, a collection will be triggered each time after amount bytes have been allocated (in total, since the previous time such an amount of bytes have been allocated). amount is usually specified as less than the full heap size, with the intention to trigger a collection earlier than when the heap becomes exhausted, and in the hope that an early collection will prevent excessive memory fragmentation. This is a heuristic measure, the effect of which will vary from application to application, as well as the optimal value of the amount parameter. Calling the function without argument will return the current value of the threshold. A value of -1 means a disabled allocation threshold. Difference to CPython This function is a MicroPython extension. CPython has a similar function - set_threshold(), but due to different GC implementations, its signature and semantics are different. powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/standard/math.html":{"url":"libs/standard/math.html","title":"math","keywords":"","body":"math – mathematical functions This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: math. The math module provides some basic mathematical functions for working with floating-point numbers. Note: On the pyboard, floating-point numbers have 32-bit precision. Availability: not available on WiPy. Floating point support required for this module. Functions math.acos(x) Return the inverse cosine of x. math.acosh(x) Return the inverse hyperbolic cosine of x. math.asin(x) Return the inverse sine of x. math.asinh(x) Return the inverse hyperbolic sine of x. math.atan(x) Return the inverse tangent of x. math.atan2(y, x) Return the principal value of the inverse tangent of y/x. math.atanh(x) Return the inverse hyperbolic tangent of x. math.ceil(x) Return an integer, being x rounded towards positive infinity. math.copysign(x, y) Return x with the sign of y. math.cos(x) Return the cosine of x. math.cosh(x) Return the hyperbolic cosine of x. math.degrees(x) Return radians x converted to degrees. math.erf(x) Return the error function of x. math.erfc(x) Return the complementary error function of x. math.exp(x) Return the exponential of x. math.expm1(x) Return exp(x) - 1. math.fabs(x) Return the absolute value of x. math.floor(x) Return an integer, being x rounded towards negative infinity. math.fmod(x, y) Return the remainder of x/y. math.frexp(x) Decomposes a floating-point number into its mantissa and exponent. The returned value is the tuple (m, e) such that x == m * 2**e exactly. If x == 0 then the function returns (0.0, 0), otherwise the relation 0.5 holds. math.gamma(x) Return the gamma function of x. math.isfinite(x) Return True if x is finite. math.isinf(x) Return True if x is infinite. math.isnan(x) Return True if x is not-a-number math.ldexp(x, exp) Return x * (2**exp). math.lgamma(x) Return the natural logarithm of the gamma function of x. math.log(x) Return the natural logarithm of x. math.log10(x) Return the base-10 logarithm of x. math.log2(x) Return the base-2 logarithm of x. math.modf(x) Return a tuple of two floats, being the fractional and integral parts of x. Both return values have the same sign as x. math.pow(x, y) Returns x to the power of y. math.radians(x) Return degrees x converted to radians. math.sin(x) Return the sine of x. math.sinh(x) Return the hyperbolic sine of x. math.sqrt(x) Return the square root of x. math.tan(x) Return the tangent of x. math.tanh(x) Return the hyperbolic tangent of x. math.trunc(x) Return an integer, being x rounded towards 0. Constants math.e base of the natural logarithm math.pi the ratio of a circle’s circumference to its diameter powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/standard/sys.html":{"url":"libs/standard/sys.html","title":"sys","keywords":"","body":"sys – system specific functions This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: sys. Functions sys.exit(retval=0) Terminate current program with a given exit code. Underlyingly, this function raise as SystemExit exception. If an argument is given, its value given as an argument to SystemExit. sys.print_exception(exc, file=sys.stdout) Print exception with a traceback to a file-like object file (or sys.stdout by default). Difference to CPython This is simplified version of a function which appears in the traceback module in CPython. Unlike traceback.print_exception(), this function takes just exception value instead of exception type, exception value, and traceback object; file argument should be positional; further arguments are not supported. CPython-compatible traceback module can be found in micropython-lib. Constants sys.argv A mutable list of arguments the current program was started with. sys.byteorder The byte order of the system (\"little\" or \"big\"). sys.implementation Object with information about the current Python implementation. For MicroPython, it has following attributes: name - string “micropython” version - tuple (major, minor, micro), e.g. (1, 7, 0) This object is the recommended way to distinguish MicroPython from other Python implementations (note that it still may not exist in the very minimal ports). Difference to CPython CPython mandates more attributes for this object, but the actual useful bare minimum is implemented in MicroPython. sys.maxsize Maximum value which a native integer type can hold on the current platform, or maximum value representable by MicroPython integer type, if it’s smaller than platform max value (that is the case for MicroPython ports without long int support). This attribute is useful for detecting “bitness” of a platform (32-bit vs 64-bit, etc.). It’s recommended to not compare this attribute to some value directly, but instead count number of bits in it: bits = 0 v = sys.maxsize while v: bits += 1 v >>= 1 if bits > 32: # 64-bit (or more) platform ... else: # 32-bit (or less) platform # Note that on 32-bit platform, value of bits may be less than 32 # (e.g. 31) due to peculiarities described above, so use \"> 16\", # \"> 32\", \"> 64\" style of comparisons. sys.modules Dictionary of loaded modules. On some ports, it may not include builtin modules. sys.path A mutable list of directories to search for imported modules. sys.platform The platform that MicroPython is running on. For OS/RTOS ports, this is usually an identifier of the OS, e.g. \"linux\". For baremetal ports it is an identifier of a board, e.g. \"pyboard\" for the original MicroPython reference board. It thus can be used to distinguish one board from another. If you need to check whether your program runs on MicroPython (vs other Python implementation), use sys.implementation instead. sys.stderr Standard error stream. sys.stdin Standard input stream. sys.stdout Standard output stream. sys.version Python language version that this implementation conforms to, as a string. sys.version_info Python language version that this implementation conforms to, as a tuple of ints. powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/standard/ubinascii.html":{"url":"libs/standard/ubinascii.html","title":"ubinascii","keywords":"","body":"ubinascii – binary/ASCII conversions This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: binascii. This module implements conversions between binary data and various encodings of it in ASCII form (in both directions). Functions ubinascii.hexlify(data[, sep]) Convert binary data to hexadecimal representation. Returns bytes string. Difference to CPython If additional argument, sep is supplied, it is used as a separator between hexadecimal values. ubinascii.unhexlify(data) Convert hexadecimal data to binary representation. Returns bytes string. (i.e. inverse of hexlify) ubinascii.a2b_base64(data) Decode base64-encoded data, ignoring invalid characters in the input. Conforms to RFC 2045 s.6.8. Returns a bytes object. ubinascii.b2a_base64(data) Encode binary data in base64 format, as in RFC 3548. Returns the encoded data followed by a newline character, as a bytes object. powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/standard/ucollections.html":{"url":"libs/standard/ucollections.html","title":"ucollections","keywords":"","body":"ucollections – collection and container types This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: collections. This module implements advanced collection and container types to hold/accumulate various objects. Classes ucollections.deque(iterable, maxlen[, flags]) Deques (double-ended queues) are a list-like container that support O(1) appends and pops from either side of the deque. New deques are created using the following arguments: iterable must be the empty tuple, and the new deque is created empty. maxlen must be specified and the deque will be bounded to this maximum length. Once the deque is full, any new items added will discard items from the opposite end. The optional flags can be 1 to check for overflow when adding items. As well as supporting bool and len, deque objects have the following methods: deque.append(x) Add x to the right side of the deque. Raises IndexError if overflow checking is enabled and there is no more room left. deque.popleft() Remove and return an item from the left side of the deque. Raises IndexError if no items are present. ucollections.namedtuple(name, fields) This is factory function to create a new namedtuple type with a specific name and set of fields. A namedtuple is a subclass of tuple which allows to access its fields not just by numeric index, but also with an attribute access syntax using symbolic field names. Fields is a sequence of strings specifying field names. For compatibility with CPython it can also be a a string with space-separated field named (but this is less efficient). Example of use: from ucollections import namedtuple MyTuple = namedtuple(\"MyTuple\", (\"id\", \"name\")) t1 = MyTuple(1, \"foo\") t2 = MyTuple(2, \"bar\") print(t1.name) assert t2.name == t2[1] ucollections.OrderedDict(...) dict type subclass which remembers and preserves the order of keys added. When ordered dict is iterated over, keys/items are returned in the order they were added: from ucollections import OrderedDict # To make benefit of ordered keys, OrderedDict should be initialized # from sequence of (key, value) pairs. d = OrderedDict([(\"z\", 1), (\"a\", 2)]) # More items can be added as usual d[\"w\"] = 5 d[\"b\"] = 3 for k, v in d.items(): print(k, v) Output: z 1 a 2 w 5 b 3 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/standard/uctypes.html":{"url":"libs/standard/uctypes.html","title":"uctypes","keywords":"","body":"uctypes – access binary data in a structured way This module implements “foreign data interface” for MicroPython. The idea behind it is similar to CPython’s ctypes modules, but the actual API is different, streamlined and optimized for small size. The basic idea of the module is to define data structure layout with about the same power as the C language allows, and then access it using familiar dot-syntax to reference sub-fields. Warning uctypes module allows access to arbitrary memory addresses of the machine (including I/O and control registers). Uncareful usage of it may lead to crashes, data loss, and even hardware malfunction. See also Module ustruct Standard Python way to access binary data structures (doesn’t scale well to large and complex structures). Usage examples: import uctypes # Example 1: Subset of ELF file header # https://wikipedia.org/wiki/Executable_and_Linkable_Format#File_header ELF_HEADER = { \"EI_MAG\": (0x0 | uctypes.ARRAY, 4 | uctypes.UINT8), \"EI_DATA\": 0x5 | uctypes.UINT8, \"e_machine\": 0x12 | uctypes.UINT16, } # \"f\" is an ELF file opened in binary mode buf = f.read(uctypes.sizeof(ELF_HEADER, uctypes.LITTLE_ENDIAN)) header = uctypes.struct(uctypes.addressof(buf), ELF_HEADER, uctypes.LITTLE_ENDIAN) assert header.EI_MAG == b\"\\x7fELF\" assert header.EI_DATA == 1, \"Oops, wrong endianness. Could retry with uctypes.BIG_ENDIAN.\" print(\"machine:\", hex(header.e_machine)) # Example 2: In-memory data structure, with pointers COORD = { \"x\": 0 | uctypes.FLOAT32, \"y\": 4 | uctypes.FLOAT32, } STRUCT1 = { \"data1\": 0 | uctypes.UINT8, \"data2\": 4 | uctypes.UINT32, \"ptr\": (8 | uctypes.PTR, COORD), } # Suppose you have address of a structure of type STRUCT1 in \"addr\" # uctypes.NATIVE is optional (used by default) struct1 = uctypes.struct(addr, STRUCT1, uctypes.NATIVE) print(\"x:\", struct1.ptr[0].x) # Example 3: Access to CPU registers. Subset of STM32F4xx WWDG block WWDG_LAYOUT = { \"WWDG_CR\": (0, { # BFUINT32 here means size of the WWDG_CR register \"WDGA\": 7 Defining structure layout Structure layout is defined by a “descriptor” - a Python dictionary which encodes field names as keys and other properties required to access them as associated values: { \"field1\": , \"field2\": , ... } Currently, uctypes requires explicit specification of offsets for each field. Offset are given in bytes from the structure start. Following are encoding examples for various field types: Scalar types: \"field_name\": offset | uctypes.UINT32 in other words, the value is a scalar type identifier ORed with a field offset (in bytes) from the start of the structure. Recursive structures: \"sub\": (offset, { \"b0\": 0 | uctypes.UINT8, \"b1\": 1 | uctypes.UINT8, }) i.e. value is a 2-tuple, first element of which is an offset, and second is a structure descriptor dictionary (note: offsets in recursive descriptors are relative to the structure it defines). Of course, recursive structures can be specified not just by a literal dictionary, but by referring to a structure descriptor dictionary (defined earlier) by name. Arrays of primitive types: \"arr\": (offset | uctypes.ARRAY, size | uctypes.UINT8), i.e. value is a 2-tuple, first element of which is ARRAY flag ORed with offset, and second is scalar element type ORed number of elements in the array. Arrays of aggregate types: \"arr2\": (offset | uctypes.ARRAY, size, {\"b\": 0 | uctypes.UINT8}), i.e. value is a 3-tuple, first element of which is ARRAY flag ORed with offset, second is a number of elements in the array, and third is a descriptor of element type. Pointer to a primitive type: \"ptr\": (offset | uctypes.PTR, uctypes.UINT8), i.e. value is a 2-tuple, first element of which is PTR flag ORed with offset, and second is a scalar element type. Pointer to an aggregate type: \"ptr2\": (offset | uctypes.PTR, {\"b\": 0 | uctypes.UINT8}), i.e. value is a 2-tuple, first element of which is PTR flag ORed with offset, second is a descriptor of type pointed to. Bitfields: \"bitf0\": offset | uctypes.BFUINT16 | lsbit i.e. value is a type of scalar value containing given bitfield (typenames are similar to scalar types, but prefixes with BF), ORed with offset for scalar value containing the bitfield, and further ORed with values for bit position and bit length of the bitfield within the scalar value, shifted by BF_POS and BF_LEN bits, respectively. A bitfield position is counted from the least significant bit of the scalar (having position of 0), and is the number of right-most bit of a field (in other words, it’s a number of bits a scalar needs to be shifted right to extract the bitfield). In the example above, first a UINT16 value will be extracted at offset 0 (this detail may be important when accessing hardware registers, where particular access size and alignment are required), and then bitfield whose rightmost bit is lsbit bit of this UINT16, and length is bitsize bits, will be extracted. For example, if lsbit is 0 and bitsize is 8, then effectively it will access least-significant byte of UINT16. Note that bitfield operations are independent of target byte endianness, in particular, example above will access least-significant byte of UINT16 in both little- and big-endian structures. But it depends on the least significant bit being numbered 0. Some targets may use different numbering in their native ABI, but uctypes always uses the normalized numbering described above. Module contents class uctypes.struct(addr, descriptor, layout_type=NATIVE) Instantiate a “foreign data structure” object based on structure address in memory, descriptor (encoded as a dictionary), and layout type (see below). uctypes.LITTLE_ENDIAN Layout type for a little-endian packed structure. (Packed means that every field occupies exactly as many bytes as defined in the descriptor, i.e. the alignment is 1). uctypes.BIG_ENDIAN Layout type for a big-endian packed structure. uctypes.NATIVE Layout type for a native structure - with data endianness and alignment conforming to the ABI of the system on which MicroPython runs. uctypes.sizeof(struct, layout_type=NATIVE) Return size of data structure in bytes. The struct argument can be either a structure class or a specific instantiated structure object (or its aggregate field). uctypes.addressof(obj) Return address of an object. Argument should be bytes, bytearray or other object supporting buffer protocol (and address of this buffer is what actually returned). uctypes.bytes_at(addr, size) Capture memory at the given address and size as bytes object. As bytes object is immutable, memory is actually duplicated and copied into bytes object, so if memory contents change later, created object retains original value. uctypes.bytearray_at(addr, size) Capture memory at the given address and size as bytearray object. Unlike bytes_at() function above, memory is captured by reference, so it can be both written too, and you will access current value at the given memory address. uctypes.UINT8 uctypes.INT8 uctypes.UINT16 uctypes.INT16 uctypes.UINT32 uctypes.INT32 uctypes.UINT64 uctypes.INT64 Integer types for structure descriptors. Constants for 8, 16, 32, and 64 bit types are provided, both signed and unsigned. uctypes.FLOAT32 uctypes.FLOAT64 Floating-point types for structure descriptors. uctypes.VOID VOID is an alias for UINT8, and is provided to conviniently define C’s void pointers: (uctypes.PTR, uctypes.VOID). uctypes.PTR uctypes.ARRAY Type constants for pointers and arrays. Note that there is no explicit constant for structures, it’s implicit: an aggregate type without PTR or ARRAY flags is a structure. Structure descriptors and instantiating structure objects Given a structure descriptor dictionary and its layout type, you can instantiate a specific structure instance at a given memory address using uctypes.struct() constructor. Memory address usually comes from following sources: Predefined address, when accessing hardware registers on a baremetal system. Lookup these addresses in datasheet for a particular MCU/SoC. As a return value from a call to some FFI (Foreign Function Interface) function. From uctypes.addressof(), when you want to pass arguments to an FFI function, or alternatively, to access some data for I/O (for example, data read from a file or network socket). Structure objects Structure objects allow accessing individual fields using standard dot notation: my_struct.substruct1.field1. If a field is of scalar type, getting it will produce a primitive value (Python integer or float) corresponding to the value contained in a field. A scalar field can also be assigned to. If a field is an array, its individual elements can be accessed with the standard subscript operator [] - both read and assigned to. If a field is a pointer, it can be dereferenced using [0] syntax (corresponding to C * operator, though [0] works in C too). Subscripting a pointer with other integer values but 0 are also supported, with the same semantics as in C. Summing up, accessing structure fields generally follows the C syntax, except for pointer dereference, when you need to use [0] operator instead of *. Limitations Accessing non-scalar fields leads to allocation of intermediate objects to represent them. This means that special care should be taken to layout a structure which needs to be accessed when memory allocation is disabled (e.g. from an interrupt). The recommendations are: Avoid accessing nested structures. For example, instead of mcu_registers.peripheral_a.register1, define separate layout descriptors for each peripheral, to be accessed as peripheral_a.register1. Or just cache a particular peripheral: peripheral_a = mcu_registers.peripheral_a. If a register consists of multiple bitfields, you would need to cache references to a particular register: reg_a = mcu_registers.peripheral_a.reg_a. Avoid other non-scalar data, like arrays. For example, instead of peripheral_a.register[0] use peripheral_a.register0. Again, an alternative is to cache intermediate values, e.g. register0 = peripheral_a.register[0]. Range of offsets supported by the uctypes module is limited. The exact range supported is considered an implementation detail, and the general suggestion is to split structure definitions to cover from a few kilobytes to a few dozen of kilobytes maximum. In most cases, this is a natural situation anyway, e.g. it doesn’t make sense to define all registers of an MCU (spread over 32-bit address space) in one structure, but rather a peripheral block by peripheral block. In some extreme cases, you may need to split a structure in several parts artificially (e.g. if accessing native data structure with multi-megabyte array in the middle, though that would be a very synthetic case).) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/standard/uerrno.html":{"url":"libs/standard/uerrno.html","title":"uerrno","keywords":"","body":"uerrno — system error codes This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: errno. This module provides access to symbolic error codes for OSError exception. A particular inventory of codes depends on MicroPython port， Will explain the specific function that will cause an error. Constants EEXIST, EAGAIN, etc. Error codes, based on ANSI C/POSIX standard. All error codes start with “E”. As mentioned above, inventory of the codes depends on MicroPython port. Errors are usually accessible as exc.args[0] where exc is an instance of OSError. Usage example: try: uos.mkdir(\"my_dir\") except OSError as exc: if exc.args[0] == uerrno.EEXIST: print(\"Directory already exists\") uerrno.errorcode Dictionary mapping numeric error codes to strings with symbolic error code (see above): >>> print(uerrno.errorcode[uerrno.EEXIST]) EEXIST powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/standard/uhashlib.html":{"url":"libs/standard/uhashlib.html","title":"uhashlib","keywords":"","body":"uhashlib – hashing algorithms This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: hashlib. This module implements binary data hashing algorithms. The exact inventory of available algorithms depends on a board. Among the algorithms which may be implemented: SHA256 - The current generation, modern hashing algorithm (of SHA2 series). It is suitable for cryptographically-secure purposes. Included in the MicroPython core and any board is recommended to provide this, unless it has particular code size constraints. Hardware accelerate is enabled on K210. Constructors class uhashlib.sha256([data]) Create an SHA256 hasher object and optionally feed data into it. Methods hash.update(data) Feed more binary data into hash. hash.digest() Return hash for all data passed through hash, as a bytes object. After this method is called, more data cannot be fed into the hash any longer. hash.hexdigest() This method is NOT implemented. Use ubinascii.hexlify(hash.digest()) to achieve a similar effect. powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/standard/uheapq.html":{"url":"libs/standard/uheapq.html","title":"uheapq","keywords":"","body":"uheapq – heap queue algorithm This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: heapq. This module implements the heap queue algorithm. A heap queue is simply a list that has its elements stored in a certain way. Functions heappush uheapq.heappush(heap, item) Push the item onto the heap. heappop uheapq.heappop(heap) Pop the first item from the heap, and return it. Raises IndexError if heap is empty. heapify uheapq.heapify(x) Convert the list x into a heap. This is an in-place operation. powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/standard/ujson.html":{"url":"libs/standard/ujson.html","title":"ujson","keywords":"","body":"ujson – JSON encoding and decoding This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: json. This modules allows to convert between Python objects and the JSON data format. Functions dump ujson.dump(obj, stream) Serialise obj to a JSON string, writing it to the given stream. dumps ujson.dumps(obj) Return obj represented as a JSON string. load ujson.load(stream) Parse the given stream, interpreting it as a JSON string and deserialising the data to a Python object. The resulting object is returned. Parsing continues until end-of-file is encountered. A ValueError is raised if the data in stream is not correctly formed. loads ujson.loads(str) Parse the JSON str and return an object. Raises ValueError if the string is not correctly formed. powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/standard/uos.html":{"url":"libs/standard/uos.html","title":"uos","keywords":"","body":"uos – basic “operating system” services This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: os. The uos module contains functions for filesystem access and mounting, terminal redirection and duplication, and the uname and urandom functions. General functions uos.uname() Return a tuple (possibly a named tuple) containing information about the underlying machine and/or its operating system. The tuple has five fields in the following order, each of them being a string: sysname – the name of the underlying system nodename – the network name (can be the same as sysname) release – the version of the underlying system version – the MicroPython version and build date machine – an identifier for the underlying hardware (eg board, CPU) uos.urandom(n) Return a bytes object with n random bytes. Whenever possible, it is generated by the hardware random number generator. Filesystem access uos.chdir(path) Change current directory. uos.getcwd() Get the current directory. uos.ilistdir([dir]) This function returns an iterator which then yields tuples corresponding to the entries in the directory that it is listing. With no argument it lists the current directory, otherwise it lists the directory given by dir. The tuples have the form (name, type, inode[, size]): name is a string (or bytes if dir is a bytes object) and is the name of the entry; type is an integer that specifies the type of the entry, with 0x4000 for directories and 0x8000 for regular files; inode is an integer corresponding to the inode of the file, and may be 0 for filesystems that don’t have such a notion. Some platforms may return a 4-tuple that includes the entry’s size. For file entries, size is an integer representing the size of the file or -1 if unknown. Its meaning is currently undefined for directory entries. uos.listdir([dir]) With no argument, list the current directory. Otherwise list the given directory. uos.mkdir(path) Create a new directory. uos.remove(path) Remove a file. uos.rmdir(path) Remove a directory. uos.rename(old_path, new_path) Rename a file. uos.stat(path) Get the status of a file or directory. uos.statvfs(path) Get the status of a fileystem. Returns a tuple with the filesystem information in the following order: f_bsize – file system block size f_frsize – fragment size f_blocks – size of fs in f_frsize units f_bfree – number of free blocks f_bavail – number of free blocks for unpriviliged users f_files – number of inodes f_ffree – number of free inodes f_favail – number of free inodes for unpriviliged users f_flag – mount flags f_namemax – maximum filename length Parameters related to inodes: f_files, f_ffree, f_avail and the f_flags parameter may return 0 as they can be unavailable in a port-specific implementation. uos.sync() Sync all filesystems. Terminal redirection and duplication uos.dupterm(stream_object, index=0) Duplicate or switch the MicroPython terminal (the REPL) on the given stream-like object. The stream_object argument must implement the readinto() and write() methods. The stream should be in non-blocking mode and readinto() should return None if there is no data available for reading. After calling this function all terminal output is repeated on this stream, and any input that is available on the stream is passed on to the terminal input. The index parameter should be a non-negative integer and specifies which duplication slot is set. A given port may implement more than one slot (slot 0 will always be available) and in that case terminal input and output is duplicated on all the slots that are set. If None is passed as the stream_object then duplication is cancelled on the slot given by index. The function returns the previous stream-like object in the given slot. Filesystem mounting Some ports provide a Virtual Filesystem (VFS) and the ability to mount multiple “real” filesystems within this VFS. Filesystem objects can be mounted at either the root of the VFS, or at a subdirectory that lives in the root. This allows dynamic and flexible configuration of the filesystem that is seen by Python programs. Ports that have this functionality provide the mount() and umount() functions, and possibly various filesystem implementations represented by VFS classes. uos.mount(fsobj, mount_point, *, readonly) Mount the filesystem object fsobj at the location in the VFS given by the mount_point string. fsobj can be a a VFS object that has a mount() method, or a block device. If it’s a block device then the filesystem type is automatically detected (an exception is raised if no filesystem was recognised). mount_point may be '/' to mount fsobj at the root, or '/' to mount it at a subdirectory under the root. If readonly is True then the filesystem is mounted read-only. During the mount process the method mount() is called on the filesystem object. Will raise OSError(EPERM) if mount_point is already mounted. uos.umount(mount_point) Unmount a filesystem. mount_point can be a string naming the mount location, or a previously-mounted filesystem object. During the unmount process the method umount() is called on the filesystem object. Will raise OSError(EINVAL) if mount_point is not found. class uos.VfsFat(block_dev) Create a filesystem object that uses the FAT filesystem format. Storage of the FAT filesystem is provided by block_dev. Objects created by this constructor can be mounted using mount(). static mkfs(block_dev) Build a FAT filesystem on block_dev. Block devices A block device is an object which implements the block protocol, which is a set of methods described below by the AbstractBlockDev class. A concrete implementation of this class will usually allow access to the memory-like functionality a piece of hardware (like flash memory). A block device can be used by a particular filesystem driver to store the data for its filesystem. class uos.AbstractBlockDev(...) Construct a block device object. The parameters to the constructor are dependent on the specific block device. readblocks(block_num, buf) Starting at the block given by the index block_num, read blocks from the device into buf (an array of bytes). The number of blocks to read is given by the length of buf, which will be a multiple of the block size. writeblocks(block_num, buf) Starting at the block given by the index block_num, write blocks from buf (an array of bytes) to the device. The number of blocks to write is given by the length of buf, which will be a multiple of the block size. ioctl(op, arg) Control the block device and query its parameters. The operation to perform is given by op which is one of the following integers: 1 – initialise the device (arg is unused) 2 – shutdown the device (arg is unused) 3 – sync the device (arg is unused) 4 – get a count of the number of blocks, should return an integer (arg is unused) 5 – get the number of bytes in a block, should return an integer, or None in which case the default value of 512 is used (arg is unused) By way of example, the following class will implement a block device that stores its data in RAM using a bytearray: class RAMBlockDev: def __init__(self, block_size, num_blocks): self.block_size = block_size self.data = bytearray(block_size * num_blocks) def readblocks(self, block_num, buf): for i in range(len(buf)): buf[i] = self.data[block_num * self.block_size + i] def writeblocks(self, block_num, buf): for i in range(len(buf)): self.data[block_num * self.block_size + i] = buf[i] def ioctl(self, op, arg): if op == 4: # get number of blocks return len(self.data) // self.block_size if op == 5: # get block size return self.block_size It can be used as follows: import uos bdev = RAMBlockDev(512, 50) uos.VfsFat.mkfs(bdev) vfs = uos.VfsFat(bdev) uos.mount(vfs, '/ramdisk') powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/standard/ure.html":{"url":"libs/standard/ure.html","title":"ure","keywords":"","body":"ure – simple regular expressions This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: re. This module implements regular expression operations. Regular expression syntax supported is a subset of CPython re module (and actually is a subset of POSIX extended regular expressions). Supported operators and special sequences . : Match any character. [...] : Match set of characters. Individual characters and ranges are supported, including negated sets (e.g. [^a-c]). ^ : Match the start of the string. $ : Match the end of the string. ? : Match zero or one of the previous sub-pattern. * : Match zero or more of the previous sub-pattern. + : Match one or more of the previous sub-pattern. ?? : Non-greedy version of ?, match zero or one, with the preference for zero. *? : Non-greedy version of *, match zero or more, with the preference for the shortest match. +? : Non-greedy version of +, match one or more, with the preference for the shortest match. | : Match either the left-hand side or the right-hand side sub-patterns of this operator. (...) : Grouping. Each group is capturing (a substring it captures can be accessed with match.group() method). \\d : Matches digit. Equivalent to [0-9]. \\D : Matches non-digit. Equivalent to [^0-9]. \\s : Matches whitespace. Equivalent to [ \\t-\\r]. \\S : Matches non-whitespace. Equivalent to [^ \\t-\\r]. \\w : Matches “word characters” (ASCII only). Equivalent to [A-Za-z0-9_]. \\W : Matches non “word characters” (ASCII only). Equivalent to [^A-Za-z0-9_]. \\ : Escape character. Any other character following the backslash, except for those listed above, is taken literally. For example, \\* is equivalent to literal * (not treated as the * operator). Note that \\r, \\n, etc. are not handled specially, and will be equivalent to literal letters r, n, etc. Due to this, it’s not recommended to use raw Python strings (r\"\") for regular expressions. For example, r\"\\r\\n\" when used as the regular expression is equivalent to \"rn\". To match CR character followed by LF, use \"\\r\\n\". NOT SUPPORTED: counted repetitions ({m,n}) named groups ((?P...)) non-capturing groups ((?:...)) more advanced assertions (\\b, \\B) special character escapes like \\r, \\n - use Python’s own escaping instead etc. Example: import ure # As ure doesn't support escapes itself, use of r\"\" strings is not # recommended. regex = ure.compile(\"[\\r\\n]\") regex.split(\"line1\\rline2\\nline3\\r\\n\") # Result: # ['line1', 'line2', 'line3', '', ''] Functions ure.compile(regex_str[, flags]) Compile regular expression, return regex object. ure.match(regex_str, string) Compile regex_str and match against string. Match always happens from starting position in a string. ure.search(regex_str, string) Compile regex_str and search it in a string. Unlike match, this will search string for first position which matches regex (which still may be 0 if regex is anchored). ure.sub(regex_str, replace, string, count=0, flags=0) Compile regex_str and search for it in string, replacing all matches with replace, and returning the new string. replace can be a string or a function. If it is a string then escape sequences of the form \\ and \\g can be used to expand to the corresponding group (or an empty string for unmatched groups). If replace is a function then it must take a single argument (the match) and should return a replacement string. If count is specified and non-zero then substitution will stop after this many substitutions are made. The flags argument is ignored. Note: availability of this function depends on MicroPython port. ure.DEBUG Flag value, display debug information about compiled expression. (Availability depends on MicroPython port.) Regex objects Compiled regular expression. Instances of this class are created using ure.compile(). regex.match(string) regex.search(string) regex.sub(replace, string, count=0, flags=0) Similar to the module-level functions match(), search() and sub(). Using methods is (much) more efficient if the same regex is applied to multiple strings. regex.split(string, max_split=-1) Split a string using regex. If max_split is given, it specifies maximum number of splits to perform. Returns list of strings (there may be up to max_split+1 elements if it’s specified). Match objects Match objects as returned by match() and search() methods, and passed to the replacement function in sub(). match.group(index) Return matching (sub)string. index is 0 for entire match, 1 and above for each capturing group. Only numeric groups are supported. match.groups() Return a tuple containing all the substrings of the groups of the match. Note: availability of this method depends on MicroPython port. match.start([index]) match.end([index]) Return the index in the original string of the start or end of the substring group that was matched. index defaults to the entire group, otherwise it will select a group. Note: availability of these methods depends on MicroPython port. match.span([index]) Returns the 2-tuple (match.start(index), match.end(index)). Note: availability of this method depends on MicroPython port. powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/standard/uselect.html":{"url":"libs/standard/uselect.html","title":"uselect","keywords":"","body":"powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/standard/usocket.html":{"url":"libs/standard/usocket.html","title":"usocket","keywords":"","body":"usocket – socket module This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: socket. This module provides access to the BSD socket interface. Difference to CPython For efficiency and consistency, socket objects in MicroPython implement a stream (file-like) interface directly. In CPython, you need to convert a socket to a file-like object using makefile() method. This method is still supported by MicroPython (but is a no-op), so where compatibility with CPython matters, be sure to use it. Socket address format(s) The native socket address format of the usocket module is an opaque data type returned by getaddrinfo function, which must be used to resolve textual address (including numeric addresses): sockaddr = usocket.getaddrinfo('www.micropython.org', 80)[0][-1] # You must use getaddrinfo() even for numeric addresses sockaddr = usocket.getaddrinfo('127.0.0.1', 80)[0][-1] # Now you can use that address sock.connect(addr) Using getaddrinfo is the most efficient (both in terms of memory and processing power) and portable way to work with addresses. However, socket module (note the difference with native MicroPython usocket module described here) provides CPython-compatible way to specify addresses using tuples, as described below. Note that depending on a MicroPython port, socket module can be builtin or need to be installed from micropython-lib (as in the case of MicroPython Unix port), and some ports still accept only numeric addresses in the tuple format, and require to use getaddrinfo function to resolve domain names. Summing up: Always use getaddrinfo when writing portable applications. Tuple addresses described below can be used as a shortcut for quick hacks and interactive use, if your port supports them. Tuple address format for socket module: IPv4: (ipv4_address, port), where ipv4_address is a string with dot-notation numeric IPv4 address, e.g. \"8.8.8.8\", and port is and integer port number in the range 1-65535. Note the domain names are not accepted as ipv4_address, they should be resolved first using usocket.getaddrinfo(). IPv6: (ipv6_address, port, flowinfo, scopeid), where ipv6_address is a string with colon-notation numeric IPv6 address, e.g. \"2001:db8::1\", and port is an integer port number in the range 1-65535. flowinfo must be 0. scopeid is the interface scope identifier for link-local addresses. Note the domain names are not accepted as ipv6_address, they should be resolved first using usocket.getaddrinfo(). Availability of IPv6 support depends on a MicroPython port. Functions usocket.socket(af=AF_INET, type=SOCK_STREAM, proto=IPPROTO_TCP) Create a new socket using the given address family, socket type and protocol number. Note that specifying proto in most cases is not required (and not recommended, as some MicroPython ports may omit IPPROTO_* constants). Instead, type argument will select needed protocol automatically: # Create STREAM TCP socket socket(AF_INET, SOCK_STREAM) # Create DGRAM UDP socket socket(AF_INET, SOCK_DGRAM) usocket.getaddrinfo(host, port, af=0, type=0, proto=0, flags=0) Translate the host/port argument into a sequence of 5-tuples that contain all the necessary arguments for creating a socket connected to that service. Arguments af, type, and proto (which have the same meaning as for the socket() function) can be used to filter which kind of addresses are returned. If a parameter is not specified or zero, all combinations of addresses can be returned (requiring filtering on the user side). The resulting list of 5-tuples has the following structure: (family, type, proto, canonname, sockaddr) The following example shows how to connect to a given url: s = usocket.socket() # This assumes that if \"type\" is not specified, an address for # SOCK_STREAM will be returned, which may be not true s.connect(usocket.getaddrinfo('www.micropython.org', 80)[0][-1]) Recommended use of filtering params: s = usocket.socket() # Guaranteed to return an address which can be connect'ed to for # stream operation. s.connect(usocket.getaddrinfo('www.micropython.org', 80, 0, SOCK_STREAM)[0][-1]) Difference to CPython CPython raises a socket.gaierror exception (OSError subclass) in case of error in this function. MicroPython doesn’t have socket.gaierror and raises OSError directly. Note that error numbers of getaddrinfo() form a separate namespace and may not match error numbers from the uerrno module. To distinguish getaddrinfo() errors, they are represented by negative numbers, whereas standard system errors are positive numbers (error numbers are accessible using e.args[0] property from an exception object). The use of negative values is a provisional detail which may change in the future. usocket.inet_ntop(af, bin_addr) Convert a binary network address bin_addr of the given address family af to a textual representation: >>> usocket.inet_ntop(usocket.AF_INET, b\"\\x7f\\0\\0\\1\") '127.0.0.1' usocket.inet_pton(af, txt_addr) Convert a textual network address txt_addr of the given address family af to a binary representation: >>> usocket.inet_pton(usocket.AF_INET, \"1.2.3.4\") b'\\x01\\x02\\x03\\x04' Constants usocket.AF_INET usocket.AF_INET6 Address family types. Availability depends on a particular MicroPython port. usocket.SOCK_STREAM usocket.SOCK_DGRAM Socket types. usocket.IPPROTO_UDP usocket.IPPROTO_TCP IP protocol numbers. Availability depends on a particular MicroPython port. Note that you don’t need to specify these in a call to usocket.socket(), because SOCK_STREAM socket type automatically selects IPPROTO_TCP, and SOCK_DGRAM - IPPROTO_UDP. Thus, the only real use of these constants is as an argument to setsockopt(). usocket.SOL_* Socket option levels (an argument to setsockopt()). The exact inventory depends on a MicroPython port. usocket.SO_* Socket options (an argument to setsockopt()). The exact inventory depends on a MicroPython port. Constants specific to WiPy: usocket.IPPROTO_SEC Special protocol value to create SSL-compatible socket. class socket Methods socket.close() Mark the socket closed and release all resources. Once that happens, all future operations on the socket object will fail. The remote end will receive EOF indication if supported by protocol. Sockets are automatically closed when they are garbage-collected, but it is recommended to close() them explicitly as soon you finished working with them. socket.bind(address) Bind the socket to address. The socket must not already be bound. socket.listen([backlog]) Enable a server to accept connections. If backlog is specified, it must be at least 0 (if it’s lower, it will be set to 0); and specifies the number of unaccepted connections that the system will allow before refusing new connections. If not specified, a default reasonable value is chosen. socket.accept() Accept a connection. The socket must be bound to an address and listening for connections. The return value is a pair (conn, address) where conn is a new socket object usable to send and receive data on the connection, and address is the address bound to the socket on the other end of the connection. socket.connect(address) Connect to a remote socket at address. socket.send(bytes) Send data to the socket. The socket must be connected to a remote socket. Returns number of bytes sent, which may be smaller than the length of data (“short write”). socket.sendall(bytes) Send all data to the socket. The socket must be connected to a remote socket. Unlike send(), this method will try to send all of data, by sending data chunk by chunk consecutively. The behavior of this method on non-blocking sockets is undefined. Due to this, on MicroPython, it’s recommended to use write() method instead, which has the same “no short writes” policy for blocking sockets, and will return number of bytes sent on non-blocking sockets. socket.recv(bufsize) Receive data from the socket. The return value is a bytes object representing the data received. The maximum amount of data to be received at once is specified by bufsize. socket.sendto(bytes, address) Send data to the socket. The socket should not be connected to a remote socket, since the destination socket is specified by address. socket.recvfrom(bufsize) Receive data from the socket. The return value is a pair (bytes, address) where bytes is a bytes object representing the data received and address is the address of the socket sending the data. socket.setsockopt(level, optname, value) Set the value of the given socket option. The needed symbolic constants are defined in the socket module (SO_* etc.). The value can be an integer or a bytes-like object representing a buffer. socket.settimeout(value) Note: Not every port supports this method, see below. Set a timeout on blocking socket operations. The value argument can be a nonnegative floating point number expressing seconds, or None. If a non-zero value is given, subsequent socket operations will raise an OSError exception if the timeout period value has elapsed before the operation has completed. If zero is given, the socket is put in non-blocking mode. If None is given, the socket is put in blocking mode. Not every MicroPython port supports this method. A more portable and generic solution is to use uselect.poll object. This allows to wait on multiple objects at the same time (and not just on sockets, but on generic stream objects which support polling). Example: # Instead of: s.settimeout(1.0) # time in seconds s.read(10) # may timeout # Use: poller = uselect.poll() poller.register(s, uselect.POLLIN) res = poller.poll(1000) # time in milliseconds if not res: # s is still not ready for input, i.e. operation timed out Difference to CPython CPython raises a socket.timeout exception in case of timeout, which is an OSError subclass. MicroPython raises an OSError directly instead. If you use except OSError: to catch the exception, your code will work both in MicroPython and CPython. socket.setblocking(flag) Set blocking or non-blocking mode of the socket: if flag is false, the socket is set to non-blocking, else to blocking mode. This method is a shorthand for certain settimeout() calls: sock.setblocking(True) is equivalent to sock.settimeout(None) sock.setblocking(False) is equivalent to sock.settimeout(0) socket.makefile(mode='rb', buffering=0) Return a file object associated with the socket. The exact returned type depends on the arguments given to makefile(). The support is limited to binary modes only (‘rb’, ‘wb’, and ‘rwb’). CPython’s arguments: encoding, errors and newline are not supported. Difference to CPython As MicroPython doesn’t support buffered streams, values of buffering parameter is ignored and treated as if it was 0 (unbuffered). Difference to CPython Closing the file object returned by makefile() WILL close the original socket as well. socket.read([size]) Read up to size bytes from the socket. Return a bytes object. If size is not given, it reads all data available from the socket until EOF; as such the method will not return until the socket is closed. This function tries to read as much data as requested (no “short reads”). This may be not possible with non-blocking socket though, and then less data will be returned. socket.readinto(buf[, nbytes]) Read bytes into the buf. If nbytes is specified then read at most that many bytes. Otherwise, read at most len(buf) bytes. Just as read(), this method follows “no short reads” policy. Return value: number of bytes read and stored into buf. socket.readline() Read a line, ending in a newline character. Return value: the line read. socket.write(buf) Write the buffer of bytes to the socket. This function will try to write all data to a socket (no “short writes”). This may be not possible with a non-blocking socket though, and returned value will be less than the length of buf. Return value: number of bytes written. exception usocket.error MicroPython does NOT have this exception. Difference to CPython CPython used to have a socket.error exception which is now deprecated, and is an alias of OSError. In MicroPython, use OSError directly. Demo Demo 1: Download picture and display on LCD attention set WiFi SSID and password first in code import socket import network import gc import os import lcd, image fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_TX,fm.fpioa.UART2_RX) uart = machine.UART(machine.UART.UART2,115200,timeout=1000, read_buf_len=4096) nic=network.ESP8285(uart) nic.connect(\"Sipeed_2.4G\",\"------\") sock = socket.socket() addr = socket.getaddrinfo(\"dl.sipeed.com\", 80)[0][-1] sock.connect(addr) sock.send('''GET /MAIX/MaixPy/assets/Alice.bmp HTTP/1.1 Host: dl.sipeed.com cache-control: no-cache ''') img = b\"\" sock.settimeout(5) while True: data = sock.recv(4096) if len(data) == 0: break print(\"rcv:\", len(data)) img = img + data print(len(img)) img = img[img.find(b\"\\r\\n\\r\\n\")+4:] print(len(img)) print(\"save to /sd/Alice.bmp\") f = open(\"/sd/Alice.bmp\",\"wb\") f.write(img) f.close() print(\"save ok\") print(\"display\") img = image.Image(\"/sd/Alice.bmp\") lcd.init() lcd.display(img) Demo 2: Send picture import os import socket import network import gc fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_TX,fm.fpioa.UART2_RX) uart = machine.UART(machine.UART.UART2,115200,timeout=1000, read_buf_len=4096) nic=network.ESP8285(uart) nic.connect(\"Sipeed_2.4G\",\"-------\") addr = (\"192.168.0.183\", 3456) sock = socket.socket() sock.connect(addr) sock.settimeout(5) f = open(\"/sd/Alice.bmp\",\"rb\") while True: img = f.read(2048) if not img or (len(img) == 0): break sock.send(img) f.close() sock.close() powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/standard/ustruct.html":{"url":"libs/standard/ustruct.html","title":"ustruct","keywords":"","body":"ustruct – pack and unpack primitive data types This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: struct. Supported size/byte order prefixes: @, , >, !. Supported format codes: b, B, h, H, i, I, l, L, q, Q, s, P, f, d (the latter 2 depending on the floating-point support). Functions calcsize ustruct.calcsize(fmt) Return the number of bytes needed to store the given fmt. pack ustruct.pack(fmt, v1, v2, ...) Pack the values v1, v2, … according to the format string fmt. The return value is a bytes object encoding the values. pack_into ustruct.pack_into(fmt, buffer, offset, v1, v2, ...) Pack the values v1, v2, … according to the format string fmt into a buffer starting at offset. offset may be negative to count from the end of buffer. unpack ustruct.unpack(fmt, data) Unpack from the data according to the format string fmt. The return value is a tuple of the unpacked values. unpack_from ustruct.unpack_from(fmt, data, offset=0) Unpack from the data starting at offset according to the format string fmt. offset may be negative to count from the end of buffer. The return value is a tuple of the unpacked values. powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/standard/utime.html":{"url":"libs/standard/utime.html","title":"utime","keywords":"","body":"utime – time related functions This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: time. The utime module provides functions for getting the current time and date, measuring time intervals, and for delays. Time Epoch: Unix port uses standard for POSIX systems epoch of 1970-01-01 00:00:00 UTC. However, embedded ports use epoch of 2000-01-01 00:00:00 UTC. Maintaining actual calendar date/time: This requires a Real Time Clock (RTC). On systems with underlying OS (including some RTOS), an RTC may be implicit. Setting and maintaining actual calendar time is responsibility of OS/RTOS and is done outside of MicroPython, it just uses OS API to query date/time. On baremetal ports however system time depends on machine.RTC() object. The current calendar time may be set using machine.RTC().datetime(tuple) function, and maintained by following means: By a backup battery (which may be an additional, optional component for a particular board). Using networked time protocol (requires setup by a port/user). Set manually by a user on each power-up (many boards then maintain RTC time across hard resets, though some may require setting it again in such case). If actual calendar time is not maintained with a system/MicroPython RTC, functions below which require reference to current absolute time may behave not as expected. Functions utime.localtime([secs]) Convert a time expressed in seconds since the Epoch (see above) into an 8-tuple which contains: (year, month, mday, hour, minute, second, weekday, yearday) If secs is not provided or None, then the current time from the RTC is used. year includes the century (for example 2014). month is 1-12 mday is 1-31 hour is 0-23 minute is 0-59 second is 0-59 weekday is 0-6 for Mon-Sun yearday is 1-366 utime.mktime() This is inverse function of localtime. It’s argument is a full 8-tuple which expresses a time as per localtime. It returns an integer which is the number of seconds since Jan 1, 2000. utime.sleep(seconds) Sleep for the given number of seconds. Some boards may accept seconds as a floating-point number to sleep for a fractional number of seconds. Note that other boards may not accept a floating-point argument, for compatibility with them use sleep_ms() and sleep_us() functions. utime.sleep_ms(ms) Delay for given number of milliseconds, should be positive or 0. utime.sleep_us(us) Delay for given number of microseconds, should be positive or 0. utime.ticks_ms() Returns an increasing millisecond counter with an arbitrary reference point, that wraps around after some value. The wrap-around value is not explicitly exposed, but we will refer to it as TICKS_MAX to simplify discussion. Period of the values is TICKS_PERIOD = TICKS_MAX + 1. TICKS_PERIOD is guaranteed to be a power of two, but otherwise may differ from port to port. The same period value is used for all of ticks_ms(), ticks_us(), ticks_cpu() functions (for simplicity). Thus, these functions will return a value in range [0 .. TICKS_MAX], inclusive, total TICKS_PERIOD values. Note that only non-negative values are used. For the most part, you should treat values returned by these functions as opaque. The only operations available for them are ticks_diff() and ticks_add() functions described below. Note: Performing standard mathematical operations (+, -) or relational operators (, >=) directly on these value will lead to invalid result. Performing mathematical operations and then passing their results as arguments to ticks_diff() or ticks_add() will also lead to invalid results from the latter functions. utime.ticks_us() Just like ticks_ms() above, but in microseconds. utime.ticks_cpu() Similar to ticks_ms() and ticks_us(), but with the highest possible resolution in the system. This is usually CPU clocks, and that’s why the function is named that way. But it doesn’t have to be a CPU clock, some other timing source available in a system (e.g. high-resolution timer) can be used instead. The exact timing unit (resolution) of this function is not specified on utime module level, but documentation for a specific port may provide more specific information. This function is intended for very fine benchmarking or very tight real-time loops. Avoid using it in portable code. Availability: Not every port implements this function. utime.ticks_add(ticks, delta) Offset ticks value by a given number, which can be either positive or negative. Given a ticks value, this function allows to calculate ticks value delta ticks before or after it, following modular-arithmetic definition of tick values (see ticks_ms() above). ticks parameter must be a direct result of call to ticks_ms(), ticks_us(), or ticks_cpu() functions (or from previous call to ticks_add()). However, delta can be an arbitrary integer number or numeric expression. ticks_add() is useful for calculating deadlines for events/tasks. (Note: you must use ticks_diff() function to work with deadlines.) Examples: # Find out what ticks value there was 100ms ago print(ticks_add(time.ticks_ms(), -100)) # Calculate deadline for operation and test for it deadline = ticks_add(time.ticks_ms(), 200) while ticks_diff(deadline, time.ticks_ms()) > 0: do_a_little_of_something() # Find out TICKS_MAX used by this port print(ticks_add(0, -1)) utime.ticks_diff(ticks1, ticks2) Measure ticks difference between values returned from ticks_ms(), ticks_us(), or ticks_cpu() functions, as a signed value which may wrap around. The argument order is the same as for subtraction operator, ticks_diff(ticks1, ticks2) has the same meaning as ticks1 - ticks2. However, values returned by ticks_ms(), etc. functions may wrap around, so directly using subtraction on them will produce incorrect result. That is why ticks_diff() is needed, it implements modular (or more specifically, ring) arithmetics to produce correct result even for wrap-around values (as long as they not too distant inbetween, see below). The function returns signed value in the range [-TICKS_PERIOD/2 .. TICKS_PERIOD/2-1] (that’s a typical range definition for two’s-complement signed binary integers). If the result is negative, it means that ticks1 occurred earlier in time than ticks2. Otherwise, it means that ticks1 occurred after ticks2. This holds only if ticks1 and ticks2 are apart from each other for no more than TICKS_PERIOD/2-1 ticks. If that does not hold, incorrect result will be returned. Specifically, if two tick values are apart for TICKS_PERIOD/2-1 ticks, that value will be returned by the function. However, if TICKS_PERIOD/2 of real-time ticks has passed between them, the function will return -TICKS_PERIOD/2 instead, i.e. result value will wrap around to the negative range of possible values. Informal rationale of the constraints above: Suppose you are locked in a room with no means to monitor passing of time except a standard 12-notch clock. Then if you look at dial-plate now, and don’t look again for another 13 hours (e.g., if you fall for a long sleep), then once you finally look again, it may seem to you that only 1 hour has passed. To avoid this mistake, just look at the clock regularly. Your application should do the same. “Too long sleep” metaphor also maps directly to application behavior: don’t let your application run any single task for too long. Run tasks in steps, and do time-keeping inbetween. ticks_diff() is designed to accommodate various usage patterns, among them: Polling with timeout. In this case, the order of events is known, and you will deal only with positive results of ticks_diff(): # Wait for GPIO pin to be asserted, but at most 500us start = time.ticks_us() while pin.value() == 0: if time.ticks_diff(time.ticks_us(), start) > 500: raise TimeoutError Scheduling events. In this case, ticks_diff() result may be negative if an event is overdue: # This code snippet is not optimized now = time.ticks_ms() scheduled_time = task.scheduled_time() if ticks_diff(scheduled_time, now) > 0: print(\"Too early, let's nap\") sleep_ms(ticks_diff(scheduled_time, now)) task.run() elif ticks_diff(scheduled_time, now) == 0: print(\"Right at time!\") task.run() elif ticks_diff(scheduled_time, now) Note: Do not pass time() values to ticks_diff(), you should use normal mathematical operations on them. But note that time() may (and will) also overflow. This is known as https://en.wikipedia.org/wiki/Year_2038_problem . utime.time() Returns the number of seconds, as an integer, since the Epoch, assuming that underlying RTC is set and maintained as described above. If an RTC is not set, this function returns number of seconds since a port-specific reference point in time (for embedded boards without a battery-backed RTC, usually since power up or reset). If you want to develop portable MicroPython application, you should not rely on this function to provide higher than second precision. If you need higher precision, use ticks_ms() and ticks_us()functions, if you need calendar time, localtime() without an argument is a better choice. Difference to CPython In CPython, this function returns number of seconds since Unix epoch, 1970-01-01 00:00 UTC, as a floating-point, usually having microsecond precision. With MicroPython, only Unix port uses the same Epoch, and if floating-point precision allows, returns sub-second precision. Embedded hardware usually doesn’t have floating-point precision to represent both long time ranges and subsecond precision, so they use integer value with second precision. Some embedded hardware also lacks battery-powered RTC, so returns number of seconds since last power-up or from other relative, hardware-specific point (e.g. reset). powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/standard/uzlib.html":{"url":"libs/standard/uzlib.html","title":"uzlib","keywords":"","body":"zlib — zlib decompression This module implements a subset of the corresponding CPython module, as described below. For more information, refer to the original CPython documentation: zlib. This module allows to decompress binary data compressed with DEFLATE algorithm (commonly used in zlib library and gzip archiver). Compression is not yet implemented. Functions decompress uzlib.decompress(data, wbits=0, bufsize=0) Return decompressed data as bytes. wbits is DEFLATE dictionary window size used during compression (8-15, the dictionary size is power of 2 of that value). Additionally, if value is positive, data is assumed to be zlib stream (with zlib header). Otherwise, if it’s negative, it’s assumed to be raw DEFLATE stream. bufsize parameter is for compatibility with CPython and is ignored. DecompIO class uzlib.DecompIO(stream, wbits=0) Create a stream wrapper which allows transparent decompression of compressed data in another stream. This allows to process compressed streams with data larger than available heap size. In addition to values described in decompress(), wbits may take values 24..31 (16 + 8..15), meaning that input stream has gzip header. Difference to CPython This class is MicroPython extension. It’s included on provisional basis and may be changed considerably or removed in later versions. powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/machine/":{"url":"libs/machine/","title":"machine","keywords":"","body":"machine I2C SPI Timer PWM UART Function unique_id() Get unique ID Return value 32 bytes unique ID Function reset() reset (reboot) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/machine/i2c.html":{"url":"libs/machine/i2c.html","title":"I2C","keywords":"","body":"machine.I2C I2C bus protocol, simply using two lines (SCL, SDA) can control multiple slaves (master mode). Supports master mode and slave mode 7-bit / 10-bit addressing mode Standard mode Fast mode Super fast mode High-speed mode 3.4Mb / s Constructor class machine.I2C (id, mode = I2C.MODE_MASTER, scl = None, sda = None, freq = 400000, timeout = 1000, addr = 0, addr_size = 7, on_recieve = None, on_transmit = None, on_event = None) Create a new I2C object with the specified parameters Parameters id: I2C ID, [0 ~ 2] \\ (I2C.I2C0 ~ I2C.I2C2 ) mode: mode, master (I2C.MODE_MASTER) and slave (I2C.MODE_SLAVE) mode scl: SCL pin, just pass the pin number directly, value range: [0,47]. Instead of setting it, use [fm] (../ builtin_py / fm.md) to manage the pin mapping uniformly. sda: SDA pin, just pass the pin number directly, value range: [0,47]. Instead of setting it, use [fm] (../ builtin_py / fm.md) to manage the pin mapping uniformly. freq: I2C communication frequency, support standard 100Kb / s, fast 400Kb / s, and higher speed (hardware supports super fast mode 1000Kb / s, and high-speed mode 3.4Mb / s) timeout: timeout time, currently this parameter is reserved, setting is invalid addr: slave address, if it is in master mode, it is not necessary to set, slave mode represents slave (local) address addr_size: address length, support 7-bit addressing and 10-bit addressing, value7 or 10 on_recieve: Receive callback function in slave mode on_transmit: Send callback function in slave mode on_event: Slave mode event function (start event and end event) Method init Constructor-like I2C.init (id, mode = Timer.MODE_MASTER, scl, sda, freq = 400000, timeout = 1000, addr = 0, addr_size = 7, on_recieve = None, on_transmit = None, on_event = None) parameters Same as constructor return value no scan Scanning slaves on the I2C bus I2C.scan () parameters no return value list object containing all scanned slave addresses readfrom Read data from the bus I2C.readfrom (addr, len, stop = True) parameters addr: slave address len: data length stop: Whether to generate a stop signal. Reserved. Currently, only the default value True can be used. return value Read data, type bytes readfrom_into Read the data and put it into the specified variable I2C.readfrom_into (addr, buf, stop = True) parameters addr: slave address buf:bytearray type, which defines the length, and the read data is stored here stop: Whether to generate a stop signal. Reserved. Currently, only the default value True can be used. return value no writeto Send data to the slave I2C.writeto (addr, buf, stop = True) parameters addr: slave address buf: data to be sent stop: Whether to generate a stop signal. Reserved. Currently, only the default value True can be used. return value Number of bytes successfully sent readfrom_mem Read slave register I2C.readfrom_mem (addr, memaddr, nbytes, mem_size = 8) parameters addr: slave address memaddr: slave register address nbytes: the length to read mem_size: register width, default is 8 bits return value Returns read data of type bytes readfrom_mem_into Read the slave register value into the specified variable I2C.readfrom_mem_into (addr, memaddr, buf, mem_size = 8) parameters addr: slave address memaddr: slave register address buf:bytearray type, which defines the length, and the read data is stored here mem_size: register width, default is 8 bits return value no writeto_mem Write data to slave register I2C.writeto_mem (addr, memaddr, buf, mem_size = 8) parameters addr: slave address memaddr: slave register address buf: data to be written mem_size: register width, default is 8 bits return value no deinit / \\ del \\ Log off the I2C hardware, release the occupied resources, and shut down the I2C clock I2C.deinit () parameters no return value no Examples i2c.deinit () or del i2c Constants I2C0: I2C 0 I2C1: I2C 1 I2C2: I2C 2 MODE_MASTER: as master mode MODE_SLAVE: as slave mode I2C_EV_START: event type, start signal I2C_EV_RESTART: event type, restart signal I2C_EV_STOP: event type, end signal Examples Routine 1: Scanning for Slave Devices from machine import I2C i2c = I2C (I2C.I2C0, freq = 100000, scl = 28, sda = 29) devices = i2c.scan () print (devices) Example 2: Read and write import time from machine import I2C i2c = I2C (I2C.I2C0, freq = 100000, scl = 28, sda = 29) i2c.writeto (0x24, b'123 ') i2c.readfrom (0x24,5) Example 3: Slave mode from machine import I2C count = 0 def on_receive (data): print (\"on_receive:\", data) def on_transmit (): count = count + 1 print (\"on_transmit, send:\", count) return count def on_event (event): print (\"on_event:\", event) i2c = I2C (I2C.I2C0, mode = I2C.MODE_SLAVE, scl = 28, sda = 29, addr = 0x24, addr_size = 7, on_receive = on_receive, on_transmit = on_transmit, on_event = on_event) Example 4: OLED (ssd1306 128x64) import time from machine import I2C SSD1306_CMD = 0 SSD1306_DATA = 1 SSD1306_ADDR = 0x3c def oled_init (i2c): i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xAE, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x20, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x10, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xb0, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xc8, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x00, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x10, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x40, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x81, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xff, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xa1, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xa6, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xa8, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x3F, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xa4, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xd3, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x00, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xd5, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xf0, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xd9, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x22, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xda, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x12, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xdb, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x20, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x8d, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x14, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xaf, mem_size = 8) def oled_on (i2c): i2c.writeto_mem (SSD1306_ADDR, 0x00, 0X8D, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0X14, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0XAF, mem_size = 8) def oled_off (i2c): i2c.writeto_mem (SSD1306_ADDR, 0x00, 0X8D, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0X10, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0XAE, mem_size = 8) def oled_fill (i2c, data): for i in range (0,8): i2c.writeto_mem (SSD1306_ADDR, 0x00, 0xb0 + i, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x10, mem_size = 8) i2c.writeto_mem (SSD1306_ADDR, 0x00, 0x01, mem_size = 8) for j in range (0,128): i2c.writeto_mem (SSD1306_ADDR, 0x40, data, mem_size = 8) i2c = I2C (I2C.I2C0, mode = I2C.MODE_MASTER, freq = 400000, scl = 28, sda = 29, addr_size = 7) time.sleep (1) oled_init (i2c) oled_fill (i2c, 0xff) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/machine/pwm.html":{"url":"libs/machine/pwm.html","title":"PWM","keywords":"","body":"machine.PWM PWM: Pulse width modulation module, hardware-supported PWM, can specify any pin (0 to 47 pins) Each PWM depends on a timer, that is, when the timer is bound to the PWM function, it cannot be used as an ordinary timer. Because there are 3 timers and each timer has 4 channels, that is, a maximum of 12 PWM waveforms can be generated at the same time. Constructor `python class machine.PWM (tim, freq, duty, pin, enable = True) ` Create a new PWM object with the specified parameters Parameters tim: Each PWM relies on a timer to generate a waveform, so a timer object needs to be passed here. The timer ID and channel number must be specified when the timer object is initialized. freq: PWM waveform frequency duty: PWM duty cycle, refers to the percentage of high level in the entire cycle, value: [0,100] [pin]: PWM output pin. Instead of setting it, use [fm] (../ builtin_py / fm.md) to manage the pin mapping uniformly. enable: Whether to start generating the waveform immediately, the default bitTrue, and to start generating the PWM waveform on the specified pin immediately after the object is generated Method init Constructor-like `python PWM.init (tim, freq, duty, pin, enable = True) ` parameters Same as constructor return value no freq Get or set the PWM frequency `python PWM.freq (freq) ` parameters freq: PWM frequency, optional parameter, if no parameter is passed, the step setting only returns the current frequency value return value Actual PWM frequency currently set duty Gets or sets the PWM duty cycle `python PWM.duty (duty) ` parameters duty: PWM duty cycle is optional. If no parameter is passed, the step setting only returns the current duty cycle value. return value PWM duty cycle value currently set enable Enable PWM output to generate waveform immediately on specified pin `python PWM.enable () ` parameters no return value no disable Disable PWM output, no longer generate waveforms at specified pins `python PWM.disable () ` parameters no return value no deinit / \\ del \\ Unregister the PWM hardware, release the occupied resources, and shut down the PWM clock `python PWM.deinit () ` parameters no return value no Examples `python pwm.deinit () or `` python del pwm ` Constants no Examples Routine 1 (breathing light) ` python from machine import Timer, PWM import time from fpioa_manager import board_info tim = Timer (Timer.TIMER0, Timer.CHANNEL0, mode = Timer.MODE_PWM) ch = PWM (tim, freq = 500000, duty = 50, pin = board_info.LED_G) duty = 0 dir = True while True: if dir: duty + = 10 else: duty-= 10 if duty> 100: duty = 100 dir = False elif duty ` Routine 2 ` python import time import machine from fpioa_manager import board_info tim = machine.Timer (machine.Timer.TIMER0, machine.Timer.CHANNEL0, mode = machine.Timer.MODE_PWM) ch0 = machine.PWM (tim, freq = 3000000, duty = 20, pin = board_info.LED_G, enable = False) ch0.enable () time.sleep (3) ch0.freq (2000000) print (\"freq:\", ch0.freq ()) ch0.duty (60) time.sleep (3) ch0.disable () ` powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/machine/spi.html":{"url":"libs/machine/spi.html","title":"SPI","keywords":"","body":"machine.SPI SPI (Serial Peripheral Interface) is a synchronous serial protocol consisting of a master and a slave. The standard 4-wire mode consists of 4 wires: SCK (SCLK), CS (chip select), MOSI, MISO. On the K210, SPI has the following characteristics: There are 4 SPI devices, of which SPI0, SPI1, and SPI3 can only work in master mode, and SPI2 can only work in slave mode. On MaixPy, SPI3 has been used to connect SPI Flash. It is temporarily reserved. It is necessary to consider the open interface and SPI Flash time-sharing multiplexing. Supports 1/2/4 / 8-wire full-duplex mode. In MaixPy, currently only supports standard (Motorola) 4-wire full-duplex mode (ie, SCK, MOSI, MISO, CS four pins) Maximum transmission rate of 45M Support DMA 4 configurable hardware chip select Constructor class machine.SPI (id, mode = SPI.MODE_MASTER, baudrate = 500000, polarity = 0, phase = 0, bits = 8, firstbit = SPI.MSB, sck, mosi, miso, cs0, cs1, cs2, cs3) Create a new SPI object with the specified parameters Parameters id: SPI ID, value range [0,3], currently only supports 0 and 1, and can only be master mode, 2 can only be used as slave, currently not implemented, 3 reserved mode: SPI mode,MODE_MASTER or MODE_MASTER_2 orMODE_MASTER_4 or MODE_MASTER_8 orMODE_SLAVE, currently only supports MODE_MASTER baudrate: SPI baud rate (frequency) polarity: Polarity, the value is 0 or 1, which indicates the polarity of the SPI at idle, 0 represents low level, 1 represents high level phase: phase, value bit 0 or 1, which means to collect data at the first or second edge of the clock, 0 means the first, 1 means the second bits: data width, default value is 8, value range [4,32] firstbit: Specify whether to transmit in MSB or LSB order. The default is SPI.MSB. sck: SCK (Clock) pin, which can directly transmit the pin value. The value range is [0,47]. Instead of setting it, use [fm] (../ builtin_py / fm.md) to manage the pin mapping uniformly. mosi: MOSI (host output) pin, which can directly pass the pin value, value range: [0,47]. Instead of setting it, use [fm] (../ builtin_py / fm.md) to manage the pin mapping uniformly. miso: MISO (host input) pin, which can directly pass the pin value, value range: [0,47]. Instead of setting it, use [fm] (../ builtin_py / fm.md) to manage the pin mapping uniformly. cs0: CS0 (chip select) pin, which can directly pass the pin value, value range: [0,47]. Instead of setting it, use [fm] (../ builtin_py / fm.md) to manage the pin mapping uniformly. cs1: CS1 (chip select) pin, which can directly pass the pin value, value range: [0,47]. Instead of setting it, use [fm] (../ builtin_py / fm.md) to manage the pin mapping uniformly. cs2: CS2 (chip select) pin, which can directly pass the pin value, value range: [0,47]. Instead of setting it, use [fm] (../ builtin_py / fm.md) to manage the pin mapping uniformly. cs3: CS3 (chip select) pin, which can directly pass the pin value, value range: [0,47]. Instead of setting it, use [fm] (../ builtin_py / fm.md) to manage the pin mapping uniformly. d0 ~ d7: Data pins, used in non-standard 4-wire mode, currently reserved. Instead of setting it, use [fm] (../ builtin_py / fm.md) to manage the pin mapping uniformly. Method init Constructor-like SPI.init (id, mode = SPI.MODE_MASTER, baudrate = 500000, polarity = 0, phase = 0, bits = 8, firstbit = SPI.MSB, sck, mosi, miso, cs0) parameters Same as constructor return value no read Read data SPI.read (nbytes, write = 0x00, cs = SPI.CS0) parameters nbytes: the length to read cs: Select chip select pins. Pins have been set forcs0 ~ cs3 during initialization. Here you only need to selectSPI.CS0 ~ SPI.CS3. The default isSPI. .CS0 write: Because it is full duplex, set the value of theMOSI pin when reading. The default is 0x00, which is always low. return value bytes data readinto Read the data and put it into the specified variable SPI.readinto (buf, write = 0x00, cs = SPI.CS0) parameters buf:bytearray type, which defines the length, and the data is saved here after reading cs: Select chip select pins. Pins have been set forcs0 ~ cs3 during initialization. Here you only need to selectSPI.CS0 ~ SPI.CS3. The default isSPI. .CS0 write: Because it is full duplex, set the value of theMOSI pin when reading. The default is 0x00, which is always low. return value no write send data SPI.write (buf, cs = SPI.CS0) parameters buf:bytearray type, which defines the data and length cs: Select chip select pins. Pins have been set forcs0 ~ cs3 during initialization. Here you only need to selectSPI.CS0 ~ SPI.CS3. The default isSPI. .CS0 return value no write_readinto Send data while reading data to a variable, that is, full duplex SPI.write (write_buf, read_buf, cs = SPI.CS0) parameters write_buf:bytearray type, which defines the data and length to be sent read_buf:bytearray type, which defines where the received data is stored cs: Select chip select pins. Pins have been set forcs0 ~ cs3 during initialization. Here you only need to selectSPI.CS0 ~ SPI.CS3. The default isSPI. .CS0 return value no deinit / \\ del \\ Log out of SPI, release hardware, shut down SPI clock SPI.deinit () parameters no return value no Examples spi.deinit () or del spi Constants SPI0: SPI 0 SPI1: SPI 1 SPI2: SPI 2 MODE_MASTER: as master mode MODE_MASTER_2: as master mode MODE_MASTER_4: as master mode MODE_MASTER_8: as master mode MODE_SLAVE: as slave mode MSB: MSB, that is, the high-order or high-order byte is sent first LSB: LSB, that is, send low-order or low-order byte first CS0: Chip Select 0 CS1: Chip Select 1 CS2: Chip Select 2 CS3: Chip Selection 3 Examples Example 1: Basic Read and Write from machine import SPI spi1 = SPI (SPI.SPI1, mode = SPI.MODE_MASTER, baudrate = 10000000, polarity = 0, phase = 0, bits = 8, firstbit = SPI.MSB, sck = 28, mosi = 29, miso = 30, cs0 = 27) w = b'1234 ' r = bytearray (4) spi1.write (w) spi1.write (w, cs = SPI.CS0) spi1.write_readinto (w, r) spi1.read (5, write = 0x00) spi1.readinto (r, write = 0x00) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/machine/timer.html":{"url":"libs/machine/timer.html","title":"Timer","keywords":"","body":"machine.Timer Hardware timers deal with timing of periods and events. Timers are perhaps the most flexible and heterogeneous kind of hardware in MCUs and SoCs, differently greatly from a model to a model. MicroPython’s Timer class defines a baseline operation of executing a callback with a given period (or once after some delay), and allow specific boards to define more non-standard behavior (which thus won’t be portable to other boards). Constructors class machine.Timer(id, channel, mode=Timer.MODE_ONE_SHOT, period=1000, unit=Timer.UNIT_MS, callback=None, arg=None, start=True, priority=1, div=0) Construct a new timer object of the given id. Parameters id: Timer ID, [0~2] (Timer.TIMER0~TIMER2) channel: Timer channel, [Timer.CHANNEL0~Timer.CHANNEL3] mode: Timer mode, MODE_ONE_SHOT or MODE_PERIODICor MODE_PWM period: Timer period, after period the callback will be invoke, (0,~). unit: unit of timer, default ms, Timer.UNIT_S or Timer.UNIT_MS or Timer.UNIT_US orTimer.UNIT_NS callback: Timer callback, two parameters, first is Timer, second is user param, see param parameter below. callback execute in interrupt, so don't stay too long in callback arg: Argument dilivered to callback start: If start instantly timer after init, True:start, False:not start, need call start() function. priority: interrupt priority, [1,7]. div: Timer clock divider,[0,255],default to 0. clk_timer = clk_pll0/2^(div+1) clk_timer*period(unit:s) should =1 Methods init Same to constructor Timer.init(id, channel, mode=Timer.MODE_ONE_SHOT, period=1000, unit=Timer.UNIT_MS, callback=None, arg=None, start=True, priority=1, div=0) callback_arg callback arg of timer obj callback Get or set callback e.g. def on_timer(timer,param): print(\"time up:\",timer) print(\"param:\",timer.callback_arg()) tim.callback(on_timer) print(on_timer, tim.callback()) period Get or set period e.g. tim.period(2000) print( tim.period() ) start Start timer e.g. tim.start() stop Stop timer restart Restart timer deinit/del Deinitialises the timer. Stops the timer, and disables the timer peripheral. e.g. tim.deinit() or del tim Constants TIMER0: Timer0 id TIMER1: Timer1 id TIMER2: Timer2 id CHANNEL0: Timer channel 0 CHANNEL1: Timer channel 1 CHANNEL2: Timer channel 2 CHANNEL3: Timer channel 3 MODE_ONE_SHOT: Timer only run once MODE_PERIODIC: Timer always run MODE_PWM: Timer used by PWM UNIT_S: unit flag (s) UNIT_MS: unit flag (ms) UNIT_US: unit flag (us) UNIT_NS: unit flag (ns) Demo Demo 1 Print data after 3s just once from machine import Timer def on_timer(timer): print(\"time up:\",timer) print(\"param:\",timer.callback_arg()) tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_ONE_SHOT, period=3000, callback=on_timer, arg=on_timer) print(\"period:\",tim.period()) Demo 2 Print every 1s, and stop 5s then restart 5s then shutdown import time from machine import Timer def on_timer(timer,param): print(\"time up:\",timer) print(\"param:\",param) tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PERIODIC, period=1, unit=Timer.UNIT_S, callback=on_timer, arg=on_timer, start=False, priority=1, div=0) print(\"period:\",tim.period()) tim.start() time.sleep(5) tim.stop() time.sleep(5) tim.restart() time.sleep(5) tim.stop() del tim powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/machine/uart.html":{"url":"libs/machine/uart.html","title":"UART","keywords":"","body":"machine.UART The uart module is mainly used to drive the asynchronous serial port on the development board, and uart can be freely configured. The k210 has a total of 3 uarts, and each uart can perform free pin mapping. Construction Pin mapping Before using uart, we need to use fm to map and manage the chip pins. As shown below, set PIN10 as the sending pin of uart2 and PIN11 as the receiving pin of uart2 fm.register (board_info.PIN10, fm.fpioa.UART2_TX) fm.register (board_info.PIN11, fm.fpioa.UART2_RX) Constructor uart = machine.UART (uart, baudrate, bits, parity, stop, timeout, read_buf_len) Create a new UART object with the specified parameters parameters uart UART number, use the specified UART, you can complete it by pressing the machine key withmachine.UART. baudrate: UART baud rate bits: UART data width, support5/6/7 / 8 (the default serial port used by REPL (UARTHS) only supports 8-bit mode), default 8 parity: parity bit, supportsNone, machine.UART.PARITY_ODD,machine.UART.PARITY_EVEN (the default serial port used by REPL (UARTHS) only supports None), default None stop: stop bit, supports1, 1.5,2, default 1 timeout: serial port receive timeout read_buf_len: Serial port receive buffer. The serial port receives data through interrupt. If the buffer is full, it will automatically stop receiving data. return value UART object Method init Used to initialize uart, usually already initialized when constructing the object, here is used to re-initialize uart uart.init (baudrate, bits, parity, stop, timeout, read_buf_len) parameters Same constructor but does not require the first UART number return value no read Used to read data from serial buffer uart.read (num) parameters num: the number of bytes read, generally fill the buffer size, if the number of data in the buffer is not as large asnum, then only the remaining data in the buffer will be returned return value bytes data readline Yihang for reading serial buffered data uart.readline (num) num: number of rows read return value bytes data write Used to send data using the serial port uart.write (buf) parameters buf: need to send data return value Amount of data written deinit Unregister UART hardware and free up resources UART.deinit () parameters no return value no repl_uart () Get serial object for REPL return value Serial object for REPL, default initialization bit 115200 8 N 1 Examples Routine 1 Before running mileage, please make sure PIN15 is connected toPIN10 and PIN17 is connected toPIN9 After running the program, you can see the print information of baudrate: 115200 bits: 8 parity: 0 stop: 0 --- check Successfully in the terminal from fpioa_manager import fm from machine import UART fm.register (board_info.PIN15, fm.fpioa.UART1_TX) fm.register (board_info.PIN17, fm.fpioa.UART1_RX) fm.register (board_info.PIN9, fm.fpioa.UART2_TX) fm.register (board_info.PIN10, fm.fpioa.UART2_RX) uart_A = UART (UART.UART1, 115200, 8, None, 1, timeout = 1000, read_buf_len = 4096) uart_B = UART (UART.UART2, 115200, 8, None, 1, timeout = 1000, read_buf_len = 4096) write_str = 'hello world' for i in range (20): uart_A.write (write_str) read_data = uart_B.read () read_str = read_data.decode ('utf-8') print (\"string =\", read_str) if read_str == write_str: print (\"baudrate: 115200 bits: 8 parity: None stop: 1 --- check Successfully\") uart_A.deinit () uart_B.deinit () del uart_A del uart_B Routine 2 AT module serial port fm.register (board_info.WIFI_RX, fm.fpioa.UART2_TX) fm.register (board_info.WIFI_TX, fm.fpioa.UART2_RX) uart = machine.UART (machine.UART.UART2, 115200, timeout = 1000, read_buf_len = 4096) Routine 3 Modify the baud rate of the REPL serial port from machine import UART repl = UART.repl_uart () repl.init (1500000, 8, None, 1, read_buf_len = 2048) Routine 3 Modify the REPL serial port from machine import UART fm.register (board_info.PIN15, fm.fpioa.UART1_TX) fm.register (board_info.PIN17, fm.fpioa.UART1_RX) uart = machine.UART (UART.UART1, 115200) UART.set_repl_uart (uart) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/machine/network.html":{"url":"libs/machine/network.html","title":"network","keywords":"","body":"network This module is used to initialize various network card drivers. The network card has these function: connecting routes, disconnecting routes, viewing network card connection information, checking whether connections are made. Please make sure the antenna is connected before using WiFi. esp8285 Some development boards expose an AT network interface module, such as an esp8285 interface connected to the k210 processor via a serial port. Pin 8 is the enable pin. Instantiate a GPIO object set it high to enable, low to disable. To reset, set it low, wait a short while, then set it high. Sample code [wifi_ap_scan.py] (https://github.com/sipeed/MaixPy_scripts/blob/master/network/demo_wifi_ap_scan.py) esp32 There is currently a esp32 module in the MaixDuino development board connected to k210 via SPI. There is also a separate TF plug-in module. ESP8285_Module network.ESP8285(uart) Instantiate an ESP8285 NIC object, passing in an uart object. On the dock and GO currently supported by MaixPy, use the AT command module as WiFi. So the uart object is the object that communicates with the AT module, you can view the uart module routine. Calling this method will initialize ESP8285, throwing an exception if it fails. Parameters uart: UART object that communicates with the AT module Return Value ESP8285: NIC object ESP8285 connect(ssid, key) Connect to a hotspot (AP/router). Parameters ssid: hotspot SSID key: password for hotspot Return Value None. An exception will be thrown if an error occurs. 2.2. ifconfig Display the current WiFi connection information. Currently, the network does not support setting the network card configuration. nic.ifconfig() Parameters None Return Value tuple type, the elements are all strings: (ip, netmask, gateway, dns_server, dhcp_server, mac, ssid), if not queried or invalid, the value is `\"0\". isconnected Check if WiFi is connected. nic.isconnected() Parameters None Return Value True: Already connected False: Disconnected disconnect Disconnect WiFi. Parameters None Return Value None scan Scan for surrounding WiFi hotspots. Parameters None Return Value A list object, each element containing a string, the string comes from the response of the AT module, the content is the same as described in esp8285 AT directive document, as follows: ',,,,,,,, ,,' : encryption method 0: OPEN 1: WEP 2: WPA_PSK 3: WPA2_PSK 4: WPA_WPA2_PSK 5: WPA2_Enterprise (current AT does not support connection to this encrypted AP) : string parameter, SSID of AP : signal strength : string parameter, AP's MAC address : channel number : AP frequency offset, unit: kHz. This value is divided by 2.4 to get the ppm value. : frequency offset calibration value : 0: CIPHER_NONE 1: CIPHER_WEP40 2: CIPHER_WEP104 3: CIPHER_TKIP 4: CIPHER_CCMP 5: CIPHER_TKIP_CCMP 6: CIPHER_UNKNOWN : definition is the same as : bit0 stands for b mode; bit1 stands for g mode; bit2 stands for n mode If the corresponding bit is 1, it indicates that the mode is enabled; if the corresponding bit is 0, the mode is not enabled. :0, WPS is not enabled; 1, WPS is enabled example: info_strs = ['4,\"ChinaNet-lot0\",-79,\"c8:50:e9:e8:21:3e\",1,-42,0,4,3,7,1', '4,\"TOPSTEP2G4\",-7 0,\"f8:e7:1e:0d:0d:f8\",1,-57,0,4,4,7,0'] This may seem strange, because each AP's information is a string of characters, there are integers and strings in the message, the string is enclosed in double quotes, so you need to deal with it again after getting this string, for example: def wifi_deal_ap_info(info): res = [] for ap_str in info: ap_str = ap_str.split(\",\") info_one = [] for node in ap_str: if node.startswith('\"'): info_one.append(node[1:-1]) else: info_one.append(int(node)) res.append(info_one) return res info_strs = ['4,\"ChinaNet-lot0\",-79,\"c8:50:e9:e8:21:3e\",1,-42,0,4,3,7,1', '4,\"TOPSTEP2G4\",-70,\"f8:e7:1e:0d:0d:f8\",1,-57,0,4,4,7,0'] info = wifi_deal_ap_info(info_strs) print(info) The output is: [[4, 'ChinaNet-lot0', -79, 'c8:50:e9:e8:21:3e', 1, -42, 0, 4, 3, 7, 1], [4, 'TOPSTEP2G4', -70, 'f8:e7:1e:0d:0d:f8', 1, -57, 0, 4, 4, 7, 0]] Then for example to get every AP SSID: for ap_info in info: print(ap_info[1]) enable_ap(ssid, key, chl=5, ecn=3) Connect to the specified WiFi hotspot. Parameters ssid: SSID key: password chl: channel number of the WiFi signal ecn: encryption method, there are OPEN``WPA2_PSK, etc., refer to the constant part of this page ESP8285, the default value is 3, which is ESP8285.WPA2_PSK, for exampleNic = network.ESP8285(uart) Nic.enable_ap(\"maixpy\", \"12345678\", 5, nic.OPEN) orNic.enable_ap(\"maixpy\", \"12345678\", 5, network.ESP8285.OPEN) disable_ap() Disconnect from the currently connected WiFi hotspot. Constants OPEN No encryption and no password required. WPA_PSK WPA_PSK encryption WPA2_PSK WPA2_PSK encryption WPA_WPA2_PSK WPA_WPA2_PSK encryption Code Refer to [code in the network directory] (https://github.com/sipeed/MaixPy_scripts/tree/master/network) ESP32_Module network.ESP32_SPI(cs,rst,rdy,mosi,miso,sclk) To instantiate an ESP32_SPI NIC object, you need to pass in the corresponding GPIOHS FUNC. If the number of parameters passed in is incorrect, an error will be returned. Parameters fpioa_func for pin function Return Value ESP32_SPI NIC object ESP32_SPI adc Read the adc value of the esp32 module Parameters None Return Value tuple, the adc value of 5 channels is \"PIN36\", \"PIN39\", \"PIN34\", \"PIN35\", \"PIN32\" Code demo_esp32_read_adc.py powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/Maix/":{"url":"libs/Maix/","title":"Maix","keywords":"","body":"Maix库 FPIOA GPIO KPU FFT I2S Audio freq utils powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/Maix/fpioa.html":{"url":"libs/Maix/fpioa.html","title":"FPIOA","keywords":"","body":"FPIOA (Field Programmable Input and Output Array) The K210 supports each peripheral to be randomly mapped to any pin, using the FPIOA function. Attention: Some GPIOHS used by default, don't use these GPIOHS if you don't have to, GPIOHS used as follows: GPIOHS Function GPIOHS31 LCD_DC GPIOHS30 LCD_RST GPIOHS29 SD_CS GPIOHS28 MIC_LED_CLK GPIOHS27 MIC_LED_DATA Class FPIOA Method help(func) Display peripherals and their brief description Parameters func: Peripheral name (function/number), you can not pass the parameter, then display all the peripheral names in a tabular form, which is also a brief description. This table can also be found at the end of this page (Appendix: Peripheral Table); If the parameter is passed, an integer value is passed. When the peripheral corresponding to the number is found, the peripheral name and description are printed, For example FPIOA.JTAG_TCLK or fm.fpioa.JTAG_TCLK (fm is described later in this page) or 0 such as: From Maix import FPIOA Fpioa = FPIOA() Fpioa.help() Fpioa.help(0) Fpioa.help(fpioa.JTAG_TCLK) Fm.fpioa.help() Fm.fpioa.help(fm.fpioa.JTAG_TCLK) Back Peripheral name and its brief description set_function(pin, func) Set the peripheral function corresponding to the pin, that is, pin mapping Parameters pin: pin number, value [0, 47], please refer to the circuit diagram for the specific pin connection. You can also use board_info. and then press the TAB button to get the common pins of the board. board_info.LED_G func: Peripheral function, passing an integer value, can be obtained by fm.fpioa.help() or by looking at the [Appendix: Peripheral Table] (#Appendix: Peripheral Table) table at the end of this page. For example, you need to map the pin connecting green LED to high speed GPIO0: Fpioa = FPIOA() Fpioa.set_function(board_info.LED_G, fm.fpioa.GPIOHS0) get_Pin_num(func) Get which pin the peripheral is mapped to Parameters func: Peripheral function, passing an integer value, can be obtained by fm.fpioa.help() or by looking at the Appendix: Peripheral Table table at the end of this page. such as: Fpioa = FPIOA() Fpioa.set_function(board_info.LED_G, fm.fpioa.GPIOHS0) Pin = fpioa.get_Pin_num(fm.fpioa.GPIOHS0) If pin == board_info.LED_G: Print(\"set function ok\") Appendix: Peripheral Table Peripheral Functions (func) Brief Description JTAG_TCLK JTAG Test Clock JTAG_TDI JTAG Test Data In JTAG_TMS JTAG Test Mode Select JTAG_TDO JTAG Test Data Out SPI0_D0 SPI0 Data 0 SPI0_D1 SPI0 Data 1 SPI0_D2 SPI0 Data 2 SPI0_D3 SPI0 Data 3 SPI0_D4 SPI0 Data 4 SPI0_D5 SPI0 Data 5 SPI0_D6 SPI0 Data 6 SPI0_D7 SPI0 Data 7 SPI0_SS0 SPI0 Chip Select 0 SPI0_SS1 SPI0 Chip Select 1 SPI0_SS2 SPI0 Chip Select 2 SPI0_SS3 SPI0 Chip Select 3 SPI0_ARB SPI0 Arbitration SPI0_SCLK SPI0 Serial Clock UARTHS_RX UART High speed Receiver UARTHS_TX UART High speed Transmitter RESV6 Reserved function RESV7 Reserved function CLK_SPI1 Clock SPI1 CLK_I2C1 Clock I2C1 GPIOHS0 GPIO High speed 0 GPIOHS1 GPIO High speed 1 GPIOHS2 GPIO High speed 2 GPIOHS3 GPIO High speed 3 GPIOHS4 GPIO High speed 4 GPIOHS5 GPIO High speed 5 GPIOHS6 GPIO High speed 6 GPIOHS7 GPIO High speed 7 GPIOHS8 GPIO High speed 8 GPIOHS9 GPIO High speed 9 GPIOHS10 GPIO High speed 10 GPIOHS11 GPIO High speed 11 GPIOHS12 GPIO High speed 12 GPIOHS13 GPIO High speed 13 GPIOHS14 GPIO High speed 14 GPIOHS15 GPIO High speed 15 GPIOHS16 GPIO High speed 16 GPIOHS17 GPIO High speed 17 GPIOHS18 GPIO High speed 18 GPIOHS19 GPIO High speed 19 GPIOHS20 GPIO High speed 20 GPIOHS21 GPIO High speed 21 GPIOHS22 GPIO High speed 22 GPIOHS23 GPIO High speed 23 GPIOHS24 GPIO High speed 24 GPIOHS25 GPIO High speed 25 GPIOHS26 GPIO High speed 26 GPIOHS27 GPIO High speed 27 GPIOHS28 GPIO High speed 28 GPIOHS29 GPIO High speed 29 GPIOHS30 GPIO High speed 30 GPIOHS31 GPIO High speed 31 GPIO0 GPIO pin 0 GPIO1 GPIO pin 1 GPIO2 GPIO pin 2 GPIO3 GPIO pin 3 GPIO4 GPIO pin 4 GPIO5 GPIO pin 5 GPIO6 GPIO pin 6 GPIO7 GPIO pin 7 UART1_RX UART1 Receiver UART1_TX UART1 Transmitter UART2_RX UART2 Receiver UART2_TX UART2 Transmitter UART3_RX UART3 Receiver UART3_TX UART3 Transmitter SPI1_D0 SPI1 Data 0 SPI1_D1 SPI1 Data 1 SPI1_D2 SPI1 Data 2 SPI1_D3 SPI1 Data 3 SPI1_D4 SPI1 Data 4 SPI1_D5 SPI1 Data 5 SPI1_D6 SPI1 Data 6 SPI1_D7 SPI1 Data 7 SPI1_SS0 SPI1 Chip Select 0 SPI1_SS1 SPI1 Chip Select 1 SPI1_SS2 SPI1 Chip Select 2 SPI1_SS3 SPI1 Chip Select 3 SPI1_ARB SPI1 Arbitration SPI1_SCLK SPI1 Serial Clock SPI_SLAVE_D0 SPI Slave Data 0 SPI_SLAVE_SS SPI Slave Select SPI_SLAVE_SCLK SPI Slave Serial Clock I2S0_MCLK I2S0 Master Clock I2S0_SCLK I2S0 Serial Clock(BCLK) I2S0_WS I2S0 Word Select(LRCLK) I2S0_IN_D0 I2S0 Serial Data Input 0 I2S0_IN_D1 I2S0 Serial Data Input 1 I2S0_IN_D2 I2S0 Serial Data Input 2 I2S0_IN_D3 I2S0 Serial Data Input 3 I2S0_OUT_D0 I2S0 Serial Data Output 0 I2S0_OUT_D1 I2S0 Serial Data Output 1 I2S0_OUT_D2 I2S0 Serial Data Output 2 I2S0_OUT_D3 I2S0 Serial Data Output 3 I2S1_MCLK I2S1 Master Clock I2S1_SCLK I2S1 Serial Clock(BCLK) I2S1_WS I2S1 Word Select(LRCLK) I2S1_IN_D0 I2S1 Serial Data Input 0 I2S1_IN_D1 I2S1 Serial Data Input 1 I2S1_IN_D2 I2S1 Serial Data Input 2 I2S1_IN_D3 I2S1 Serial Data Input 3 I2S1_OUT_D0 I2S1 Serial Data Output 0 I2S1_OUT_D1 I2S1 Serial Data Output 1 I2S1_OUT_D2 I2S1 Serial Data Output 2 I2S1_OUT_D3 I2S1 Serial Data Output 3 I2S2_MCLK I2S2 Master Clock I2S2_SCLK I2S2 Serial Clock(BCLK) I2S2_WS I2S2 Word Select(LRCLK) I2S2_IN_D0 I2S2 Serial Data Input 0 I2S2_IN_D1 I2S2 Serial Data Input 1 I2S2_IN_D2 I2S2 Serial Data Input 2 I2S2_IN_D3 I2S2 Serial Data Input 3 I2S2_OUT_D0 I2S2 Serial Data Output 0 I2S2_OUT_D1 I2S2 Serial Data Output 1 I2S2_OUT_D2 I2S2 Serial Data Output 2 I2S2_OUT_D3 I2S2 Serial Data Output 3 RESV0 Reserved function RESV1 Reserved function RESV2 Reserved function RESV3 Reserved function RESV4 Reserved function RESV5 Reserved function I2C0_SCLK I2C0 Serial Clock I2C0_SDA I2C0 Serial Data I2C1_SCLK I2C1 Serial Clock I2C1_SDA I2C1 Serial Data I2C2_SCLK I2C2 Serial Clock I2C2_SDA I2C2 Serial Data CMOS_XCLK DVP System Clock CMOS_RST DVP System Reset CMOS_PWDN DVP Power Down Mode CMOS_VSYNC DVP Vertical Sync CMOS_HREF DVP Horizontal Reference output CMOS_PCLK Pixel Clock CMOS_D0 Data Bit 0 CMOS_D1 Data Bit 1 CMOS_D2 Data Bit 2 CMOS_D3 Data Bit 3 CMOS_D4 Data Bit 4 CMOS_D5 Data Bit 5 CMOS_D6 Data Bit 6 CMOS_D7 Data Bit 7 SCCB_SCLK SCCB Serial Clock SCCB_SDA SCCB Serial Data UART1_CTS UART1 Clear To Send UART1_DSR UART1 Data Set Ready UART1_DCD UART1 Data Carrier Detect UART1_RI UART1 Ring Indicator UART1_SIR_IN UART1 Serial Infrared Input UART1_DTR UART1 Data Terminal Ready UART1_RTS UART1 Request To Send UART1_OUT2 UART1 User-designated Output 2 UART1_OUT1 UART1 User-designated Output 1 UART1_SIR_OUT UART1 Serial Infrared Output UART1_BAUD UART1 Transmit Clock Output UART1_RE UART1 Receiver Output Enable UART1_DE UART1 Driver Output Enable UART1_RS485_EN UART1 RS485 Enable UART2_CTS UART2 Clear To Send UART2_DSR UART2 Data Set Ready UART2_DCD UART2 Data Carrier Detect UART2_RI UART2 Ring Indicator UART2_SIR_IN UART2 Serial Infrared Input UART2_DTR UART2 Data Terminal Ready UART2_RTS UART2 Request To Send UART2_OUT2 UART2 User-designated Output 2 UART2_OUT1 UART2 User-designated Output 1 UART2_SIR_OUT UART2 Serial Infrared Output UART2_BAUD UART2 Transmit Clock Output UART2_RE UART2 Receiver Output Enable UART2_DE UART2 Driver Output Enable UART2_RS485_EN UART2 RS485 Enable UART3_CTS UART3 Clear To Send UART3_DSR UART3 Data Set Ready UART3_DCD UART3 Data Carrier Detect UART3_RI UART3 Ring Indicator UART3_SIR_IN UART3 Serial Infrared Input UART3_DTR UART3 Data Terminal Ready UART3_RTS UART3 Request To Send UART3_OUT2 UART3 User-designated Output 2 UART3_OUT1 UART3 User-designated Output 1 UART3_SIR_OUT UART3 Serial Infrared Output UART3_BAUD UART3 Transmit Clock Output UART3_RE UART3 Receiver Output Enable UART3_DE UART3 Driver Output Enable UART3_RS485_EN UART3 RS485 Enable TIMER0_TOGGLE1 TIMER0 Toggle Output 1 TIMER0_TOGGLE2 TIMER0 Toggle Output 2 TIMER0_TOGGLE3 TIMER0 Toggle Output 3 TIMER0_TOGGLE4 TIMER0 Toggle Output 4 TIMER1_TOGGLE1 TIMER1 Toggle Output 1 TIMER1_TOGGLE2 TIMER1 Toggle Output 2 TIMER1_TOGGLE3 TIMER1 Toggle Output 3 TIMER1_TOGGLE4 TIMER1 Toggle Output 4 TIMER2_TOGGLE1 TIMER2 Toggle Output 1 TIMER2_TOGGLE2 TIMER2 Toggle Output 2 TIMER2_TOGGLE3 TIMER2 Toggle Output 3 TIMER2_TOGGLE4 TIMER2 Toggle Output 4 CLK_SPI2 Clock SPI2 CLK_I2C2 Clock I2C2 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/Maix/gpio.html":{"url":"libs/Maix/gpio.html","title":"GPIO","keywords":"","body":"GPIO General Purpose Input Output is referred to as GPIO, or bus extender. High speed gpio and universal gpio on the K210 On the K210, GPIO has the following characteristics: High speed GPIO: The high-speed GPIO is GPIOHS, a total of 32. Has the following characteristics: • Configurable input and output signals • Each IO has an independent interrupt source • Interrupt support edge trigger and level trigger • Each IO can be assigned to one of the 48 pins on the FPIOA • Configurable up and down, or high resistance General GPIO: There are 8 general-purpose GPIOs with the following characteristics: • 8 IOs use one interrupt source • Configurable input and output signals • Configurable trigger IO total interrupt, edge trigger and level trigger • Each IO can be assigned to one of the 48 pins on the FPIOA Attention: Some GPIOHS used by default, don't use these GPIOHS if you don't have to, GPIOHS used as follows: GPIOHS Function GPIOHS31 LCD_DC GPIOHS30 LCD_RST GPIOHS29 SD_CS GPIOHS28 MIC_LED_CLK GPIOHS27 MIC_LED_DATA Constructor Class GPIO(ID, MODE, PULL, VALUE) Create a new SPI object with the specified parameters Parameters ID: The GPIO pin used (must be specified using the constants in GPIO) MODE: GPIO mode • GPIO.IN is the input mode • GPIO.OUT is the output mode PULL: GPIO pull-down mode * • GPIO.PULL_UP pull up • GPIO.PULL_DOWN dropdown • GPIO.PULL_NONE does not pull up or pull down method value Modify/read GPIO pin status GPIO.value([value]) Parameters [value]: optional parameter, if this parameter is not empty, return the current GPIO pin status return value Returns the current GPIO pin status if the [value] parameter is not empty irq Configure an interrupt handler to call when the pin's trigger source is active. If the pin mode is pin.in, the trigger source is an external value on the pin. GPIO.irq(CALLBACK_FUNC, TRIGGER_CONDITION, GPIO.WAKEUP_NOT_SUPPORT, PRORITY) Parameters CALLBACK_FUNC: callback function, called when the interrupt is triggered, it has two parameters, GPIO and PIN_NUM • GPIO returns a GPIO object • PIN_NUM returns the GPIO pin number that triggered the interrupt (only GPIOHS supports interrupts, so the pin number here is also the GPIOHS pin number) TRIGGER_CONDITION: Trigger interrupt when GPIO pin is in this state • GPIO.IRQ_RISING rising edge trigger • GPIO.GPIO.IRQ_FALLING falling edge trigger • GPIO.IRQ_BOTH is triggered on both rising and falling edges return value no disirq Close interrupt GPIO.disirq() Parameters no return value no mode GPIO mode GPIO.mode(MODE) Parameters MODE • GPIO.IN is the input mode • GPIO.OUT is the output mode return value no pull GPIO pull-down mode GPIO.pull(PULL) Parameters PULL • GPIO.IRQ_RISING rising edge trigger • GPIO.IRQ_FALLING falling edge trigger • GPIO.IRQ_BOTH is triggered on both rising and falling edges return value no Constant GPIO0: GPIO0 GPIO1: GPIO1 GPIO2: GPIO2 GPIO3: GPIO3 GPIO4: GPIO4 GPIO5: GPIO5 GPIO6: GPIO6 GPIO7: GPIO7 GPIOHS0: GPIOHS0 GPIOHS1: GPIOHS1 GPIOHS2: GPIOHS2 GPIOHS3: GPIOHS3 GPIOHS4: GPIOHS4 GPIOHS5: GPIOHS5 GPIOHS6: GPIOHS6 GPIOHS7: GPIOHS7 GPIOHS8: GPIOHS8 GPIOHS9: GPIOHS9 GPIOHS10: GPIOHS10 GPIOHS11: GPIOHS11 GPIOHS12: GPIOHS12 GPIOHS13: GPIOHS13 GPIOHS14: GPIOHS14 GPIOHS15: GPIOHS15 GPIOHS16: GPIOHS16 GPIOHS17: GPIOHS17 GPIOHS18: GPIOHS18 GPIOHS19: GPIOHS19 GPIOHS20: GPIOHS20 GPIOHS21: GPIOHS21 GPIOHS22: GPIOHS22 GPIOHS23: GPIOHS23 GPIOHS24: GPIOHS24 GPIOHS25: GPIOHS25 GPIOHS26: GPIOHS26 GPIOHS27: GPIOHS27 GPIOHS28: GPIOHS28 GPIOHS29: GPIOHS29 GPIOHS30: GPIOHS30 GPIOHS31: GPIOHS31 GPIO.IN: input mode GPIO.OUT: output mode GPIO.PULL_UP: Pull up GPIO.PULL_DOWN: drop down GPIO.PULL_NONE: does not pull up or pull down GPIO.IRQ_RISING: rising edge trigger GPIO.IRQ_FALLING: falling edge trigger GPIO.IRQ_BOTH: Both rising and falling edges are triggered DEMO1 import utime from Maix import GPIO fm.register(board_info.LED_R,fm.fpioa.GPIO0) led_r=GPIO(GPIO.GPIO0,GPIO.OUT) utime.sleep_ms(500) led_r.value() fm.unregister(board_info.LED_R,fm.fpioa.GPIO0) DEMO2 import utime from Maix import GPIO fm.register(board_info.LED_R,fm.fpioa.GPIO0) led_r=GPIO(GPIO.GPIO0,GPIO.IN) utime.sleep_ms(500) led_r.value() fm.unregister(board_info.LED_R,fm.fpioa.GPIO0) DEMO3 import utime from Maix import GPIO def test_irq(GPIO,pin_num): print(\"key\",pin_num,\"\\n\") fm.register(board_info.BOOT_KEY,fm.fpioa.GPIOHS0) key=GPIO(GPIO.GPIOHS0,GPIO.IN,GPIO.PULL_NONE) utime.sleep_ms(500) key.value() key.irq(test_irq,GPIO.IRQ_BOTH,GPIO.WAKEUP_NOT_SUPPORT,7) key.disirq() fm.unregister(board_info.BOOT_KEY,fm.fpioa.GPIOHS0) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/Maix/kpu.html":{"url":"libs/Maix/kpu.html","title":"KPU","keywords":"","body":"KPU KPU is a general-purpose neural network processor, which can do convolutional neural network calculation at low power consumption, for example obtain the size, coordinates and types of detected objects or detect and classify faces and objects. KPU has the following features: Supports fixed-point models trained by mainstream framework with some restrictions There is no direct limit on the number of network layers. It supports separate configuration of each layer of convolutional neural network parameters, including the number of input and output channels, input and output line width and column height. Supports two convolution kernels 1x1 and 3x3 Support any form of activation function The maximum supported neural network parameter size in real-time work is 5.5MiB to 5.9MiB Maximum supported network parameter size when working in non-real time (Flash capacity - software volume) Module Method Loading the model Load a model from flash or file system import KPU as kpu task = kpu.load(offset or file_path) Parameters offtset: The offset of the model in flash, such as 0xd00000 indicates that the model is flashed at the beginning of 13M file_path: The model is the file name in the file system, such as \"/sd/xxx.kmodel\" Back kpu_net: kpu network object Initializing the yolo2 network Passing initialization parameters for the yolo2 network model import KPU as kpu task = kpu.load(offset or file_path) anchor = (1.889, 2.5245, 2.9465, 3.94056, 3.99987, 5.3658, 5.155437, 6.92275, 6.718375, 9.01025) kpu.init_yolo2(task, 0.5, 0.3, 5, anchor) Parameters kpu_net: kpu network object threshold: probability threshold nms_value: box_iou threshold anchor_num: number of anchors anchor: anchor parameters are consistent with model parameters initialization import KPU as kpu task = kpu.load(offset or file_path) kpu.deinit(task) Parameters kpu_net: kpu_net object returned by kpu_load Running yolo2 network import KPU as kpu import image task = kpu.load(offset or file_path) anchor = (1.889, 2.5245, 2.9465, 3.94056, 3.99987, 5.3658, 5.155437, 6.92275, 6.718375, 9.01025) kpu.init_yolo2(task, 0.5, 0.3, 5, anchor) img = image.Image() kpu.run_yolo2(task, img) #This is not right, please refer to the routine Parameters kpu_net: kpu_net object returned by kpu_load image_t: image captured from sensor Back list: list of kpu_yolo2_find Network forward operation (forward) Calculate the loaded network model to the specified number of layers 3, and output the feature map of the target layer import KPU as kpu task = kpu.load(offset or file_path) …… fmap=kpu.forward(task,img,3) Parameters kpu_net: kpu_net object image_t: image captured from sensor int: specifies the number of layers to calculate to the network Back fmap: Feature map object, containing the feature map of all channels of the current layer fmap feature map Take the specified channel data of the feature map to the image object img=kpu.fmap(fmap,1) Parameters fmap: feature map object int: specify the channel number of the feature map Back img_t: The grayscale image generated by the corresponding map of the feature map fmap_free Release Feature Map Release feature map object kpu.fmap_free(fmap) Parameters fmap: feature map object Back none netinfo Get the network structure information of the model info=kpu.netinfo(task) layer0=info[0] Parameters kpu_net: kpu_net object Back netinfo list: a list of all layers of information, including information:Index: the number of layers of the current layer in the network Wi: input width Hi: input height Wo: output width Ho: output height Chi: number of input channels Cho: number of output channels Dw: whether it is a depth wise layer Kernel_type: convolution kernel type, 0 is 1x1, 1 is 3x3 Pool_type: pooling type, 0 is not pooled; 1:2x2 max pooling; 2:... Para_size: the number of bytes of the convolution parameter of the current layer Routine Running face recognition demo Model download address: http://dl.sipeed.com/MAIX/MaixPy/model/face_model_at_0x300000.kfpkg import sensor import image import lcd import KPU as kpu lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) task = kpu.load(0x300000) #使用kfpkg将 kmodel 与 maixpy 固件打包下载到 flash anchor = (1.889, 2.5245, 2.9465, 3.94056, 3.99987, 5.3658, 5.155437, 6.92275, 6.718375, 9.01025) a = kpu.init_yolo2(task, 0.5, 0.3, 5, anchor) while(True): img = sensor.snapshot() code = kpu.run_yolo2(task, img) if code: for i in code: print(i) a = img.draw_rectangle(i.rect()) a = lcd.display(img) a = kpu.deinit(task) Operational feature map Model download address: http://dl.sipeed.com/MAIX/MaixPy/model/face_model_at_0x300000.kfpkg The model is an 8-bit fixed-point model, about 380KB in size, and the layer information is: 1 2 : 160x120 3 4 5 6 : 80x60 7 8 9 10 :40x30 11~16 : 20x15 import sensor import image import lcd import KPU as kpu index=3 lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) task=kpu.load(0x300000) img=image.Image() info=kpu.netinfo(task) layer=info[index] w=layer.wo() h=layer.ho() num=int(320*240/w/h) list=[None]*num x_step=int(320/w) y_step=int(240/h) img_lcd=image.Image() while True: img=sensor.snapshot() fmap=kpu.forward(task,img,index) for i in range(0,num): list[i]=kpu.fmap(fmap,i) for i in range(0,num): list[i].stretch(64,255) for i in range(0,num): a=img_lcd.draw_image(list[i],((i%x_step)*w,(int(i/x_step))*h)) lcd.display(img_lcd) kpu.fmap_free(fmap) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/Maix/fft.html":{"url":"libs/Maix/fft.html","title":"FFT","keywords":"","body":"FFT operation The FFT fast Fourier transform module performs Fourier transform on the input data and returns the corresponding frequency amplitudes. The FFT fast Fourier operation can convert the time domain signal into the frequency domain signal. Module function arithmetic function Enter time domain data and perform Fourier transform import FFT res = FFT.run(data, points, shift) Parameters data: input time domain data, bytearray type points: FFT operation points, only supports 64, 128, 256 and 512 points shift: offset, default is 0 return value res: Returns the calculated frequency domain data, presented as list type. The list has points tuples, each tuple has 2 elements, the first element is the real part, and the second is Imaginary Frequency function FFT res = FFT.freq(points, sample_rate) Parameters points: Calculate points sample_rate: sample rate return value res : Returns a list of the frequency values ​​of all frequency points after the operation Amplitude function It is used to calculate the amplitude of each frequency point after the FFT operation. It is currently used as a test. Users can write their own amplitude processing functions in python. amp = FFT.amplitude(FFT_res) Parameters FFT_res: function run results after running return value res : Returns a list that stores the magnitude of each frequency point Routine Acquire sound and perform FFT operation, and display the calculated data on the screen as a histogram from Maix import GPIO from Maix import I2S from Maix import FFT import image import lcd lcd.init() fm.register(8, fm.fpioa.GPIO0) wifi_en=GPIO(GPIO.GPIO0,GPIO.OUT) wifi_en.value(0) fm.register(20,fm.fpioa.I2S0_IN_D0) fm.register(19,fm.fpioa.I2S0_WS) fm.register(18,fm.fpioa.I2S0_SCLK) rx = I2S(I2S.DEVICE_0) rx.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode = I2S.STANDARD_MODE) sample_rate = 38640 rx.set_sample_rate(sample_rate) img = image.Image() sample_points = 1024 FFT_points = 512 lcd_width = 320 lcd_height = 240 hist_num = FFT_points #changeable if hist_num > 320: hist_num = 320 hist_width = int(320 / hist_num)#changeable x_shift = 0 while True: audio = rx.record(sample_points) FFT_res = FFT.run(audio.to_bytes(),FFT_points) FFT_amp = FFT.amplitude(FFT_res) img = img.clear() x_shift = 0 for i in range(hist_num): if FFT_amp[i] > 240: hist_height = 240 else: hist_height = FFT_amp[i] img = img.draw_rectangle((x_shift,240-hist_height,hist_width,hist_height),[255,255,255],2,True) x_shift = x_shift + hist_width lcd.display(img) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/Maix/i2s.html":{"url":"libs/Maix/i2s.html","title":"I2S","keywords":"","body":"I2S The I2S module is mainly used to drive I2S devices. The k210 has a total of 3 I2S devices and each device has a total of 4 channels. Before use, it is necessary to map and manage the pins. Module functions Constructor Create a new I2S object from Maix import I2S i2s_dev = I2S (device_num) parameters device_num UART number, using the specified I2S, which can be completed by pressing the I2S.` tab return value Returns an I2S object Channel configuration function Used to configure I2S channels. Pin mapping is required before i2s_dev.channel_config (channel, mode, resolution, cycles, align_mode) parameters channel: I2S channel number mode: channel transmission mode. There are a total of receiving and sending modes. resolution: channel resolution, ie the number of received data bits cycles: number of single data clocks align_mode: channel alignment mode return value no Set the sampling rate Used to configure the I2S sampling rate i2s_dev.set_sample_rate (sample_rate) parameters sample_rate: return value no Receive audio Receive audio data using I2S audio = i2s_dev.record (points) parameters points: audio points collected at one time return value audio: an audio audio object Send audio Send audio data using I2S i2s_dev.play (audio) parameters audio: the audio object to send return value no Examples Routine 1 from Maix import I2S import time fm.register (20, fm.fpioa.I2S0_IN_D0) #GO fm.register (19, fm.fpioa.I2S0_WS) fm.register (18, fm.fpioa.I2S0_SCLK) fm.register (34, fm.fpioa.I2S2_OUT_D1) fm.register (35, fm.fpioa.I2S2_SCLK) fm.register (33, fm.fpioa.I2S2_WS) sample_rate = 44 * 1000 rx = I2S (I2S.DEVICE_0) rx.channel_config (rx.CHANNEL_0, rx.RECEIVER, align_mode = I2S.STANDARD_MODE) rx.set_sample_rate (sample_rate) tx = I2S (I2S.DEVICE_2) tx.channel_config (tx.CHANNEL_1, tx.TRANSMITTER, align_mode = I2S.RIGHT_JUSTIFYING_MODE) tx.set_sample_rate (sample_rate) while True: audio = rx.record (256) #sampling points number must be smaller than 256 tx.play (audio) Routine 2 from Maix import I2S from Maix import Audio from Maix import FFT import time fm.register (20, fm.fpioa.I2S0_IN_D0) fm.register (19, fm.fpioa.I2S0_WS) fm.register (18, fm.fpioa.I2S0_SCLK) fm.register (34, fm.fpioa.I2S2_OUT_D1) fm.register (35, fm.fpioa.I2S2_SCLK) fm.register (33, fm.fpioa.I2S2_WS) rx = I2S (I2S.DEVICE_0) rx.channel_config (rx.CHANNEL_0, rx.RECEIVER, align_mode = I2S.STANDARD_MODE) rx.set_sample_rate (16000) tx = I2S (I2S.DEVICE_2) tx.channel_config (tx.CHANNEL_1, tx.TRANSMITTER, align_mode = I2S.RIGHT_JUSTIFYING_MODE) tx.set_sample_rate (16000) while True: audio = rx.record (256) audio_data = audio.to_bytes () play_audio = Audio (audio_data) tx.play (play_audio) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/Maix/audio.html":{"url":"libs/Maix/audio.html","title":"Audio","keywords":"","body":"audio An abstract audio object that can be passed in as a parameter or use its methods to play audio directly Module functions Constructor Constructing an Audio object audio.Audio (array = None, path = None, points = 1024) parameters This interface can pass a parameter, each parameter will determine a different audio type array: data of typebytearray, which can be converted to audio objects, default None path: The path of the opened audio file, currently only supports thewav format. The default is None, Note The keywordspath, audio.Audio (\" / sd / 1.wav \" )This is wrong! !! audio.Audio (path =\" /sd/1.wav \") is correct points: open audio buffer with points sample points, one sample point size is 32bit. If it is 0, the buffer will not be opened. The default is 1024. return value Returns an Audio object to_bytes: bytes conversion function Converts audio data in an audio object to an object of type bytearray audio_data = test_audio.to_bytes () parameters no return value The returned audio data bytearray object play_process: Play preprocessing function It is used to preprocess audio objects, and audio files need to be parsed before playback, so preprocessing is required. Here you need to pass in an I2S device for playback wav_info = test_audio.play_process (i2s_dev) parameters i2s_dev: i2s device for playback return value Header information of the wav file, list type, which arenumchannels, samplerate,byterate, blockalign,bitspersample, datasize play: Play function Read audio files and parse them. Generally used in conjunction with loops. parameters no return value None: Format does not support playback 0: End of playback 1: Now playing finish: Audio post-processing functions Complete the audio playback. This function must be called after the playback is completed, and the underlying allocated resources are recycled. parameters no return value no Examples Play wav audio from fpioa_manager import * from Maix import I2S, GPIO import audio # disable wifi fm.register (8, fm.fpioa.GPIO0) wifi_en = GPIO (GPIO.GPIO0, GPIO.OUT) wifi_en.value (0) # register i2s (i2s0) pin fm.register (34, fm.fpioa.I2S0_OUT_D1) fm.register (35, fm.fpioa.I2S0_SCLK) fm.register (33, fm.fpioa.I2S0_WS) # init i2s (i2s0) wav_dev = I2S (I2S.DEVICE_0) # init audio player = audio.Audio (path = \"/sd/6.wav\") player.volume (40) # read audio info wav_info = player.play_process (wav_dev) print (\"wav file head information:\", wav_info) # config i2s according to audio info wav_dev.channel_config (wav_dev.CHANNEL_1, I2S.TRANSMITTER, resolution = I2S.RESOLUTION_16_BIT, cycles = I2S.SCLK_CYCLES_32, align_mode = I2S.RIGHT_JUSTIFYING_MODE) wav_dev.set_sample_rate (wav_info [1]) # loop to play audio while True: ret = player.play () if ret == None: print (\"format error\") break elif ret == 0: print (\"end\") break player.finish () powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/Maix/freq.html":{"url":"libs/Maix/freq.html","title":"freq","keywords":"","body":"Maix.freq Frequency module, support program to modify cpu and kpu frequency Method freq.set (cpu, pll1, kpu_div) Set cpu or kpu frequency, it will restart automatically after setting Please note that after the frequency setting is completed, some peripheral performance may be changed. from Maix import freq freq.set (cpu = 400, kpu = 400) The configuration file will be saved in the /flash/freq.conf file of the file system. Do not modify this file. If the file does not exist, it will be automatically created parameters Parameters not set will retain their previous values Note: If the cpu frequency setting is less than60MHz, the default REPL serial baud rate will be set to9600 cpu: The cpu frequency you want to set, the range is [26,600] (The chip has a maximum800 but has voltage requirements. The series supported by MaixPy do not support up to800, the default 400, different boards May behave differently, not recommended for stability pll1: Frequency ofpll1 output, value range [26,1200] (chip maximum 1800, MaixPy limited to 1200), default 400 kpu_div:kpu clock frequency divider. The value range is [1,16]. kpu frequency =pll1 / kpu_div. For example, if you want to set thekpu frequency to 400, you only need to setpll1 to 400 andkpu_div to 1. Note the kpu frequency range: [26,600] return value If the frequency does not change, it returns null. If the frequency changes, the machine will restart automatically. Please confirm whether the current situation can restart before using this interface freq.get () Get the currently set frequency parameters return value cpu frequency andkpu frequency, returned as a tuple, such as (400,400) freq.get_cpu () Get the current cpu frequency return value cpu frequency freq.get_kpu () Get the currently set kpu frequency return value Current kpu frequency powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/Maix/utils.html":{"url":"libs/Maix/utils.html","title":"utils","keywords":"","body":"Maix.utils gc_heap_size ([size]) Get or set the GC heap size. If you report insufficient memory, you can consider setting a larger size. Parameters None or Pass in a new GC heap size. If there is no parameter, just get the heap size; If there are parameters, set the heap size, and then restart automatically Return value GC heap size powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/builtin_py/":{"url":"libs/builtin_py/","title":"Built-in class","keywords":"","body":"Built-in class The library is a user-level interface that encapsulates the underlying classes of MaixPy, making it easy for users to use MaixPy, which includes the following: fpioa_manager board_info 需要注意的是， 这些类在开机启动的时候在 _boot.py 里面已经被导入了， 所以在串口终端可以直接使用， 但是， 如果是执行文件， 则需要手动写代码导入， 否则找不到类 Be attention, theses class imported at the start up by _boot.py, so we can directly use it in serial terminal without any import, but if we execute file, we need to import by ourselves~ from board import board_info from fpioa_manager import fm or from fpioa_manager import fm, board_info powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/builtin_py/fm.html":{"url":"libs/builtin_py/fm.html","title":"fpioa_manager","keywords":"","body":"FPIOA Manager fpioa_manager: referred to as fm, this module is used to register internal functions and pins of the chip, to help users manage internal functions and pins. If the functions and pins are already registered, the internal functions and pins will not be available. Actually fm is global variable define with Fpioa_Manager class, written by Micropython and integrated to firmware, source code see board.py method Registration function Register pins and functions fm.register(pin,function) Parameters This method must pass in 2 parameters, otherwise it will return a null value. pin: function mapping pin function : chip function return value This method has 2 return values. Parameter error returns None,None Set the success to return pin, function Setting fails to return reg_pin, reg_func, indicating the pins and functions that have been registered Logout function Logout pin and function fm.unregister(pin,function) Parameters This method can pass 1 or 2 parameters. When passing in 1 parameter, you need to add a parameter keyword. If it is 1 parameter, its pins and functions will be logged out. pin: function mapping pin function : chip function return value Parameter error returns None,None Set successfully returns pin, function, indicating the pin and function being logged out Set failure to return 0,0 Routine from fpioa_manager import fm, board_info fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX)#Register again fm.register(board_info.WIFI_RX,fm.fpioa.SPI0_SS0)#Register the same pin fm.register(board_info.WIFI_RX,fm.fpioa.SPI0_SS0)#Register the same function fm.unregister(board_info.WIFI_RX, fm.fpioa.UART2_TX)#Logout function and pin fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.unregister(function = fm.fpioa.UART2_TX)#Logout function fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.unregister(pin = board_info.WIFI_RX)#Logout pin Appendix The following pins have been registered when MaxiPy is powered on. Please pay attention to the user. SD card Function: SPI1_SCLK/SPI1_D0/SPI1_D1/GPIOHS7/SPI0_SS1 Pin: PIN25/PIN26/PIN27/PIN28/PIN29 LCD Function: SPI0_SS3/SPI0_SCLK/GPIOHS1/GPIOHS2 Pin: PIN36/PIN37/PIN38/PIN39 sensor Function: SCCB_SDA/SCCB_SCLK/CMOS_RST/CMOS_VSYNC/CMOS_PWDN/CMOS_HREF/CMOS_XCLK/CMOS_PCLK Pin: PIN40/PIN41/PIN42/PIN43/PIN44/PIN45/PIN46/PIN47 REPL Function: UARTHS_RX/UARTHS_TX Pin: PIN4/PIN5 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/builtin_py/board_info.html":{"url":"libs/builtin_py/board_info.html","title":"board_info","keywords":"","body":"board_info board_info: Mainly used for user-friendly development board pin configuration, built-in user-friendly naming and interface, which allows users to reduce the dependence on the electrical connection schematic. board_info is a global variable defined with Board_Info class, written by MicroPython and integrated to firmware, source code see fpioa_manager.py Members Board_info has many pin indexes and a list pin_namelist The list is mainly used internally by the class, and the user does not operate it. Pin Index The pin index is mainly to convert numbers into human-friendly strings, which is convenient for users to program. Enter the following, please be careful not to ignore the . number, then press the tab key to complete, you can see the board-related pin functions. Board_info. For example, enter the following code, it will return the number 8, which represents the 8th pin of the development board, and its electrical connection is the enable pin of the wifi module. board_info.WIFI_EN method Search method When the user does not know the pin electrical connection, you can use this method to find Board_info.pin_map(pin_num) Parameters This method does not pass in parameters or pass in a parameter pin_num: pin number, range [6,47] Board-level electrical connection information for all pins will be printed when no parameters are passed in When the parameters are passed in, only the board-level electrical connection information for the specified pin is printed. return value Parameter error returns False Unknown error return False Find successful return information Routine Routine 1 from board import board_info Wifi_en_pin = board_info.WIFI_EN Print(wifi_en_pin)# output is 8 Board_info.pin_map()# print all Board_info.pin_map(8)# prints only pin 8 information powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/machine_vision/":{"url":"libs/machine_vision/","title":"Machine vision","keywords":"","body":"Machine vision It mainly contains classes related to images and displays, including: LCD Sensor Image powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/machine_vision/lcd.html":{"url":"libs/machine_vision/lcd.html","title":"lcd","keywords":"","body":"Lcd screen display driver function lcd.init(type=1, freq=15000000, color=lcd.BLACK) Initialize the LCD screen to display Parameters type: type of LCD (reserved for future use): 0: None 1: lcd shield (default) type is a key-value parameter that must be explicitly called by writing type= in the function call freq: frequency of lcd ( actually maybe SPI ) color： LCD initialized color, 16 bits RGB565 color, e.g. 0xFFFF; or RGB888 tuple, e.g. (236, 36, 36), default lcd.BLACK lcd.deinit() Unregister the LCD driver to release the I/O pins lcd.width() Returns the width of the LCD (horizontal resolution) lcd.height() Returns the height of the LCD (vertical resolution). lcd.type() Returns the type of LCD (reserved for future use): 0: None 1: lcd Shield lcd.freq(freq) Set or get frequency of LCD (SPI) Paremeters freq: frequency of LCD (SPI) Return frequency of LCD lcd.set_backlight(state) Setting the backlight status of LCD, turning off the backlight will greatly reduce the energy consumption of the LCD expansion board. //TODO: Not implemented Parameters state: backlight brightness, value [0,100] lcd.get_backlight() Return to backlight status return value Backlight brightness, value [0,100] lcd.display(image, roi=Auto) Display a image (GRAYSCALE or RGB565) on the LCD. Roi is a rectangular tuple (x, y, w, h) of a region of interest. If not specified, it is an image rectangle If the roi width is less than the lcd width, the vertical black border is used to make roi at the center of the screen (that is, fill the unoccupied area with black). If the roi width is greater than the lcd width, roi is at the center of the screen, and the unmatched pixels are not displayed (ie, the LCD displays the center of roi in window form). If the roi height is less than the lcd height, use a vertical black border to center roi in the center of the screen (ie fill the unoccupied area with black). If the roi height is greater than the lcd height, roi is at the center of the screen, and the unmatched pixels are not displayed (ie, the LCD displays the center of roi in window form). roi is a key-value parameter that must be explicitly called by writing roi= in a function call. lcd.clear() Empty the LCD screen to black or other color. Parameters color： LCD initialized color, 16 bits RGB565 color, e.g. 0xFFFF; or RGB888 tuple, e.g. (236, 36, 36) lcd.direction(dir) Set LCD direction and mirror parameters maybe change in the future Parameters dir： nomally lcd.YX_LRUD or lcd.YX_RLDU， other values just exchange XY or LR or DU Routine Routine 1: Display English import lcd lcd.init() lcd.draw_string(100, 100, \"hello maixpy\", lcd.RED, lcd.BLACK) Routine 2: Displaying pictures import lcd import image img = image.Image(\"/sd/pic.bmp\") lcd.display(img) Routine 3: Display English in the form of displaying pictures import lcd import image img = image.Image() img.draw_string(60, 100, \"hello maixpy\", scale=2) lcd.display(img) Routine 4: Real-time display of images captured by the camera import sensor, lcd sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames() lcd.init() while(True): lcd.display(sensor.snapshot()) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/machine_vision/sensor.html":{"url":"libs/machine_vision/sensor.html","title":"sensor","keywords":"","body":"Sensor Sensor module for camera configuration and image capture, etc., used to control the development board camera to complete the camera task method Reset function Reset and initialize the camera. This will automatically scan and get the camera address sensor.reset([, freq=24000000[, set_regs=True[, dual_buff=False]]]) Parameters freq: Set the clock frequency of sensor. The higher the frequency, the higher the frame rate, but the picture quality may be worse. The default is 24MHz. If the camera has colored spots (ov7740), you can lower it appropriately, such as20MHz set_regs: Allows the program to write camera registers. The default isTrue. If you need a custom reset sequence, you can set it to False, and then use the sensor.__ write_reg(addr, value) function to customize the write register sequence dual_buff: The default isFalse.Allowing double buffering will increase the frame rate, but the memory footprint will also increase (about 384KiB) return value no Start function Start or stop the camera sensor.run(enbale) Parameters enbale: 1 means open, 0 means stop return value return: returns 1 Setting the frame size It is used to set the camera output frame size. The k210 supports VGA format at most. If it is larger than VGA, it will not be able to acquire images. The screen of the MaixPy development board is 320*240 resolution, and the recommended setting is QVGA format. sensor.set_framesize(framesize[, set_regs=True]) Parameters framesize: frame size set_regs: Allows the program to write camera registers. The default isTrue. If you need a custom sequence, you can set it to False, and then use the sensor.__ write_reg(addr, value) function to customize the write register sequence return value True : set successfully False: setting error Setting the frame format Used to set the camera output format, k210 supports rgb565 and yuv422 formats. The screen of the MaixPy development board configuration is set using rgb565, and the recommended setting is RGB565 format. sensor.set_pixformat(format[, set_regs=True]) Parameters format: frame format set_regs: Allows the program to write camera registers. The default isTrue. If you need a custom sequence, you can set it to False, and then use the sensor.__ write_reg(addr, value) function to customize the write register sequence return value True : set successfully False: setting error Starting image capture Turn on image capture sensor.run(enable) Parameters enable: 1 means start grabbing image 0 means stop grabbing image return value True : set successfully False: setting error Getting images Control camera capture image img = sensor.snapshot() Parameters no return value img: returned image object Close the camera Turn off the camera sensor.shutdown(enable) Parameters enable: 1 means to turn on the camera 0 means to turn off the camera return value no Frame skipping Skip the specified number of frames or skip the image for the specified time sensor.skip_frames(n, [, time]) Parameters n: skip n frame image time: Skip the specified time in ms return value no Resolution width Get camera resolution width sensor.width() Parameters no return value camera resolution width of int type Resolution Height sensor.height() Parameters no return value int type camera resolution height Get frame buffer Get the current frame buffer sensor.get_fb() Parameters no return value Object of type image Get ID Get the current camera ID sensor.get_id() Parameters no return value int type ID Setting color bar mode Set the camera to color bar mode sensor.set_colorbar(enable) Parameters enable: 1 means to turn on the color bar mode 0 means to turn off the color bar mode return value no Setting the contrast Set camera contrast sensor.set_contrast(contrast) Parameters constrast: camera contrast, range [-2, +2] return value True : set successfully False: setting error Setting brightness Set camera brightness sensor.set_brightness(brightness) Parameters constrast: camera brightness, range [-2, +2] return value True : set successfully False: setting error Setting the saturation Set camera saturation sensor.set_saturation(saturation) Parameters constrast: camera saturation, range [-2, +2] return value True : set successfully False: setting error Setting automatic gain Set the camera automatic gain mode sensor.set_auto_gain(enable,gain_db) Parameters enable: 1 means to turn on automatic gain 0 means to turn off automatic gain gain_db: Set the camera fixed gain value when the auto gain is turned off, the unit is db return value no Get the gain value Get camera gain value sensor.get_gain_db() Parameters no return value Gain value of float type Setting up horizontal mirroring Set the camera horizontal mirror sensor.set_hmirror(enable) Parameters enable: 1 means to turn on horizontal mirroring 0 to turn off horizontal mirroring return value no Write register Write the specified value to the camera register sensor.__write_reg(address, value) Parameters address: register address value : write value return value no Read register Read camera register value sensor.__read_reg(address) Parameters address: register address return value Register value of type int Routine Routine 1 import sensor import lcd lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) while 1: img = sensor.snapshot() lcd.display(img) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/machine_vision/image.html":{"url":"libs/machine_vision/image.html","title":"image","keywords":"","body":"Image — machine vision Ported in openmv, same as openmv Routine Routine 1: Find green import sensor import image import lcd import time lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) green_threshold = (0, 80, -70, -10, -0, 30) while True: img=sensor.snapshot() blobs = img.find_blobs([green_threshold]) if blobs: for b in blobs: tmp=img.draw_rectangle(b[0:4]) tmp=img.draw_cross(b[5], b[6]) c=img.get_pixel(b[5], b[6]) lcd.display(img) Routine 2: Display fps import sensor import image import lcd import clock clock = clock.clock() lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames(30) while True: clock.tick() img = sensor.snapshot() fps =clock.fps() img.draw_string(2,2, (\"%2.1ffps\" %(fps)), color=(0,128,0), scale=2) lcd.display(img) Routine 3: Scan QR code import sensor import image import lcd import clock clock = clock.clock() lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.set_vflip(1) sensor.run(1) sensor.skip_frames(30) while True: clock.tick() img = sensor.snapshot() res = img.find_qrcodes() fps =clock.fps() if len(res) > 0: img.draw_string(2,2, res[0].payload(), color=(0,128,0), scale=2) print(res[0].payload()) lcd.display(img) If the lens is used, the picture will be distorted and the picture needs to be corrected. Use the lens_corr function to correct, such as 2.8mm, img.lens_corr(1.8) function The function can also press Ctrl+F on the page to search for functions using the browser's search function search image. image.rgb_to_lab(rgb_tuple) Returns the tuple (l, a, b) of the LAB format corresponding to the tuple rgb_tuple (r, g, b) in RGB888 format. RGB888 refers to 8 bits (0-255) of red, green and blue. In LAB, L has a value range of 0-100, and a/b ranges from -128 to 127. image.lab_to_rgb(lab_tuple) Returns the tuple (r, g, b) of the RGB888 format corresponding to the tuple lab_tuple (l, a, b) in LAB format. RGB888 refers to 8 bits (0-255) of red, green and blue. In LAB, L has a value range of 0-100, and a/b ranges from -128 to 127. image.rgb_to_grayscale(rgb_tuple) Returns the gray value corresponding to the tuple rgb_tuple (r, g, b) in RGB888 format. RGB888 refers to 8 bits (0-255) of red, green and blue. The gray value is from 0 to 255. image.grayscale_to_rgb(g_value) Returns the tuple (r, g, b) of the RGB888 format corresponding to the gray value g_value. RGB888 refers to 8 bits (0-255) of red, green and blue. The gray value is from 0 to 255. image.load_decriptor(path) Load a descriptor object from the disk. Path is the path where the descriptor file is saved. image.save_descriptor(path, descriptor) Save the descriptor object descriptor to disk. Path is the path where the descriptor file is saved. image.match_descriptor(descritor0, descriptor1[, threshold=70[, filter_outliers=False]]) For the LBP descriptor, this function returns an integer that represents the difference between the two descriptors. This distance measurement is especially necessary. This distance is a measure of similarity. The closer this measure is to 0, the better the LBPF feature points will match. For the ORB descriptor, this function returns the kptmatch object. See above. Threshold is used to filter the ambiguous matching service for the ORB keypoint. A lower threshold value will be tied to the keypoint matching algorithm. The threshold value is at 0-100 (int). The default is 70. Filter_outliers is used to filter outliers for ORB keypoints. Feature points allow the user to increase the threshold value. The default setting is False. HaarCascade Class – Feature Descriptors The Haar Cascade feature descriptor is used for the image.find_features() method. It has no methods for the user to call. Constructor Class image.HaarCascade(path[, stages=Auto]) Load a Haar Cascade from a Haar Cascade binary (a format suitable for OpenMV Cam). If you pass a \"frontalface\" string instead of a path, this constructor will load a built-in positive face Haar Cascade into memory. In addition, you can also load Haar Cascade into memory via \"eye\". Finally, this method returns the loaded Haar Cascade object, which is used to use image.find_features() . The stage default is the number of stages in Haar Cascade. However, you can specify a lower value to speed up the running of the feature detector, which of course leads to a higher false positive rate. You can make your own Haar Cascades to work with your OpenMV Cam. First, use Google search \" Haar Cascade\" to check if someone has created OpenCV Haar Cascade for the object you want to detect. If not, you need to do it yourself (the amount of work is huge). For information on how to make your own Haar Cascade, see here on how to turn OpenCV Haar Cascades into a mode that your OpenMV Cam can read, see this script Q: What is Haar Cascade? A: Haar Cascade is a series of comparison checks used to determine if an object is present in an image. This series of comparison checks is divided into phases, and the operation of the latter phase is premised on the completion of the previous phase. Contrast checks are not complicated, but are like processes that check if the center of the image is slightly more vertical than the edges. A wide range of inspections are carried out first in the early stages, and more small area inspections are carried out later. Q: How was Haar Cascades made? A: Haar Cascades trains generator algorithms with positive and negative images. For example, use hundreds of pictures containing cats (marked as containing cats) and hundreds of pictures that do not contain cats (have been marked differently) to train this generation algorithm. This generation algorithm will eventually generate a Haar Cascades for detecting cats. Similarity Class – Similarity Object The similarity object is returned by image.get_similarity. Constructor Class image.similarity Call the image.get_similarity() function to create this object. Methods similarity.mean() Returns the mean of the similarity difference in 8x8 pixel block structure. Range [-1/+1], where -1 is completely different and +1 is identical. You can also get this value via index [0]. similarity.stdev() Returns the standard deviation of the 8x8 pixel block structure similarity difference. You can also get this value via index [1]. similarity.min() Returns the minimum value of the 8x8 pixel block structure similarity difference. Where -1 is completely different and +1 is identical. You can also get this value via index [2]. By looking at this value, you can quickly determine if any 8x8 pixel blocks between the two images are very different, which is much lower than +1. similarity.max() Returns the minimum value of the 8x8 pixel block structure similarity difference. Where -1 is completely different and +1 is identical. You can also get this value via index [3]. By looking at this value, you can quickly determine if any 8x8 pixel blocks between the two images are the same. That is much larger than -1. Histogram Class – Histogram Object The histogram object is returned by image.get_histogram. A grayscale histogram has a channel that contains multiple binaryes. All binaries are normalized to a total of one. RGB565 has three channels with multiple binary. All binaries are normalized to a total of one. Constructor Class image.histogram Please call the image.get_histogram() function to create this object. Methods histogram.bins() Returns a list of floating point numbers for the grayscale histogram. You can also get this value via index [0]. histogram.l_bins() Returns a list of floating point numbers for the L channel of the RGB565 histogram LAB. You can also get this value via index [0]. histogram.a_bins() Returns a list of floating point numbers for the A channel of the RGB565 histogram LAB. You can also get this value via index [1]. histogram.b_bins() Returns a list of floating point numbers for the B channel of the RGB565 histogram LAB. You can also get this value via index [2]. histogram.get_percentile(percentile) Calculates the CDF of the histogram channel, returning a value that passes the histogram in percentile (0.0 - 1.0) (floating point). Therefore, if you pass in 0.1, this method will tell you which binary will cause the accumulator to cross 0.1 when accumulating the accumulator. This is effective for determining the minimum (0.1) and max(0.9) of the color distribution when there is no anomalous utility to corrupt your adaptive color tracking results. histogram.get_threhsold() Use the Otsu’s method to calculate the optimal threshold, dividing each channel of the histogram into two halves. This method returns an image.threshold object. This method is especially useful for determining the best image.binary() threshold. histogram.get_statistics() Calculates the mean, median, value, standard deviation, minimum, maximum, lower quartile, and upper quartile for each color channel in the histogram and returns a statistics object. You can also use histogram.statistics() and histogram.get_stats() as aliases for this method. Percentile Class – Percentage Value Object The percentage value object is returned by histogram.get_percentile. The grayscale value has one channel. Do not use the l* , a , or b_ methods. The RGB565 percentage value has three channels. Use the l* , a , and b_ methods. Constructor Class image.percentile Call the histogram.get_percentile() function to create this object. Methods percentile.value() Returns the grayscale percentage value (value range 0-255). You can also get this value via index [0]. percentile.l_value() Returns the percentage value of the L channel of the RGB565 LAB (value range is 0-100). You can also get this value via index [0]. percentile.a_value() Returns the percentage value of the A channel of the RGB565 LAB (value range -128-127). You can also get this value via index [1]. percentile.b_value() Returns the percentage value of the B channel of the RGB565 LAB (value range -128-127). You can also get this value via index [2]. Threhsold Class – Threshold Object The threshold object is returned by histogram.get_threshold. The grayscale image has a channel. There are no l*, a, and b_ methods. The RGB565 threshold has three channels. Use the l*, a, and b_ methods. Constructor Class image.threshold Call the histogram.get_threshold() function to create this object. Methods threhsold.value() Returns the threshold of the grayscale image (between 0 and 255). You can also get this value via index [0]. threhsold.l_value() Returns the L threshold in RGB565 map LAB (between 0 and 100). You can also get this value via index [0]. threhsold.a_value() Returns the A threshold in the RGB565 graph LAB (between -128 and 127). You can also get this value via index [1]. threhsold.b_value() Returns the B threshold in RGB565 map LAB (between -128 and 127). You can also get this value via index [2]. class Statistics – Statistics Object The statistics object is returned by histogram.get_statistics or image.get_statistics. Grayscale statistics have one channel, using non-l*, a, or b_ methods. The RGB565 percentage value has three channels. Use the l* , a , and b_ methods. Constructor Class image.statistics Call the histogram.get_statistics() or image.get_statistics() function to create this object. Methods statistics.mean() Returns the grayscale mean (0-255) (int). You can also get this value via index [0]. statistics.median() Returns the gray value median (0-255) (int). You can also get this value via index [1]. statistics.mode() Returns the gray level value (0-255) (int). You can also get this value via index [2]. statistics.stdev() Returns the gray standard deviation (0-255) (int). You can also get this value via index [3]. statistics.min() Returns the minimum gray level (0-255) (int). You can also get this value via index [4]. statistics.max() Returns the grayscale maximum (0-255) (int). You can also get this value via index [5]. statistics.lq() Returns the quarter value (0-255) (int) under gray. You can also get this value via index [6]. statistics.uq() Returns the grayscale upper quartile (0-255) (int). You can also get this value via index [7]. statistics.l_mean() Returns the mean (0-255) (int) of L in RGB5656 LAB. You can also get this value via index [0]. statistics.l_median() Returns the median (0-255) (int) of L in RGB5656 LAB. You can also get this value via index [1]. statistics.l_mode() Returns the value of L (0-255) (int) in RGB5656 LAB. You can also get this value via index [2]. statistics.l_stdev() Returns the standard deviation value (0-255) (int) of L in RGB5656 LAB. You can also get this value via index [3]. statistics.l_min() Returns the minimum value (0-255) (int) of L in RGB5656 LAB. You can also get this value via index [4]. statistics.l_max() Returns the maximum value (0-255) (int) of L in RGB5656 LAB. You can also get this value via index [5]. statistics.l_lq() Returns the lower quartile (0-255) (int) of L in RGB5656 LAB. You can also get this value via index [6]. statistics.l_uq() Returns the upper quartile (0-255) (int) of L in RGB5656 LAB. You can also get this value via index [7]. statistics.a_mean() Returns the mean (0-255) (int) of A in RGB5656 LAB. You can also get this value via index [8]. statistics.a_median() Returns the median (0-255) (int) of A in RGB5656 LAB. You can also get this value via index [9]. statistics.a_mode() Returns the value of A (0-255) (int) in RGB5656 LAB. You can also get this value via index [10]. statistics.a_stdev() Returns the standard deviation value (0-255) (int) of A in RGB5656 LAB. You can also get this value via index [11]. statistics.a_min() Returns the minimum value (0-255) (int) of A in RGB5656 LAB. You can also get this value via index [12]. statistics.a_max() Returns the maximum value (0-255) (int) of A in RGB5656 LAB. You can also get this value via index [13]. statistics.a_lq() Returns the lower quartile (0-255) (int) of A in RGB5656 LAB. You can also get this value via index [14]. statistics.a_uq() Returns the upper quartile (0-255) (int) of A in RGB5656 LAB. You can also get this value via index [15]. statistics.b_mean() Returns the mean (0-255) (int) of B in RGB5656 LAB. You can also get this value via index [16]. statistics.b_median() Returns the median (0-255) (int) of B in RGB5656 LAB. You can also get this value via index [17]. statistics.b_mode() Returns the value of B (0-255) (int) in RGB5656 LAB. You can also get this value via index [18]. statistics.b_stdev() Returns the standard deviation (0-255) (int) of B in RGB5656 LAB. You can also get this value via index [19]. statistics.b_min() Returns the minimum value (0-255) (int) of B in RGB5656 LAB. You can also get this value via index [20]. statistics.b_max() Returns the maximum value (0-255) (int) of B in RGB5656 LAB. You can also get this value via index [21]. statistics.b_lq() Returns the lower quartile (0-255) (int) of B in RGB5656 LAB. You can also get this value via index [22]. statistics.b_uq() Returns the upper quartile (0-255) (int) of B in RGB5656 LAB. You can also get this value via index [23]. Blob class – color block object The patch object is returned by image.find_blobs. Constructor Class image.blob Call the image.find_blobs() function to create this object. Methods blob.rect() Returns a rectangular tuple (x, y, w, h) for other image methods such as image.draw_rectangle of the color block bounding box. blob.x() Returns the x coordinate (int) of the bounding box of the patch. You can also get this value via index [0]. blob.y() Returns the y coordinate (int) of the bounding box of the patch. You can also get this value via index [1]. blob.w() Returns the w coordinate (int) of the bounding box of the patch. You can also get this value via index [2]. blob.h() Returns the h coordinate (int) of the bounding box of the patch. You can also get this value via index [3]. blob.pixels() Returns the number of pixels subordinate to a part of the int. You can also get this value via index [4]. blob.cx() Returns the center x position of the color block (int). You can also get this value via index [5]. blob.cy() Returns the center x position of the color block (int). You can also get this value via index [6]. blob.rotation() Returns the rotation of the patch (in radians). If the color block is similar to a pencil or pen, then this value is a unique value between 0-180. If the color block is round, then this value has no effect. If this color block is completely symmetrical, you can only get a 0-360 degree rotation. You can also get this value via index [7]. blob.code() Returns a 16-bit binary number with one bit set for each color threshold, which is part of the color block. For example, if you look for three color thresholds via image.find_blobs, this color block can be set to 0/1/2 digits. Note: You can only set one bit per color block unless you call image.find_blobs with merge=True . Then multiple color patches with different color thresholds can be merged together. You can also use this method and multiple thresholds to implement color code tracking. You can also get this value via index [8]. blob.count() Returns the number of multiple patches that are merged into this patch. This number is not 1 only if you call image.find_blobs with merge=True. You can also get this value via index [9]. blob.area() Returns the border area around the patch (w * h) blob.density() Returns the density ratio of this patch. This is the number of pixels in the bounding box area of ​​the patch. In general, a lower density ratio means that the object is not locked well. Line Class – Straight Line Object Line objects are returned by image.find_lines , image.find_line_segments or image.get_regression. Constructor Class image.line Call the image.find_lines(), image.find_line_segments(), or image.get_regression() function to create this object. Methods line.line() Returns a line tuple (x1, y1, x2, y2) for use with other image methods such as image.draw_line . line.x1() Returns the p1 vertex x coordinate component of the line. You can also get this value via index [0]. line.y1() Returns the p1 y component of the line. You can also get this value via index [1]. line.x2() Returns the p2 x component of the line. You can also get this value via index [2]. line.y2() Returns the p2 y component of the line. You can also get this value via index [3]. line.length() Returns the length of the line ie sqrt(((x2-x1)^2) + ((y2-y1)^2). You can also get this value via index [4]. line.magnitude() Returns the length of the line after the Hough transform. You can also get this value via index [5]. line.theta() Returns the angle of the line after the Hough transform (0-179 degrees). You can also get this value via index [7]. line.rho() Returns the p value of the line after the Hough transform. You can also get this value via index [8]. CircleClass - Round Object The circular object is returned by image.find_circles. Constructor Class image.circle Call the image.find_circles() function to create this object. Methods circle.x() Returns the x position of the circle. You can also get this value via index [0]. circle.y() Returns the y position of the circle. You can also get this value via index [1]. circle.r() Returns the radius of the circle. You can also get this value via index [2]. circle.magnitude() Returns the size of the circle. You can also get this value via index [3]. Rect class – rectangular object The rectangle object is returned by image.find_rects. Constructor Class image.rect Call the image.find_rects() function to create this object. Methods rect.corners() Returns a list of four tuples (x, y) consisting of the four corners of a rectangular object. The four corners are usually returned in a clockwise order starting from the upper left corner. rect.rect() Returns a rectangular tuple (x, y, w, h) for other image methods such as image.draw_rectangle of the bounding box of the rectangle. rect.x() Returns the x position of the top left corner of the rectangle. You can also get this value via index [0]. rect.y() Returns the y position of the top left corner of the rectangle. You can also get this value via index [1]. rect.w() Returns the width of the rectangle. You can also get this value via index [2]. rect.h() Returns the height of the rectangle. You can also get this value via index [3]. rect.magnitude() Returns the size of the rectangle. You can also get this value via index [4]. QRCode Class – QR Code Object The QR code object is returned by image.find_qrcodes. Constructor Class image.qrcode Call the image.find_qrcodes() function to create this object. Methods qrcode.corners() Returns a list of four tuples (x, y) consisting of the four corners of the object. The four corners are usually returned in a clockwise order starting from the upper left corner. qrcode.rect() Returns a rectangular tuple (x, y, w, h) for other image methods such as image.draw_rectangle of the bounding box of the QR code. qrcode.x() Returns the x coordinate (int) of the bounding box of the QR code. You can also get this value via index [0]. qrcode.y() Returns the y coordinate (int) of the bounding box of the QR code. You can also get this value via index [1]. qrcode.w() Returns the w coordinate (int) of the bounding box of the QR code. You can also get this value via index [2]. qrcode.h() Returns the h coordinate (int) of the bounding box of the QR code. You can also get this value via index [3]. qrcode.payload() Returns a string of the QR code payload, such as a URL. You can also get this value via index [4]. qrcode.version() Returns the version number (int) of the QR code. You can also get this value via index [5]. qrcode.ecc_level() Returns the ECC level (int) of the QR code. You can also get this value via index [6]. qrcode.mask() Returns the mask (int) of the QR code. You can also get this value via index [7]. qrcode.data_type() Returns the data type of the QR code. You can also get this value via index [8]. qrcode.eci() Returns the ECI of the QR code. The ECI stores the code for storing the data bytes in the QR code. If you want to process a QR code that contains more than standard ASCII text, you need to look at this value. You can also get this value via index [9]. qrcode.is_numeric() Returns True if the data type of the QR code is numeric. qrcode.is_alphanumeric() Returns True if the data type of the QR code is alphanumeric. qrcode.is_binary() Returns True if the data type of the QR code is binary. If you are dealing with all types of text carefully, you need to check if eci is True to determine the text encoding of the data. Usually it's just standard ASCII, but it could also be UTF8 with two byte characters. qrcode.is_kanji() Returns True if the data type of the QR code is Japanese Kanji. When set to True, you need to decode the string yourself, because the Japanese character is 10 digits per character, and MicroPython does not support parsing such text. AprilTag Class – AprilTag object The AprilTag object is returned by image.find_apriltags. Constructor Class image.apriltag Call the image.find_apriltags() function to create this object. Methods apriltag.corners() Returns a list of four tuples (x, y) consisting of the four corners of the object. The four corners are usually returned in a clockwise order starting from the upper left corner. apriltag.rect() Returns a rectangular tuple (x, y, w, h) for other image methods such as image.draw_rectangle of the AprilTag bounding box. apriltag.x() Returns the x coordinate (int) of the AprilTag bounding box. You can also get this value via index [0]. apriltag.y() Returns the y coordinate (int) of the AprilTag bounding box. You can also get this value via index [1]. apriltag.w() Returns the w coordinate (int) of the AprilTag bounding box. You can also get this value via index [2]. apriltag.h() Returns the h coordinate (int) of the AprilTag bounding box. You can also get this value via index [3]. apriltag.id() Returns the numeric ID of the AprilTag. TAG16H5 -> 0 to 29 TAG25H7 -> 0 to 241 TAG25H9 -> 0 to 34 TAG36H10 -> 0 to 2319 TAG36H11 -> 0 to 586 ARTOOLKIT -> 0 to 511 You can also get this value via index [4]. apriltag.family() Return to the digital family of AprilTag. image.TAG16H5 image.TAG25H7 image.TAG25H9 image.TAG36H10 image.TAG36H11 image.ARTOOLKIT You can also get this value via index [5]. apriltag.cx() Returns the center x position (int) of the AprilTag. You can also get this value via index [6]. apriltag.cy() Returns the center y position (int) of the AprilTag. You can also get this value via index [7]. apriltag.rotation() Returns the curl (int) of the AprilTag in radians. You can also get this value via index [8]. apriltag.decision_margin() Returns the color saturation of the AprilTag match (values ​​0.0 - 1.0), where 1.0 is optimal. You can also get this value via index [9]. apriltag.hamming() Returns the acceptable digit error value for the AprilTag. TAG16H5 -> accepts up to 0 bit errors TAG25H7 -> accepts up to 1 bit error TAG25H9 -> accepts up to 3 bit errors TAG36H10 -> accepts up to 3 bit errors TAG36H11 -> accepts up to 4 errors ARTOOLKIT -> accepts up to 0 bit errors You can also get this value via index [10]. apriltag.goodness() Returns the color saturation of the AprilTag image (value 0.0 - 1.0), where 1.0 is optimal. Currently this value is usually 0.0. In the future, we can enable a feature called \"tag refinement\" to achieve detection of smaller AprilTag. However, this feature now reduces the frame rate below 1 FPS. You can also get this value via index [11]. apriltag.x_translation() Returns the transformation from the x direction of the camera. The unit of distance is unknown. This method is useful for determining the position of the AprilTag away from the camera. However, the size of the AprilTag and the factors you use will affect the determination of the X unit ownership. For ease of use, we recommend that you use a lookup table to convert the output of this method into information that is useful to your application. Note: The direction here is from left to right. You can also get this value via index [12]. apriltag.y_translation() Returns the transformation from the y direction of the camera, the unit of distance is unknown. This method is useful for determining the position of the AprilTag away from the camera. However, the size of the AprilTag and the factors you use will affect the determination of the Y unit ownership. For ease of use, we recommend that you use a lookup table to convert the output of this method into information that is useful to your application. Note: The direction here is from top to bottom. You can also get this value via index [13]. apriltag.z_translation() Returns the transformation from the camera's z direction, the unit of distance is unknown. This method is useful for determining the position of the AprilTag away from the camera. However, factors such as the size of the AprilTag and the lens you are using will affect the determination of the Z-unit attribution. For ease of use, we recommend that you use a lookup table to convert the output of this method into information that is useful to your application. Note: The direction here is from front to back. You can also get this value via index [14]. apriltag.x_rotation() Returns the curl of the AprilTag in radians on the X plane. Example: Visually see the AprilTag and move the camera from left to right. You can also get this value via index [15]. apriltag.y_rotation() Returns the curl of the AprilTag in radians on the Y plane. Example: Visualize the AprilTag and move the camera from top to bottom. You can also get this value via index [16]. apriltag.z_rotation() Returns the curl of the AprilTag in radians on the Z plane. Example: Visualize the AprilTag and rotate the camera. Note: This is just a renamed version of apriltag.rotation(). You can also get this value via index [17]. DataMatrix Class – Data Matrix Object The data matrix object is returned by image.find_datamatrices. Constructor Class image.datamatrix Call the image.find_datamatrices() function to create this object. Methods datamatrix.corners() Returns a list of four tuples (x, y) consisting of the four corners of the object. The four corners are usually returned in a clockwise order starting from the upper left corner. datamatrix.rect() Returns a rectangular tuple (x, y, w, h) for other image methods such as image.draw_rectangle of the bounding box of the data matrix. datamatrix.x() Returns the x coordinate (int) of the bounding box of the data matrix. You can also get this value via index [0]. datamatrix.y() Returns the y coordinate (int) of the bounding box of the data matrix. You can also get this value via index [1]. datamatrix.w() Returns the w width of the bounding box of the data matrix. You can also get this value via index [2]. datamatrix.h() Returns the h height of the bounding box of the data matrix. You can also get this value via index [3]. datamatrix.payload() Returns a string of payloads for the data matrix. Example: String. You can also get this value via index [4]. datamatrix.rotation() Returns the curl (float) of the data matrix in radians. You can also get this value via index [5]. datamatrix.rows() Returns the number of rows (int) of the data matrix. You can also get this value via index [6]. datamatrix.columns() Returns the number of columns (int) of the data matrix. You can also get this value via index [7]. datamatrix.capacity() Returns the number of characters this data matrix can hold. You can also get this value via index [8]. datamatrix.padding() Returns the number of unused characters in this data matrix. You can also get this value via index [9]. BarCode Class – Barcode Object The barcode object is returned by image.find_barcodes. Constructor Class image.barcode Call the image.find_barcodes() function to create this object. Methods barcode.corners() Returns a list of four tuples (x, y) consisting of the four corners of the object. The four corners are usually returned in a clockwise order starting from the upper left corner. barcode.rect() Returns a rectangular tuple (x, y, w, h) for other image methods such as image.draw_rectangle of the bounding box of the data matrix. barcode.x() Returns the x coordinate (int) of the bounding box of the barcode. You can also get this value via index [0]. barcode.y() Returns the y coordinate (int) of the bounding box of the barcode. You can also get this value via index [1]. barcode.w() Returns the w width (int) of the bounding box of the barcode. You can also get this value via index [2]. barcode.h() Returns the h height (int) of the bounding box of the barcode. You can also get this value via index [3]. barcode.payload() Returns a string of the payload of the barcode. Example: Quantity. You can also get this value via index [4]. barcode.type() Returns the enumerated type (int) of the barcode. You can also get this value via index [5]. image.EAN2 image.EAN5 image.EAN8 image.UPCE image.ISBN10 image.UPCA image.EAN13 image.ISBN13 image.I25 image.DATABAR image.DATABAR_EXP image.CODABAR image.CODE39 image.PDF417 - Enable in the future (e.g. is not working properly now). image.CODE93 image.CODE128 barcode.rotation() Returns the curl (floating point) of the barcode in radians. You can also get this value via index [6]. barcode.quality() Returns the number of times the barcode was detected in the image (int). When scanning a barcode, each new scan line can decode the same barcode. Each time this process is performed, the value of the barcode will increase. You can also get this value via index [7]. Displacement class – displacement object The displacement object is returned by image.find_displacement. Constructor Class image.displacement Call the image.find_displacement() function to create this object. Methods displacement.x_translation() Returns an x ​​translation pixel between two images. This is a precise subpixel, so it is a floating point number. You can also get this value via index [0]. displacement.y_translation() Returns the y translation pixel between the two images. This is a precise subpixel, so it is a floating point number. You can also get this value via index [1]. displacement.rotation() Returns the z translation pixel between the two images. This is a precise subpixel, so it is a floating point number. You can also get this value via index [2]. displacement.scale() Returns the arc of rotation between two images. You can also get this value via index [3]. displacement.response() Returns the quality of the displacement match between the two images. Range 0-1. A displacement object with a response of less than 0.1 may be noise. You can also get this value via index [4]. Kptmatch class – feature point object The feature point object is returned by image.match_descriptor. Constructor Class image.kptmatch Please call the image.match_descriptor() function to create this object. Methods kptmatch.rect() Returns a rectangular tuple (x, y, w, h) for other image methods such as image.draw_rectangle of the bounding box of the feature point. kptmatch.cx() Returns the center x position (int) of the feature point. You can also get this value via index [0]. kptmatch.cy() Returns the center y position (int) of the feature point. You can also get this value via index [1]. kptmatch.x() Returns the x coordinate (int) of the bounding box of the feature point. You can also get this value via index [2]. kptmatch.y() Returns the y coordinate (int) of the bounding box of the feature point. You can also get this value via index [3]. kptmatch.w() Returns the w width (int) of the feature point bounding box. You can also get this value via index [4]. kptmatch.h() Returns the h height (int) of the feature point bounding box. You can also get this value via index [5]. kptmatch.count() Returns the number of matching feature points (int). You can also get this value via index [6]. kptmatch.theta() Returns the curl of the estimated feature point (int). You can also get this value via index [7]. kptmatch.match() Returns a list of (x,y) tuples that match the key. You can also get this value via index [8]. ImageWriterClass – ImageWriter Object The ImageWriter object allows you to quickly write uncompressed images to disk. Constructor Class image.ImageWriter(path) Create an ImageWriter object and you can write uncompressed images to disk in a simple file format for OpenMV Cams. The uncompressed image can then be re-read using ImageReader. Methods imagewriter.size() Returns the size of the file being written. imagewriter.add_frame(img) Write an image to disk. Because the image is not compressed, it performs quickly but takes up a lot of disk space. imagewriter.close() Close the image stream file. You must close the file or the file will be corrupted. ImageReader Class – ImageReader Object The ImageReader object allows you to quickly read uncompressed images from disk. Constructor Class image.ImageReader(path) Create an ImageReader object to play back the image data written by the ImageWriter object. Frames played back by the ImageWriter object are played back under the same FPS as when writing to disk. Methods imagereader.size() Returns the size of the file being read. Imagereader.next_frame([copy_to_fb=True, loop=True]) Returns an image object from a file written by ImageWriter. If copy_to_fb is True, the image object will be loaded directly into the frame buffer. Otherwise the image object will be placed in the heap. Note: Unless the image is small, the heap may not have enough space to store the image object. If loop is True, playback will resume after the last image of the stream has been read. Otherwise, this method will return None after all frames have been read. Note: imagereader.next_frame attempts to limit the playback speed by pausing playback after reading the frame to match the speed of the frame recording. Otherwise, this method will play all images at a speed of 200+FPS. imagereader.close() Close the file being read. You need to do this to prevent the imagereader object from being damaged. However, since it is a read-only file, the file will not be damaged when it is not closed. ImageClass - Image Object Image objects are the basic objects of machine vision operations. Constructor Class image.Image(path[, copy_to_fb=False]) Create a new image object from the file in path. Support image files in bmp/pgm/ppm/jpg/jpeg format. If copy_to_fb is True, the image will be loaded directly into the framebuffer and you can load large images. If False, the image will be loaded into the MicroPython heap, which is much smaller than the frame buffer. In OpenMV Cam M4, if copy_to_fb is False, you should try to keep the image size below 8KB. If True, the image can be up to 160KB. In OpenMV Cam M7, if copy_to_fb is False, you should try to keep the image size below 16KB. If True, the image can be up to 320KB. The image supports the \"[]\" notation. Let image[index] = 8/16-bit value to assign image pixels or image[index] and get an image pixel. If it is a grayscale image of 16-bit RGB565 value for RGB image, this pixel is 8 Bit. For JPEG images, \"[]\" gives you access to JPEG image patches in the form of compressed section arrays. Since JPEG images are in the form of compressed byte streams, reading and writing of data sets is opaque. The image also supports read buffer operations. You can use the image as a section array object and enter the image into all types of MicroPython functions. If you want to transfer an image, you can pass it to the UART / SPI / I2C write function for automatic transfer. Methods image.width() Returns the width of the image in pixels. image.height() Returns the height of the image in pixels. image.format() Returns sensor.GRAYSCALE for grayscale images, sensor.RGB565 for RGB images, and sensor.JPEG for JPEG images. image.size() Returns the image size in bytes. image.get_pixel(x, y[, rgbtuple]) Grayscale: Returns the grayscale pixel value at the (x, y) position. RGB565l: Returns the RGB888 pixel tuple (r, g, b) at the (x, y) position. Bayer image: Returns the pixel value at the (x, y) position. Compressed images are not supported. image.get_pixel() and image.set_pixel() are the only ways you can manipulate Bayer mode images. The Bayer pattern image is a text image. For even rows, where the pixels in the image are R/G/R/G/ and so on. For odd lines, where the pixels in the image are G/B/G/B/etc. Each pixel is 8 bits. image.set_pixel(x, y, pixel) Grayscale: Set the pixel at the (x, y) position to the grayscale value pixel . RGB image: Set the pixel at the (x, y) position to RGB888 tuple (r, g, b) pixel . Compressed images are not supported. image.get_pixel() and image.set_pixel() are the only ways you can manipulate Bayer mode images. The Bayer pattern image is a text image. For even rows, where the pixels in the image are R/G/R/G/ and so on. For odd lines, where the pixels in the image are G/B/G/B/etc. Each pixel is 8 bits. image.mean_pool(x_div, y_div) Find the average of the x_div * y_div squares in the image and return a modified image consisting of the average of each square. This method allows you to quickly reduce the image on the original image. Compressed images and bayer images are not supported. image.mean_pooled(x_div, y_div) Find the average of the x_div * y_div squares in the image and return a new image consisting of the average of each square. This method allows you to create a reduced copy of the image. Compressed images and bayer images are not supported. image.midpoint_pool(x_div, y_div[, bias=0.5]) Finds the midpoint value of the x_div * y_div square in the image and returns a modified image consisting of the midpoint values ​​of each square. Bias is 0.0 to return the minimum value for each region, and bias is 1.0 to return the maximum value for each region. This method allows you to quickly reduce the image on the original image. Compressed images and bayer images are not supported. image.midpoint_pooled(x_div, y_div[, bias=0.5]) Finds the midpoint value of the x_div * y_div square in the image and returns a new image consisting of the midpoint values ​​of each square. Bias is 0.0 to return the minimum value for each region, and bias is 1.0 to return the maximum value for each region. This method allows you to create a reduced copy of the image. Compressed images and bayer images are not supported. image.to_grayscale([copy=False]) Convert the image to a grayscale image. This method also modifies the base image pixels and changes the image size in bytes, so it can only be done on grayscale images or RGB565 images. Otherwise copy must be True to create a new modified image on the heap. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.to_rgb565([copy=False]) Convert an image to a color image. This method also modifies the base image pixels and changes the image size in bytes, so it can only be done on RGB565 images. Otherwise copy must be True to create a new modified image on the heap. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.to_rainbow([copy=False]) Convert an image to a rainbow image. This method also modifies the base image pixels and changes the image size in bytes, so it can only be done on RGB565 images. Otherwise copy must be True to create a new modified image on the heap. A rainbow image is a color image that has a unique color value for each 8-bit mask grayscale illumination value in the image. For example, it provides a heat map color for a thermal image. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.compress([quality=50]) JPEG properly compresses the image. Using this method to use a higher quality compression ratio is at the expense of destroying the original image compared to the compressed save heap space. Quality is the compression quality (0-100) (int). image.compress_for_ide([quality=50]) JPEG properly compresses the image. Using this method to use a higher quality compression ratio is at the expense of destroying the original image compared to the compressed save heap space. This method compresses the image and then formats the JPEG data by encoding each 6 bits into a byte between 128 and 191 and converts it to OpenMV IDE for display. This step is done to prevent JPEG data from being mistaken for other text data in the byte stream. You need to use this method to format the image data for display in the terminal window created by Open Terminal in OpenMV IDE. Quality is the compression quality (0-100) (int). image.compressed([quality=50]) Returns a JPEG compressed image - the original image is unprocessed. However, this method requires a large allocation of heap space, so image compression quality and image resolution must be low. Quality is the compression quality (0-100) (int). image.compressed_for_ide([quality=50]) Returns a JPEG compressed image - the original image is unprocessed. However, this method requires a large allocation of heap space, so image compression quality and image resolution must be low. This method compresses the image and then formats the JPEG data by encoding each 6 bits into a byte between 128 and 191 and converts it to OpenMV IDE for display. This step is done to prevent JPEG data from being mistaken for other text data in the byte stream. You need to use this method to format the image data for display in the terminal window created by Open Terminal in OpenMV IDE. Quality is the compression quality (0-100) (int). image.copy([roi[, copy_to_fb=False]]) Create a copy of the image object. Roi is a region of interest (x, y, w, h) of a rectangle to be copied. If not specified, the ROI copies the image rectangle of the entire image. But this does not apply to JPEG images. Remember that the image copy is stored in the MicroPython heap instead of the frame buffer. Again, you need to keep the image copy size below 8KB (OpenMV) or below 16KB (OpenMV Cam M7). If you want to use a copy operation to use all the heap space, this function will get an exception. An oversized image can easily trigger an exception. If copy_to_fb is True, this method replaces the framebuffer with an image. The frame buffer has much larger space than the heap and can accommodate large images. image.save(path[, roi[, quality=50]]) Save a copy of the image to the file system in path. Support image files in bmp/pgm/ppm/jpg/jpeg format. Note: You cannot save a compressed image in jpeg format to an uncompressed format. Roi is a region of interest (x, y, w, h) of a rectangle to be copied. If not specified, the ROI copies the image rectangle of the entire image. But this does not apply to JPEG images. Quality refers to the JPEG compression quality that saves the image to JPEG format when the image has not been compressed. image.clear() Set all pixels in the image to zero (very fast). Returns an image object so that you can use the . notation to call another method. Compressed images are not supported. image.draw_line(x0, y0, x1, y1[, color[, thickness=1]]) Draw a line from (x0, y0) to (x1, y1) on the image. You can pass x0, y0, x1, y1 individually or to a tuple (x0, y0, x1, y1). Color is the RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the base pixel value of the grayscale image (0-255) or the byte of the RGB565 image to invert the RGB565 value. Thickness The thickness of the control line. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.draw_rectangle(x, y, w, h[, color[, thickness=1[, fill=False]]]) Draw a rectangle on the image. You can pass x, y, w, h alone or as a tuple (x, y, w, h). Color is the RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the base pixel value of the grayscale image (0-255) or the byte of the RGB565 image to invert the RGB565 value. Thickness The thickness of the control line. Set fill to True to fill the rectangle. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.draw_circle(x, y, radius[, color[, thickness=1[, fill=False]]]) Draw a circle on the image. You can pass x, y, radius alone or as a tuple (x, y, radius). Color is the RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the base pixel value of the grayscale image (0-255) or the byte of the RGB565 image to invert the RGB565 value. Thickness The thickness of the control line. Set fill to True to fill the circle. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.draw_string(x, y, text[, color[, scale=1[, x_spacing=0[, y_spacing=0[, mono_space=True]]]]) Draw 8x10 text from the (x, y) position in the image. You can pass x, y alone or as a tuple (x, y). Text is a string that is written to the image. The \\n, \\r, and \\r\\n terminators move the cursor to the next line. Color is the RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the base pixel value of the grayscale image (0-255) or the byte of the RGB565 image to invert the RGB565 value. You can increase the scale to increase the size of the text on the image. Only integer values ​​(for example, 1/2/3 / etc). X_spacing allows you to add (if positive) or subtract (if negative) x pixels between characters to set the character spacing. Y_spacing allows you to add (if positive) or subtract (if negative) y pixels between characters to set the line spacing. Mono_space defaults to True, which forces the text spacing to be fixed. For big text, this looks bad. Setting False to get a non-fixed width of character spacing looks much better. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.draw_cross(x, y[, color[, size=5[, thickness=1]]]) Draw a cross on the image. You can pass x, y alone or as a tuple (x, y). Color is the RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the base pixel value of the grayscale image (0-255) or the byte of the RGB565 image to invert the RGB565 value. Size Controls the extension of the crosshair. Thickness Controls the pixel thickness of the edge. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.draw_arrow(x0, y0, x1, y1[, color[, thickness=1]]) Draw an arrow from (x0, y0) to (x1, y1) on the image. You can pass x0, y0, x1, y1 individually or to a tuple (x0, y0, x1, y1). Color is the RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the base pixel value of the grayscale image (0-255) or the byte of the RGB565 image to invert the RGB565 value. Thickness The thickness of the control line. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.draw_image(image, x, y[, x_scale=1.0[, y_scale=1.0[, mask=None]]]) Draw an image whose top left corner starts at position x, y. You can pass x, y alone or pass it to a tuple (x, y). X_scale Controls the extent to which the image is scaled in the x direction (floating point). Y_scale Controls the extent to which the image is scaled in the y direction (floating point). Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. You can use the mask mask to draw. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.draw_keypoints(keypoints[, color[, size=10[, thickness=1[, fill=False]]]]) Draw a point of a feature point object on the image. Color is the RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the base pixel value of the grayscale image (0-255) or the byte of the RGB565 image to invert the RGB565 value. Size Controls the size of feature points. Thickness The thickness of the control line. Set fill to True to fill the feature points. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.flood_fill(x, y[, seed_threshold=0.05[, floating_threshold=0.05[, color[, invert=False[, clear_background=False[, mask=None]]]]]) The area where the image is filled starting from position x, y. You can pass x, y alone or pass it to a tuple (x, y). Seed_threshold Controls the difference between the pixels in the fill area and the original start pixel. Floating_threshold Controls the difference between pixels in the fill area and any adjacent pixels. Color is the RGB888 tuple for grayscale or RGB565 images. The default is white. However, you can also pass the base pixel value of the grayscale image (0-255) or the byte of the RGB565 image to invert the RGB565 value. Pass invert to True to repopulate everything outside the flood_fill connection area. Pass clear_background as True and zero the remaining flood_fill pixels that are not recolored. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask will be evaluated at flood_fill. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.binary(thresholds[, invert=False[, zero=False[, mask=None]]]) Sets all pixels in the image to black or white depending on whether the pixel is within the threshold in the threshold list thresholds. The thresholds must be a list of tuples. [(lo, hi), (lo, hi), ..., (lo, hi)] Define the range of colors you want to track. For grayscale images, each tuple needs to contain two values ​​- the minimum gray value and the maximum gray value. Only pixel regions that fall between these thresholds are considered. For RGB565 images, each tuple needs to have six values ​​(l_lo, l_hi, a_lo, a_hi, b_lo, b_hi) - the minimum and maximum values ​​for the LAB L, A and B channels, respectively. For ease of use, this feature will automatically fix the minimum and maximum values ​​of the exchange. Also, if the tuple is greater than six values, the remaining values ​​are ignored. Conversely, if the tuple is too short, the remaining thresholds are assumed to be in the maximum range. annotation To get the threshold of the tracked object, simply select (click and drag) the tracking object in the IDE framebuffer. The histogram will be updated accordingly to the area. Then just write down the color distribution in the starting and falling positions in each histogram channel. These will be the low and high values ​​of thresholds. Since the difference between the upper and lower quartiles is small, the threshold is manually determined. You can also determine the color threshold by going to Tools -> Machine Vision -> Threshold Editor in the OpenMV IDE and dragging the slider from the GUI window. Invert Reverses the threshold operation, where pixels are matched outside of the known color range, not within the known color range. Set zero to True to make the threshold pixel zero and leave the pixels that are not in the threshold list unchanged. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.invert() Change binary image 0 (black) to 1 (white) and 1 (white) to 0 (black) to flip all pixel values ​​in the binary image very quickly. Returns an image object so that you can use the . notation to call another method. Compressed images and Bayer images are not supported. image.b_and(image[, mask=None]) Use another image to perform a logical AND operation with this image. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.b_nand(image[, mask=None]) Use another image to perform a logical AND operation with this image. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.b_or(image[, mask=None]) Use another image to perform a logical OR operation with this image. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.b_nor(image[, mask=None]) Use another image to perform a logical OR operation with this image. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.b_xor(image[, mask=None]) Use another image to perform an exclusive OR operation with this image. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.b_xnor(image[, mask=None]) Use another image to logically AND the same image. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.erode(size[, threshold[, mask=None]]) Remove pixels from the edges of the split area. This method is implemented by convolving the kernel of ((size2)+1)x((size2)+1) pixels on the convolution image. If the sum of the adjacent pixel sets is smaller than threshold, then the center pixel of the kernel is performed. Return to zero. If the threshold is not set, this method functions as the standard corrosion method. If the threshold is set, you can specify a specific pixel to be etched. For example, set a threshold of 2 around pixels that are less than 2 pixels. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.dilate(size[, threshold[, mask=None]]) Add pixels to the edges of the split area. This method is implemented by convolving the kernel of ((size2)+1)x((size2)+1) pixels on the convolution image. If the sum of the adjacent pixel sets is greater than threshold, the central pixel of the kernel is performed. Settings. If the threshold is not set, this method functions as the standard corrosion method. If the threshold is set, you can specify a specific pixel to be etched. For example, set a threshold of 2 around pixels that are less than 2 pixels. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.open(size[, threshold[, mask=None]]) The image is subjected to corrosion and expansion in sequence. See image.erode() and image.dilate() for more information. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.close(size[, threshold[, mask=None]]) The image is expanded and etched in sequence. See image.erode() and image.dilate() for more information. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.top_hat(size[, threshold[, mask=None]]) Returns the difference between the original image and the image after executing the image.open() function. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Compressed images and bayer images are not supported. image.black_hat(size[, threshold[, mask=None]]) Returns the difference between the original image and the image after executing the image.close() function. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Compressed images and bayer images are not supported. image.negate() Flip (number invert) all pixel values ​​in the image very quickly. The value of the pixel value of each color channel is converted. Example: (255 - pixel). Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.replace(image[, hmirror=False[, vflip=False[, mask=None]]]) Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Set hmirror to True to replace the image with a horizontal mirror. Set vflip to True to replace the image with a vertical flip. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.add(image[, mask=None]) Add two images to each other in pixels. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.sub(image[, reverse=False[, mask=None]]) The two images are subtracted from each other by pixel. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Set reverse to True to reverse the subtraction from this_image-image to image-this_image . Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.mul(image[, invert=False[, mask=None]]) Multiply two images by pixel by pixel. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Setting invert to True changes the multiplication operation from ab to 1/((1/a)(1/b)). In particular, this brightens the image rather than darkening the image (eg, multiply and burn operations). Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.div(image[, invert=False[, mask=None]]) Divide this image by another image. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Set invert to True to change the division direction from a/b to b/a. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.min(image[, mask=None]) At the pixel level, replace the pixels in this image with the smallest pixel value between this image and another image. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. This method is not available on OpenMV4. image.max(image[, mask=None]) Replace pixels in this image at the pixel level with the maximum pixel value between this image and another image. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.difference(image[, mask=None]) The two images are taken to each other in absolute values. Example: For each color channel, replace each pixel with ABS (this.pixel-image.pixel). Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Mask is another image used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.blend(image[, alpha=128[, mask=None]]) Combine another image image with this image. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Alpha controls how much other images are to be blended into this image. alpha should be an integer value between 0 and 256. A value close to zero will mix more images into this image, and close to 256 is the opposite. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.histeq([adaptive=False[, clip_limit=-1[, mask=None]]]) Run a histogram equalization algorithm on the image. Histogram equalization normalizes contrast and brightness in the image. If adaptive passes to True, the adaptive histogram equalization method will be run on the image, which is usually better than the non-adaptive histogram qualification, but runs longer. Clip_limit provides a way to limit the contrast of adaptive histogram equalization. A good histogram equalization contrast limited image can be generated using a small value (eg 10). Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.mean(size, [threshold=False, [offset=0, [invert=False, [mask=None]]]]]) Standard mean blur filtering using a box filter. Size is the size of the kernel. Take 1 (3x3 core), 2 (5x5 core) or higher. If you want to adaptively set the threshold on the output of the filter, you can pass the threshold=True parameter to initiate adaptive threshold processing of the image, which is based on the brightness of the ambient pixel (the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. Median(size, percentile=0.5, threshold=False, offset=0, invert=False, mask]) Run median filtering on the image. Median filtering is the best filtering to smooth the surface, but at very slow speeds, while preserving the edges. Size is the size of the kernel. Take 1 (3x3 core), 2 (5x5 core) or higher. Percentile Controls the percentile of the values ​​used in the kernel. By default, each pixel is replaced with an adjacent fiftyth percentile (center). You can set this value to 0 when using minimum filtering, to 0.25 for lower quartile filtering, to 0.75 for upper quartile filtering, and to 1 for maximum filtering. If you want to adaptively set the threshold on the output of the filter, you can pass the threshold=True parameter to initiate adaptive threshold processing of the image, which is based on the brightness of the ambient pixel (the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.mode(size[, threshold=False, offset=0, invert=False, mask]) Run a majority filter on the image, replacing each pixel with the pattern of adjacent pixels. This method works well on grayscale images. However, due to the non-linear nature of this operation, many artifacts are produced on the edges of the RGB image. Size is the size of the kernel. Take 1 (3x3 core), 2 (5x5 core). If you want to adaptively set the threshold on the output of the filter, you can pass the threshold=True parameter to initiate adaptive threshold processing of the image, which is based on the brightness of the ambient pixel (the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.midpoint(size[, bias=0.5, threshold=False, offset=0, invert=False, mask]) Run midpoint filtering on the image. This filter finds the midpoint of the neighborhood of each pixel in the image ((max-min)/2). Size is the size of the kernel. Take 1 (3x3 core), 2 (5x5 core) or higher. Bias Controls the minimum/maximum degree of image blending. 0 is only for minimum filtering and 1 is for maximum filtering only. You can minimize/maximize filtering of images with bias. If you want to adaptively set the threshold on the output of the filter, you can pass the threshold=True parameter to initiate adaptive threshold processing of the image, which is based on the brightness of the ambient pixel (the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.morph(size, kernel, mul=Auto, add=0) The image is convolved through the filter kernel. This allows you to perform a general convolution on the image. Size Controls the size of the kernel to ((size2)+1)x((size2)+1) pixels. Kernel The kernel used to convolve the image, either as a tuple or as a list of values ​​[-128:127]. Mul is the number used to multiply the result of the convolutional pixel. If not set, it defaults to a value that will prevent scaling in the convolution output. Add is the number used to add the convolution result to each pixel. Mul can be used for global contrast adjustment, and add can be used for global brightness adjustment. If you want to adaptively set the threshold on the output of the filter, you can pass the threshold=True parameter to initiate adaptive threshold processing of the image, which is based on the brightness of the ambient pixel (the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. image.gaussian(size[, unsharp=False[, mul[, add=0[, threshold=False[, offset=0[, invert=False[, mask=None]]]]]]) The image is convolved by a smooth Gaussian kernel. Size is the size of the kernel. Take 1 (3x3 core), 2 (5x5 core) or higher. If unsharp is set to True, this method does not perform Gaussian filtering only, but performs an unsharp masking operation to improve the image sharpness of the edges. Mul is the number used to multiply the result of the convolutional pixel. If not set, it defaults to a value that will prevent scaling in the convolution output. Add is the number used to add the convolution result to each pixel. Mul can be used for global contrast adjustment, and add can be used for global brightness adjustment. If you want to adaptively set the threshold on the output of the filter, you can pass the threshold=True parameter to initiate adaptive threshold processing of the image, which is based on the brightness of the ambient pixel (the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.laplacian(size[, sharpen=False[, mul[, add=0[, threshold=False[, offset=0[, invert=False[, mask=None]]]]]]) The image is convolved by edge detection of the Laplacian kernel. Size is the size of the kernel. Take 1 (3x3 core), 2 (5x5 core) or higher. If sharpen is set to True, this method will instead sharpen the image instead of just outputting edge-detected images that have not been thresholded. Increase the kernel size and increase the image clarity. Mul is the number used to multiply the result of the convolutional pixel. If not set, it defaults to a value that will prevent scaling in the convolution output. Add is the number used to add the convolution result to each pixel. Mul can be used for global contrast adjustment, and add can be used for global brightness adjustment. If you want to adaptively set the threshold on the output of the filter, you can pass the threshold=True parameter to initiate adaptive threshold processing of the image, which is based on the brightness of the ambient pixel (the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. Mask is another image used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.bilateral(size[, color_sigma=0.1[, space_sigma=1[, threshold=False[, offset=0[, invert=False[, mask=None]]]]]) The image is convolved by a bilateral filter. A bilateral filter smoothes the image while maintaining the edges in the image. Size is the size of the kernel. Take 1 (3x3 core), 2 (5x5 core) or higher. The color_sigma control uses a bilateral filter to match the proximity of the color. Increasing this value increases the color blur. Space_sigma controls the degree to which pixels are blurred in space. Increasing this value increases pixel blur. If you want to adaptively set the threshold on the output of the filter, you can pass the threshold=True parameter to initiate adaptive threshold processing of the image, which is based on the brightness of the ambient pixel (the brightness of the pixels around the kernel function). Set to 1 or 0. A negative offset value sets more pixels to 1, while a positive value only sets the strongest contrast to 1. Set invert to invert the result output of the binary image. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.cartoon(size[, seed_threshold=0.05[, floating_threshold=0.05[, mask=None]]]) Roam the image and fill all the pixel areas in the image using the flood-fills algorithm. This effectively removes texture from the image by flattening the colors in all areas of the image. For best results, the image should have a lot of contrast so that the areas don't penetrate too easily. Seed_threshold Controls the difference between the pixels in the fill area and the original start pixel. Floating_threshold Controls the difference between pixels in the fill area and any adjacent pixels. Mask is another image that is used as a pixel-level mask for drawing operations. The mask should be an image with only black or white pixels and should be the same size as the image you are drawing. Only the pixels set in the mask are modified. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.remove_shadows([image]) Remove the shadow from the image. If the current image does not have a \"shadowless\" version, this method will attempt to remove the shadow from the image, but there is no true unshaded image basis. This algorithm is suitable for removing shadows in a flat, uniform background. Note that this method takes many seconds to run and is only suitable for removing shadows in real time, dynamically generating an unshadowed version of the image. Future versions of the algorithm will work for more environments, but equally slow. If the current image has a \"shadowless\" version, this method will remove all shadows in the image using the \"true source\" background unshadowed image to filter out the shadows. Non-shaded pixels are not filtered out, so you can add new objects that didn't exist before to the scene, and any non-shaded pixels in those objects will be displayed. Returns an image object so that you can use the . notation to call another method. Only RGB565 images are supported. This method is not available on OpenMV Cam M4. image.chrominvar() Remove the lighting effect from the image, leaving only the color gradient. Faster than image.illuminvar() but affected by shadows. Returns an image object so that you can use the . notation to call another method. Only RGB565 images are supported. This method is not available on OpenMV Cam M4. image.illuminvar() Remove the lighting effect from the image, leaving only the color gradient. Slower than image.chrominvar() but not affected by shadows. Returns an image object so that you can use the . notation to call another method. Only RGB565 images are supported. This method is not available on OpenMV Cam M4. image.linpolar([reverse=False]) The image is re-projected from Cartesian coordinates to linear polar coordinates. Set reverse = True to re-project in the opposite direction. Linear polar re-projection converts image rotation to x translation. Compressed images are not supported. This method is not available on OpenMV Cam M4. image.logpolar([reverse=False]) The image is re-projected from Cartesian coordinates to log polar coordinates. Set reverse = True to re-project in the opposite direction. Log-polar polar re-projection converts the rotation of the image to x translation and zoom to y translation. Compressed images are not supported. This method is not available on OpenMV Cam M4. image.lens_corr([strength=1.8[, zoom=1.0]]) Perform lens distortion correction to remove the fisheye effect caused by the lens. Strength is a floating point number that determines how much the fisheye effect is applied to the image. By default, try the value of 1.8 first, then adjust this value to make the image show the best results. Zoom is the value at which the image is scaled. The default is 1.0. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. img.rotation_corr([x_rotation=0.0[, y_rotation=0.0[, z_rotation=0.0[, x_translation=0.0[, y_translation=0.0[, zoom=1.0]]]]]) The perspective problem in the image is corrected by performing a 3D rotation of the frame buffer. X_rotation is the degree to which the image is rotated in the frame buffer around the x-axis (this causes the image to rotate up and down). Y_rotation is the degree of rotation of the image around the y-axis in the frame buffer (ie, the image is rotated left and right). Z_rotation is the degree by which the image is rotated in the frame buffer around the z-axis (ie, the image is rotated to the appropriate position). X_translation is the number of units that move the image to the left or right after rotation. Because this transformation is applied in 3D space, the unit is not a pixel... Y_translation is the number of units that move the image up or down after rotation. Because this transformation is applied in 3D space, the unit is not a pixel... Zoom is the amount that is scaled by the image. By default 1.0. Returns an image object so that you can use the . notation to call another method. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.get_similarity(image) Returns a \"similarity\" object describing the two images using the SSIM algorithm to compare the similarities of 8x8 pixel patches between the two images. Image can be an image object, the path to an uncompressed image file (bmp/pgm/ppm), or a scalar value. If a scalar value, the value can be an RGB888 tuple or a base pixel value (eg, an 8-bit grayscale of a grayscale image or a byte-inverted RGB565 value of an RGB image). Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.get_histogram([thresholds[, invert=False[, roi[, bins[, l_bins[, a_bins[, b_bins]]]]]]) Normalize histogram operations on all color channels of roi and return histogram objects. Please refer to the histogram object for more information. You can also call this method using image.get_hist or image.histogram . If you pass the thresholds list, the histogram information will only be calculated from the pixels in the threshold list. The thresholds must be a list of tuples. [(lo, hi), (lo, hi), ..., (lo, hi)] Define the range of colors you want to track. For grayscale images, each tuple needs to contain two values ​​- the minimum gray value and the maximum gray value. Only pixel regions that fall between these thresholds are considered. For RGB565 images, each tuple needs to have six values ​​(l_lo, l_hi, a_lo, a_hi, b_lo, b_hi) - the minimum and maximum values ​​for the LAB L, A and B channels, respectively. For ease of use, this feature will automatically fix the minimum and maximum values ​​of the exchange. Also, if the tuple is greater than six values, the remaining values ​​are ignored. Conversely, if the tuple is too short, the remaining thresholds are assumed to be in the maximum range. annotation To get the threshold of the tracked object, simply select (click and drag) the tracking object in the IDE framebuffer. The histogram will be updated accordingly to the area. Then just write down the color distribution in the starting and falling positions in each histogram channel. These will be the low and high values ​​of thresholds. Since the difference between the upper and lower quartiles is small, the threshold is manually determined. You can also determine the color threshold by going to Tools -> Machine Vision -> Threshold Editor in the OpenMV IDE and dragging the slider from the GUI window. Invert Reverses the threshold operation, where pixels are matched outside of the known color range, not within the known color range. Unless you need to use color statistics for advanced operations, simply use the image.get_statistics() method instead of this method to see the pixel areas in the image. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Bins and other bins are the number of bins used for the histogram channel. For grayscale images, use bins, for RGB565 images, use each of the other channels. The bin count for each channel must be greater than 2. In addition, it makes no sense to set the bin count to a number greater than the unique pixel value of each channel. By default, the histogram will have the maximum number of bins per channel. Compressed images and bayer images are not supported. image.get_statistics([thresholds[, invert=False[, roi[, bins[, l_bins[, a_bins[, b_bins]]]]]]) Calculates the average, median, value, standard deviation, minimum, maximum, lower quartile, and upper quartile for each color channel in roi and returns a data object. See the statistics object for more information. You can also call this method using image.get_stats or image.statistics . If you pass the thresholds list, the histogram information will only be calculated from the pixels in the threshold list. The thresholds must be a list of tuples. [(lo, hi), (lo, hi), ..., (lo, hi)] Define the range of colors you want to track. For grayscale images, each tuple needs to contain two values ​​- the minimum gray value and the maximum gray value. Only pixel regions that fall between these thresholds are considered. For RGB565 images, each tuple needs to have six values ​​(l_lo, l_hi, a_lo, a_hi, b_lo, b_hi) - the minimum and maximum values ​​for the LAB L, A and B channels, respectively. For ease of use, this feature will automatically fix the minimum and maximum values ​​of the exchange. Also, if the tuple is greater than six values, the remaining values ​​are ignored. Conversely, if the tuple is too short, the remaining thresholds are assumed to be in the maximum range. annotation To get the threshold of the tracked object, simply select (click and drag) the tracking object in the IDE framebuffer. The histogram will be updated accordingly to the area. Then just write down the color distribution in the starting and falling positions in each histogram channel. These will be the low and high values ​​of thresholds. Since the difference between the upper and lower quartiles is small, the threshold is manually determined. You can also determine the color threshold by going to Tools -> Machine Vision -> Threshold Editor in the OpenMV IDE and dragging the slider from the GUI window. Invert Reverses the threshold operation, where pixels are matched outside of the known color range, not within the known color range. You can use this method when you need to get a pixel area information in an image. For example, if you want to use the frame difference method to detect motion, you need to use this method to determine the change in the color channel of the image, which triggers the motion detection threshold. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Bins and other bins are the number of bins used for the histogram channel. For grayscale images, use bins, for RGB565 images, use each of the other channels. The bin count for each channel must be greater than 2. In addition, it makes no sense to set the bin count to a number greater than the unique pixel value of each channel. By default, the histogram will have the maximum number of bins per channel. Compressed images and bayer images are not supported. image.get_regression(thresholds[, invert=False[, roi[, x_stride=2[, y_stride=1[, area_threshold=10[, pixels_threshold=10[, robust=False]]]]]]) Perform linear regression calculations on all threshold pixels of the image. This calculation is done by least squares, which is usually faster, but does not handle any outliers. If robust is True, the Theil index will be used. The Theil index calculates the median of all slopes between all threshold pixels in the image. If you set too many pixels after the threshold transition, even on an 80x60 image, this N^2 operation may lower your FPS below 5. However, as long as the number of pixels to be set after the threshold conversion is small, linear regression is effective even when the threshold pixel exceeding 30% is an abnormal value. This method returns an image.line object. How to easily use straight line objects, see the following blog post: https://openmv.io/blogs/news/linear-regression-line-following The thresholds must be a list of tuples. [(lo, hi), (lo, hi), ..., (lo, hi)] Define the range of colors you want to track. For grayscale images, each tuple needs to contain two values ​​- the minimum gray value and the maximum gray value. Only pixel regions that fall between these thresholds are considered. For RGB565 images, each tuple needs to have six values ​​(l_lo, l_hi, a_lo, a_hi, b_lo, b_hi) - the minimum and maximum values ​​for the LAB L, A and B channels, respectively. For ease of use, this feature will automatically fix the minimum and maximum values ​​of the exchange. Also, if the tuple is greater than six values, the remaining values ​​are ignored. Conversely, if the tuple is too short, the remaining thresholds are assumed to be in the maximum range. To get the threshold of the tracked object, simply select (click and drag) the tracked object in the IDE framebuffer. The histogram will be updated accordingly to the area. Then just write down the color distribution in the starting and falling positions in each histogram channel. These will be the low and high values ​​of thresholds. Since the difference between the upper and lower quartiles is small, the threshold is manually determined. You can also determine the color threshold by going to Tools -> Machine Vision -> Threshold Editor in the OpenMV IDE and dragging the slider from the GUI window. Invert Reverses the threshold operation, where pixels are matched outside of the known color range, not within the known color range. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. X_stride is the number of x pixels to skip when calling a function. Y_stride is the number of y pixels to skip when calling a function. Returns None if the bounding box area after the regression is smaller than area_threshold . Returns None if the number of pixels after regression is less than pixel_threshold . Compressed images and bayer images are not supported. image.find_blobs(thresholds[, invert=False[, roi[, x_stride=2[, y_stride=1[, area_threshold=10[, pixels_threshold=10[, merge=False[, margin=0[, threshold_cb =None[, merge_cb=None]]]]]]]]]]]) Finds all the patches in the image and returns a list of patch objects that include each patch. Please observe the image.blob object for more information. The thresholds must be a list of tuples. [(lo, hi), (lo, hi), ..., (lo, hi)] Define the range of colors you want to track. For grayscale images, each tuple needs to contain two values ​​- the minimum gray value and the maximum gray value. Only pixel regions that fall between these thresholds are considered. For RGB565 images, each tuple needs to have six values ​​(l_lo, l_hi, a_lo, a_hi, b_lo, b_hi) - the minimum and maximum values ​​for the LAB L, A and B channels, respectively. For ease of use, this feature will automatically fix the minimum and maximum values ​​of the exchange. Also, if the tuple is greater than six values, the remaining values ​​are ignored. Conversely, if the tuple is too short, the remaining thresholds are assumed to be in the maximum range. annotation To get the threshold of the tracked object, simply select (click and drag) the tracking object in the IDE framebuffer. The histogram will be updated accordingly to the area. Then just write down the color distribution in the starting and falling positions in each histogram channel. These will be the low and high values ​​of thresholds. Since the difference between the upper and lower quartiles is small, the threshold is manually determined. You can also determine the color threshold by going to Tools -> Machine Vision -> Threshold Editor in the OpenMV IDE and dragging the slider from the GUI window. Invert Reverses the threshold operation, where pixels are matched outside of the known color range, not within the known color range. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. X_stride is the number of x pixels that need to be skipped when looking for a patch. Once the color block is found, the line fill algorithm will be precise pixels. If the color block is known to be large, increase x_stride to increase the speed at which the color block is found. Y_stride is the number of y pixels that need to be skipped when looking for a patch. Once the color block is found, the line fill algorithm will be precise pixels. If the color block is known to be large, increase y_stride to increase the speed at which the patch is found. If the bounding box area of ​​a patch is smaller than area_threshold, it will be filtered out. If the number of pixels in a patch is smaller than pixel_threshold, it will be filtered out. Merge If True, merges all the patches that have not been filtered. The border rectangles of these patches overlap each other. Margin can be used in the intersection test to increase or decrease the size of the patch boundary rectangle. For example, patches with edges of 1 and border rectangles of 1 will be merged. Merging patches allows color code tracking to be achieved. Each patch object has a code value code , which is a bit vector. For example, if you enter two color thresholds in image.find_blobs, the first threshold code is 1 and the second code is 2 (the third code is 4, the fourth code is 8, and so on). Merged patches use logical OR operations on all code so you know the color that produced them. This allows you to track two colors, and if you get a patch object in two colors, it might be a color code. If you use a strict color range and cannot fully track all the pixels of the target object, you may need to merge the patches. Finally, if you want to merge the patches, but don't want the two different threshold colors to be merged, just call image.find_blobs twice, and the different threshold patches will not be merged. The threshold_cb can be set to a function that calls each color block after threshold filtering to filter it out of the list of patches to be merged. The callback function will receive a parameter: the patch object to be filtered. The callback function then returns True to preserve the color block or return False to filter the color block. Merge_cb can be set to function to call two patches to be merged to disable or permit the merge. The callback function will receive two arguments - two patch objects that will be merged. The callback function must return True to merge the color blocks, or return False to prevent color block merging. Compressed images and bayer images are not supported. image.find_lines([roi[, x_stride=2[, y_stride=1[, threshold=1000[, theta_margin=25[, rho_margin=25]]]]]) Use the Hough transform to find all the lines in the image. Returns a list of image.line objects. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. X_stride is the number of x pixels that need to be skipped during the Hough transform. If the line is known to be large, increase x_stride. Y_stride is the number of y pixels that need to be skipped during the Hough transform. If the line is known to be large, increase y_stride. Threshold Controls the line that is detected from the Hough transform. Only return lines that are greater than or equal to threshold. The correct threshold value for the application depends on the image. Note: The magnitude of a line is the sum of the size of all Sobel filter pixels that make up the line. Theta_margin controls the merging of the lines being monitored. The part of the line angle of theta_margin is merged with the part of the line p value of rho_margin. Rho_margin controls the merging of the lines being monitored. The part of the line angle of theta_margin is merged with the part of the line p value of rho_margin. The method performs a Hough transform by running a Sobel filter on the image and using the amplitude and gradient response of the filter. No pre-processing of the image is required. However, cleaning up the image filter results in more stable results. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.find_line_segments([roi[, merge_distance=0[, max_theta_difference=15]]]) Use Hough transform to find line segments in the image. Returns a list of image.line objects. Roi is a region of interest (x, y, w, h) of a rectangle to be copied. If not specified, the ROI is the image rectangle. The operating range is limited to pixels in the roi area. Merge_distance specifies the maximum number of pixels between two segments that can be separated from each other without being merged. Max_theta_difference is the maximum angle difference between the two line segments that merge_distancede will merge above. This method uses the LSD library (also used by OpenCV) to find line segments in the image. This is a bit slow, but very accurate, the line segments won't jump. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.find_circles([roi[, x_stride=2[, y_stride=1[, threshold=2000[, x_margin=10[, y_margin=10[, r_margin=10]]]]]]) Use the Hough transform to find a circle in the image. Returns a list of image.circle objects (see above). Roi is a region of interest (x, y, w, h) of a rectangle to be copied. If not specified, the ROI is the image rectangle. The operating range is limited to pixels in the roi area. X_stride is the number of x pixels that need to be skipped during the Hough transform. If the circle is known to be large, increase x_stride. Y_stride is the number of y pixels that need to be skipped during the Hough transform. If the circle is known to be large, increase y_stride. Threshold Controls the circle detected from the Hough transform. Only returns a circle greater than or equal to threshold. The correct threshold value for the application depends on the image. Note: The magnitude of a circle is the sum of the size of all Sobel filter pixels that make up the circle. X_margin controls the merge of the detected circles. The round pixels are partially merged for x_margin , y_margin , and r_margin . Y_margin controls the merge of the detected circles. The round pixels are partially merged for x_margin , y_margin , and r_margin . R_margin Controls the merge of the detected circles. The round pixels are partially merged for x_margin , y_margin , and r_margin . Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.find_rects([roi=Auto, threshold=10000]) Use the same quad detection algorithm used to find AprilTAg to find rectangles in the image. Ideal for rectangles that contrast sharply with the background. AprilTag's quad detection can handle arbitrary scaling/rotating/cutting rectangles. Returns a list of image.rect objects. Roi is a region of interest (x, y, w, h) of a rectangle to be copied. If not specified, the ROI is the image rectangle. The operating range is limited to pixels in the roi area. The border size (by sliding the Sobel operator over all pixels on the edge of the rectangle and adding the value) is smaller than the rectangle of the threshold and is filtered from the return list. The correct value for threshold depends on your application/scenario. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.find_qrcodes([roi]) Find all the QR codes in roi and return a list of image.qrcode objects. Please refer to the image.qrcode object for more information. In order for this method to work successfully, the QR code on the image needs to be flat. By using the sensor.set_windowing function to zoom in at the center of the lens, the image.lens_corr function to dissipate the barrel distortion of the lens, or by replacing a lens with a narrow field of view, you get a flatter QR code that is unaffected by lens distortion. Some machine vision lenses do not cause barrel distortion, but they are much more expensive than the standard lenses offered by OpenMV, which is an undistorted lens. Roi is a region of interest (x, y, w, h) of a rectangle to be copied. If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. Image.find_apriltags([roi[, families=image.TAG36H11[, fx[, fy[, cx[, cy]]]]]) Find all AprilTags in roi and return a list of image.apriltag objects. Please refer to the image.apriltag object for more information. Compared to QR codes, AprilTags can be detected in longer distances, poorer light, and more distorted image environments. AprilTags can handle all kinds of image distortion problems, and the QR code does not. That is, AprilTags can only encode the digital ID as its payload. AprilTags can also be used for localization. Each image.apriltag object returns its three-dimensional position information and rotation angle from the camera. The position information is determined by fx, fy, cx, and cy, which are the focal length and center point of the image in the X and Y directions, respectively. Create AprilTags using the Tag Generator tool built into OpenMV IDE. The tag generator creates a printable 8.5\"x11\" AprilTags. Roi is a region of interest (x, y, w, h) of a rectangle to be copied. If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. The family is the bit mask of the tag family to be decoded. Is a logical or: image.TAG16H5 image.TAG25H7 image.TAG25H9 image.TAG36H10 image.TAG36H11 image.ARTOOLKIT The default setting is the best image.TAG36H11 tag family. Note: every time a tag family is enabled, the speed of find_apriltags will be slightly slower. Fx is the focal length of the camera's x-direction in pixels. The value of the standard OpenMV Cam is (2.8 / 3.984) * 656, which is obtained by dividing the focal length value of the millimeter by the length of the photosensitive element in the X direction and multiplying by the number of pixels of the photosensitive element in the X direction (for the OV7725 photosensitive element) In terms of). Fy is the focal length of the camera in the y direction in pixels. The value of the standard OpenMV Cam is (2.8 / 2.952) * 488, which is obtained by dividing the focal length value of the millimeter meter by the length of the photosensitive element in the Y direction, and multiplying by the number of pixels of the photosensitive element in the Y direction (for the OV7725 photosensitive element) In terms of). Cx is the center of the image, image.width()/2 , not roi.w()/2 . Cy is the center of the image, image.height()/2, not roi.h()/2 . Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. Image.find_datamatrices([roi[, effort=200]]) Finds all the data matrices in roi and returns a list of image.datamatrix objects. Please refer to the image.datamatrix object for more information. In order for this method to work successfully, the rectangular code on the image needs to be flat. By using the sensor.set_windowing function to zoom in on the center of the lens, the image.lens_corr function to dissipate the barrel distortion of the lens, or by replacing a lens with a narrow field of view, you get a flatter rectangular code that is unaffected by lens distortion. Some machine vision lenses do not cause barrel distortion, but they are much more expensive than the standard lenses offered by OpenMV, which is an undistorted lens. Roi is a region of interest (x, y, w, h) of a rectangle to be copied. If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. The effort controls the time used to find the rectangular code match. The default value of 200 should apply to all use cases. However, you may also increase the detection at the expense of the frame rate or increase the frame rate at the expense of detection. Note: If the effort is set below about 160, you will not be able to perform any tests; instead, you can set it to any high value you want, but if the setting is higher than 240, the detection rate will not continue to increase. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. image.find_barcodes([roi]) Find all the 1D barcodes in roi and return a list of image.barcode objects. Please refer to the image.barcode object for more information. For best results, use a long 640, wide 40/80/160 window. The lower the degree of verticality, the faster the speed. Since the barcode is a linear one-dimensional image, it is only necessary to have a higher resolution in one direction and a lower resolution in the other direction. Note: This function performs horizontal and vertical scanning, so you can use a window with a width of 40/80/160 and a length of 480. Finally, be sure to adjust the lens so that the bar code is positioned where the focal length produces the sharpest image. Fuzzy barcodes cannot be decoded. This function supports all 1D barcodes: image.EAN2 image.EAN5 image.EAN8 image.UPCE image.ISBN10 image.UPCA image.EAN13 image.ISBN13 image.I25 image.DATABAR (RSS-14) image.DATABAR_EXP (RSS-Expanded) image.CODABAR image.CODE39 image.PDF417 image.CODE93 image.CODE128 Roi is a region of interest (x, y, w, h) of a rectangle to be copied. If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Compressed images and bayer images are not supported. This method is not available on OpenMV Cam M4. Image.find_displacement(template[, roi[, template_roi[, logpolar=False]]]) Find the transform offset for this image from the template. This method can be used to make light flow. This method returns an image.displacement object containing the results of the displacement calculation using phase correlation. Roi is a rectangular area (x, y, w, h) that needs to be processed. If not specified, it is equal to the image rectangle. Template_roi is the rectangular area (x, y, w, h) that needs to be processed. If not specified, it is equal to the image rectangle. Roi and template roi must have the same w/h, but x/y can be anywhere in the image. You can slide a smaller rois on a larger image to get a smoother image of the light flow. Image.find_displacement usually calculates the x/y translation between two images. However, if you set logpolar = True , it will find a change in rotation and scaling between the two images. The same image.displacement object results in two possible feedbacks. Compressed images and bayer images are not supported. annotation Use this method on images with a uniform length and width (for example, sensor.B64X64). This method is not available on OpenMV Cam M4. image.find_number(roi) A LENET-6 CNN (Convolutional Neural Network) trained on the MINST data set is run to detect numbers in the 28x28 ROI located anywhere on the image. Returns a tuple containing integers and floating point numbers representing the detected number (0-9) and the confidence of the detection (0-1). Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Only grayscale images are supported. annotation This method is experimental. This method may be removed if you run any CNN that Caffe trains on your PC in the future. This function has been removed by the latest 3.0.0 firmware. This method is not available on OpenMV Cam M4. image.classify_object(roi) Run CIFAR-10 CNN on the ROI of the image to detect aircraft, cars, birds, cats, deer, dogs, frogs, horses, boats and trucks. This method automatically scales the image internally to 32x32 to feed to the CNN. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Only RGB565 images are supported. annotation This method is experimental. This method may be removed if you run any CNN that Caffe trains on your PC in the future. This method is not available on OpenMV Cam M4. Image.find_template(template, threshold[, roi[, step=2[, search=image.SEARCH_EX]]]) Try to find the location of the first template match in the image using the Normalized Cross Correlation (NCC) algorithm. Returns the bounding box tuple (x, y, w, h) of the matching position, otherwise returns None. Template is a small image object that matches this image object. Note: Both images must be grayscale. Threshold is a floating point number (0.0-1.0), where a smaller value increases the detection rate while increasing the false positive rate. Conversely, a higher value reduces the detection rate while reducing the false positive rate. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Step is the number of pixels that need to be skipped when looking up the template. Skip pixels can greatly increase the speed at which the algorithm runs. This method is only applicable to the algorithm in SERACH_EX mode. Search can be used for image.SEARCH_DS or image.SEARCH_EX. image.SEARCH_DS The algorithm used for searching templates is faster than image.SEARCH_EX, but if the template is around the edges of the image, it may not be searched successfully. image.SEARCH_EX performs a more detailed search of the image, but it runs much faster than image.SEARCH_DS . Only grayscale images are supported. image.find_features(cascade[, threshold=0.5[, scale=1.5[, roi]]]) This method searches for images of all regions that match Haar Cascade and returns a list of bounding box rectangle tuples (x, y, w, h) for these features. If no features are found, a blank list is returned. Cascade is a Haar Cascade object. See image.HaarCascade() for more information. Threshold is a floating point number (0.0-1.0), where a smaller value increases the detection rate while increasing the false positive rate. Conversely, a higher value reduces the detection rate while reducing the false positive rate. Scale is a floating point number that must be greater than 1.0. A higher scale factor runs faster, but its image matching is poorer. The ideal value is between 1.35 and 1.5. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Only grayscale images are supported. image.find_eye(roi) Find the pupil in the region of interest (x, y, w, h) around the eye. Returns a tuple containing the position of the pupil (x, y) in the image. If no pupil is found, it returns (0,0). Before using this function, you first need to search for someone's face using image.find_features() and Haar operator frontalface. Then use image.find_features and Haar operator find_eye to search for the eye on the face. Finally, this method is called on each eye ROI returned after calling the image.find_features function to get the coordinates of the pupil. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Only grayscale images are supported. image.find_lbp(roi) The LBP (local binary mode) key points are extracted from the ROI tuple (x, y, w, h). You can use the image.match_descriptor function to compare two sets of key points to get the matching distance. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Only grayscale images are supported. image.find_keypoints([roi[, threshold=20[, normalized=False[, scale_factor=1.5[, max_keypoints=100[, corner_detector=image.CORNER_AGAST]]]]]) The ORB key points are extracted from the ROI tuple (x, y, w, h). You can use the image.match_descriptor function to compare two sets of key points to get the matching area. If no key is found, return None. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Threshold is a number that controls the number of extractions (values ​​0-255). For the default AGAST corner detector, this value should be around 20. For the FAST corner detector, this value is approximately 60-80. The lower the threshold, the more corner points you extract. Normalized is a boolean value. If True, close the extraction keypoint at multiple resolutions. If you don't care about handling extensions and want the algorithm to run faster, set it to True. Scale_factor is a floating point number that must be greater than 1.0. A higher scale factor runs faster, but its image matching is poorer. The ideal value is between 1.35 and 1.5. Max_keypoints is the maximum number of key points a keypoint object can hold. If the key point object is too large and causes memory problems, lower the value. Corner_detector is the corner detector algorithm used to extract key points from an image. Can be image.CORNER_FAST or image.CORNER_AGAST . The FAST corner detector runs faster, but with less accuracy. Only grayscale images are supported. image.find_edges(edge_type[, threshold]) Turn the image into black and white and leave only the edges as white pixels. image.EDGE_SIMPLE - Simple threshold high-pass filtering algorithm image.EDGE_CANNY - Canny edge detection algorithm Threshold is a binary tuple containing a low threshold and a high threshold. You can control the edge quality by adjusting this value. The default is (100, 200). Only grayscale images are supported. Find_hog([roi[, size=8]]) The pixels in the ROI are replaced with HOG (Directed Gradient Histogram) lines. Roi is a rectangular tuple of interest regions (x, y, w, h). If not specified, the ROI is the image rectangle of the entire image. The operating range is limited to pixels in the roi area. Only grayscale images are supported. This method is not available on OpenMV Cam M4. Constant image.SEARCH_EX Detailed template matching search. image.SEARCH_DS Faster template matching search. image.EDGE_CANNY Edge detection is performed on the image using the Canny edge detection algorithm. image.EDGE_SIMPLE Edge detection is performed on the image using a threshold high-pass filtering algorithm. image.CORNER_FAST High-speed low-accuracy corner detection algorithm for ORB key points image.CORNER_AGAST Low speed high accuracy algorithm for ORB key points. image.TAG16H5 Bitmask enumeration for the TAG1H5 tag group. Used in AprilTags. image.TAG25H7 Bitmask enumeration for the TAG25H7 tag group. Used in AprilTags. image.TAG25H9 Bitmask enumeration for the TAG25H9 tag group. Used in AprilTags. image.TAG36H10 Bitmask enumeration for the TAG36H10 tag group. Used in AprilTags. image.TAG36H11 Bitmask enumeration for the TAG36H11 tag group. Used in AprilTags. image.ARTOOLKIT The bit mask enumeration of the ARTOOLKIT tag group. Used in AprilTags. image.EAN2 EAN2 barcode type enumeration. image.EAN5 EAN5 barcode type enumeration. image.EAN8 EAN8 barcode type enumeration. image.UPCE UPCE barcode type enumeration. image.ISBN10 ISBN10 barcode type enumeration. image.UPCA UPCA barcode type enumeration. image.EAN13 EAN13 barcode type enumeration. image.ISBN13 ISBN13 barcode type enumeration. image.I25 I25 barcode type enumeration. image.DATABAR DATABAR barcode type enumeration. image.DATABAR_EXP DATABAR_EXP barcode type enumeration. image.CODABAR CODABAR barcode type enumeration. image.CODE39 CODE39 barcode type enumeration. image.PDF417 PDF417 barcode type enumeration (currently not working). image.CODE93 CODE93 barcode type enumeration. image.CODE128 CODE128 barcode type enumeration. powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/machine_vision/video.html":{"url":"libs/machine_vision/video.html","title":"video","keywords":"","body":"video Support play and record video with avi format Global Function open(path, record=False, interval=100000, quality=50, width=320, height=240, audio=False, sample_rate=44100, channels=1) Open a avi file to play or record Parameters path： file path, e.g. /sd/badapple.avi record： record video or not, if False just to play video interval： Record interval, unit: micro second, fps = 1000000/interval, default to 100000, that is 10 frames per second quality： jpeg compress quality(%), default to 50 width： record screen width, default to 320 height： record screen height, default to 240 audio： record audio or not, default to False sample_rate： sample rate of recorded audio, default to 44100 (44.1k) channels： channels of recorded audio, default to 1 Return Value Return a object, just support avi format yet, so just return a instance of avi class Class avi Get from video.open() play() Play video, decode one frame data(video or audio) every once called Return value 0: play end 1: playing 2: pause(reverve) 3: current frame is video 4: current frame is audio volume(volume) Set play volume Parameters volume: value:[0,100] Return value Set value, ranges: [0,100] record() Record video frame, it will block until the interval time up Return Value The length of current frame( video ) Examples Example 1: Play avi video Encode a video with format: screen size 320x240， MJEPG compress format, PCM format audio You can download avi video here: badapple.avi import video,time from Maix import GPIO fm.register(34, fm.fpioa.I2S0_OUT_D1) fm.register(35, fm.fpioa.I2S0_SCLK) fm.register(33, fm.fpioa.I2S0_WS) fm.register(8, fm.fpioa.GPIO0) wifi_en=GPIO(GPIO.GPIO0,GPIO.OUT) wifi_en.value(0) v = video.open(\"/sd/badapple.avi\") print(v) v.volume(50) while True: if v.play() == 0: print(\"play end\") break v.__del__() By default, it will use I2S0 to display audio, so we need to set their corresponding pins; Turn off WiFi because of the interference of Dock board WiFi on sound quality Example 2: Record Video import video, sensor, image, lcd, time lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames(30) v = video.open(\"/sd/capture.avi\", record=1, interval=200000, quality=50) i = 0 tim = time.ticks_ms() while True: tim = time.ticks_ms() img = sensor.snapshot() lcd.display(img) img_len = v.record(img) # print(\"record\",time.ticks_ms() - tim) i += 1 if i > 100: break print(\"finish\") v.record_finish() lcd.clear() You can cancel the print comment to see if the actual recording interval has reached the set frame interval (such as 200000us set here). The actual print should be 200ms, If the actual frame interval is greater than the set value, the actual performance does not meet the set requirements. You need to increase the set frame interval to decrease the frame rate. In addition, removing the display and printing can also increase the frame rate to some extent. powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/peripheral_modules/":{"url":"libs/peripheral_modules/","title":"Peripheral modules","keywords":"","body":"Peripheral Modules Here peripheral means offchip modules, for example: LCD、 Camera、 touchscreen etc. The peripheral related to vision are put into machine vision), modules as follows: lcd: Display image on LCD sensor: Get camera data, we name it as sensor just like openmv do, but not totally the same as openmv's, see the doc Other Modules: touchscreen: Touchscreen related operation, like get click status or get click coordinate ws2812: WS2812 LED Thermal infrared temperature sensor Ultrasonic Grove chainable RGB LED powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/peripheral_modules/touchscreen.html":{"url":"libs/peripheral_modules/touchscreen.html","title":"touchscreen","keywords":"","body":"touchscreen Touchscreen related operation, like get click status or get click coordinate the drivers supported currently: ns2009 ( default ) To change driver, we need to rebuild the Maixpy firmware Global Function init(i2c=None, cal=None) Initialize touchscreen This API may be changed later, considering the different type of touchscreen Parameters i2c: Currently just support I2C touchscreen, so should give I2C object, we may rename this paramter or remove it later cal: Calibration data, a touple consist of 7 integer, get by touchscreen.calibrate() function calibrate() Calibrate touchscreen with LCD screen pixels Return Return a tuple consist of 7 integer, you can save it to file system or flash, use it in init function, so we no need to calibrate every power on read() Read the click status of touchscreen, and return coordinate of click( press ) Return 一个由 3 个整型值组成的元组 (status, x, y)， 注意这个值会一直保持上一个状态 A touple consist of 3 integet (status, x, y), be attention, the value always keep the last value if status did'nt change status： click status, values: touchscreen.STATUS_PRESS， touchscreen.STATUS_MOVE， touchscreen.STATUS_RELEASE x： x coordinate y： y coordinate Constant touchscreen.STATUS_PRESS The touchscreen is pressed, the firt value of tuple returned by read() touchscreen.STATUS_MOVE The touchscreen is pressed and pen is moving, the firt value of tuple returned by read() touchscreen.STATUS_RELEASE The touchscreen is released, the firt value of tuple returned by read() Examples Demo 1: Drawing Board Drawing board, you can clear content with boot key uncomment ts.calibrate() to execute calibration program import touchscreen as ts from machine import I2C import lcd, image from board import board_info from fpioa_manager import * board_info=board_info() fm.register(board_info.BOOT_KEY, fm.fpioa.GPIO1) btn_clear = GPIO(GPIO.GPIO1, GPIO.IN) lcd.init() i2c = I2C(I2C.I2C0, freq=400000, scl=30, sda=31) ts.init(i2c) #ts.calibrate() lcd.clear() img = image.Image() status_last = ts.STATUS_IDLE x_last = 0 y_last = 0 draw = False while True: (status,x,y) = ts.read() print(status, x, y) if draw: img.draw_line((x_last, y_last, x, y)) if status_last!=status: if (status==ts.STATUS_PRESS or status == ts.STATUS_MOVE): draw = True else: draw = False status_last = status lcd.display(img) x_last = x y_last = y if btn_clear.value() == 0: img.clear() ts.__del__() powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/peripheral_modules/ultrasonic.html":{"url":"libs/peripheral_modules/ultrasonic.html","title":"modules.ultrasonic","keywords":"","body":"modules.ultrasonic Ultrasonic sensor Construction method ultrasonic(gpiohs) Parameters gpiohs: gpiohs number, you need to register the pin withfm first, for example ```python from fpioa_manager import * from modules import ultrasonic fm.register (board_info.D [6], fm.fpioa.GPIOHS0, force = True) device = ultrasonic (fm.fpioa.GPIOHS0) ``` return value Return object method measure(unit, timeout) Parameters unit: unit, take the value in the following constants timeout: timeout time in microseconds (us) Constant ultrasonic.UNIT_CM Unit of distance returned, cm ultrasonic.UNIT_INCH Units of distance returned, feet powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/peripheral_modules/ws2812.html":{"url":"libs/peripheral_modules/ws2812.html","title":"modules.ws2812","keywords":"","body":"WS2812 light strip (modules.ws2812) This module uses the I2S ofK210 to drive the module, so you need to pay attention to the conflict during the use Currently supports up to 12 lights Constructor from modules import ws2812 class ws2812 (led_pin = -1, led_num = -1, i2s_num = I2S_DEVICE_2, i2s_chn = I2S_CHANNEL_3, i2s_dma_chn = DMAC_CHANNEL1) Create a new ws2812 object by specifying parameters Parameters led_pin: The pin of the light strip data cable connection, such asboard_info.D [4] led_num: How many lamp beads are there in the strip? i2s_num: WhichI2S device is used to drive this object, the default is I2S_DEVICE_2, the value range is0-2 i2s_chn: WhichI2S channel is used by this object, the default is I2S_CHANNEL_3, and the value range is0-3 i2s_dma_chn: The DMA channel used by this object, generally not considered by users Method set_led class_ws2812.set_led(num, color) parameters num: TheNth lamp, starting from 0 color: The color assigned to the lamp bead, of typetuple, (R, G, B) return value no display class_ws2812.display() parameters no return value no Routine 0 from modules import ws2812 class_ws2812 = ws2812 (board_info.D [4], 30) for i in range (30): class_ws2812.set_led (i, (0xff, 0,0)) class_ws2812.display () Routine 1 from modules import ws2812 class_ws2812 = ws2812 (board_info.D [4], 30) r = 0 dir = True while True: if dir: r + = 1 else: r-= 1 if r> = 255: r = 255 dir = False elif r Above routine, see MaixPy_scripts powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/peripheral_modules/htpa.html":{"url":"libs/peripheral_modules/htpa.html","title":"modules.htpa","keywords":"","body":"HTPA Thermal Infrared Temperature Measurement Module (modules.htpa) Hyman HTPA 32x32 Thermal Infrared Questioning Module Construction method htpa (i2c, scl_pin, sda_pin, i2c_freq) Create an instance Parameters i2c: I2C number, such asI2C.I2C0, value [0, 2] (see machine.I2C) scl_pin: I2C SCL pin sda_pin: I2C SDA pin i2c_freq: I2C clock frequency return value htpa object Instance method temperature() Get the sensor temperature value, which can only be called by the instance return value Array, the length is the width x height of the sensor, such as 32x32 Instance method width() Gets the sensor resolution width, which can only be called by the instance return value Integer, width instance method height() Gets the sensor resolution width, which can only be called by the instance Examples heimann_HTPA_32x32 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"libs/peripheral_modules/grove_chainable_rgb_led.html":{"url":"libs/peripheral_modules/grove_chainable_rgb_led.html","title":"Grove RGB LED","keywords":"","body":"Grove 链式 RGB LED 使用两跟线串行连接多个 RGB LED 灯（灯条） 使用 micropython 语法编写， 例程和资料见 MaixPy_Scripts powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"application/":{"url":"application/","title":"Integrated Apps","keywords":"","body":"Integrated Application pye: Integrated MaixPy file editor. Directly edit files on the board using the serial port. nes: NES game emulator lvgl: LittlvGL GUI lib powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"application/pye.html":{"url":"application/pye.html","title":"Micropython Editor","keywords":"","body":"pye Micropython Editor A file editor written by py, integrated into the MaixPy firmware. With it, you can directly edit files via the serial port terminal. Usage: from pye_mp import pye pye(\"/sd/boot.py\") powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"application/nes.html":{"url":"application/nes.html","title":"nes","keywords":"","body":"NES game emulator Classic NES game emulator, take us back to childhood! Or... Let us find a way to let it play itself! Function init(rc_type=nes.KEYBOARD, cs, mosi, miso, clk, repeat=16, vol=5) Initializes the NES emulator Parameters tc_type： Remote control type, keyboard（nes.KEYBOARD） （The serial port communicates with the computer's keyboard, it's not directly connected to the board's USB port...） or PS2 joystick（nes.JOYSTICK）。 A PS2 joystick is recommended for a better experience. Serial communication can't send more than one key at a time. If you want, you can try to write your own scripts here cs： If using a PS2 joystick with SPI interface, enter the cs pin number mosi： If using a PS2 joystick with SPI interface, enter the mosi pin number miso： If using a PS2 joystick with SPI interface, enter the miso pin number clk： If using a PS2 joystick with SPI interface, enter the clk pin number repeat： (Only for keyboard mode!) key repetition rate vol： Initial volume, can be adjusted later run(nes) Run a NES game (ROM) Parameters nes： File path of the game's ROM ， /sd/mario.nes for example Shortcuts Keyboard (serial port) move ： W A S D A ： J B ： K start ： M or Enter option： N or \\ exit ： ESC volume - ： - volume + ： = run speed - ： R run speed + ： F Joystick move ： ^ V -> A ： □ B ： × start ： START select： SELECT exit ： no volume - ： R2 volume + ： R1 run speed - ： L1 run speed + ： L2 Examples Demo 1： Keyboard (Serial port) import nes, lcd lcd.init(freq=15000000) nes.init(nes.KEYBOARD) nes.run(\"/sd/mario.nes\") Demo 2： PS2 joystick import nes, lcd lcd.init(freq=15000000) nes.init(nes.JOYSTICK, cs=19, clk=18, mosi=23, miso=21) nes.run(\"/sd/mario.nes\") powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"application/lvgl.html":{"url":"application/lvgl.html","title":"lvgl","keywords":"","body":"lvgl LittlevGL Refer to the official documentation: lvgl blog page Demo Refer to MaixPy_Scripts on github powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"advanced/compile.html":{"url":"advanced/compile.html","title":"Custom Firmware-Compile","keywords":"","body":"Source code compilation Pre-compiled firmware may not meet specific usage scenarios. If you need to modify the configuration, configure and compile the required firmware Compiled please refer to build.md powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"advanced/code_struct.html":{"url":"advanced/code_struct.html","title":"Code structure","keywords":"","body":"Code frame structure Directory Introduction Directory Subdirectory Subdirectory2 Subdirectory3 Brief assets Resource like image projects Project dir tools tools components ┐ component └-boards code for board specific └-drivers driver code └-micropython ┐ Micropython related └-core micropython source code └-port ┐ maixpy port code └-builtin_py maixpy defualt builtin script └-include headers └-src modules └-spiffs SPIFFS └-utils utils Add code The project is organized using CMake, and the project supports multiple configurable options (Kconfig) If you do not add folders and configuration items, you can add files to the existing folder for compilation. If you need to add modules, you can modify CMakeLists.txt to add content, you can refer to [c_cpp_project_framework] (https://github.com/Neutree/c_cpp_project_framework) with less content If you need to add configuration items, you can modify the Kconfig file to achieve the purpose. All configuration items will generate macro definitions and add them toglobal_config.h (generated file) at compile time, and in CmakeLists.txt This macro definition can be used in files. For example, config BOARD_M5STICK is defined in Kconfig, and CMakeLists.txt can determine whether to compile specific code by judging whether CONFIG_BOARD_M5STICK is true. When compiling, you can choose whether to check by python3 project.py menuconfig powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"advanced/pack_fs.html":{"url":"advanced/pack_fs.html","title":"Pack SPIFFS","keywords":"","body":"Packaged file system Package several files on the PC into a SPIFFS file system image, use kflash to burn to a specific address of the flash, and these files can be read directly on the development board (MaixPy) See the instructions for details:pack SPIFFS for MaixPy powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"others/Q_A.html":{"url":"others/Q_A.html","title":"Q&A","keywords":"","body":"MaixPy Frequently Asked Questions What are the similarities and differences between MaixPy and C development, how do I choose MaixPy is a scripting language based on Micropython, which does not require compilation and is parsed at runtime. It is easier and more convenient to write, but the runtime is not as good as the C language. So if you are fast verification, novice, only python, less hair, etc., you can use MaixPy; you can use C language for the pursuit of extreme performance efficiency or familiar with C MaixPy IDE cannot successfully connect to the development board Check if the serial port is occupied After clicking the connection, do not use it with the terminal tool at the same time, otherwise the serial port will be occupied and cannot be opened If you have been unable to connect successfully, check: Please check if the development board model is wrong; Observe whether the screen of the development board has changed. If there is no response, it may be that the serial port is selected incorrectly; Try to upgrade to the latest master branch firmware, and the latest MaixPy IDE software The document web page cannot be opened, it is slow If some pages cannot be accessed, please check the URL (path) is correct, you can return to the homepage (maixpy.sipeed.com) and enter again. For example, this URL is caused by clicking too fast: ` http://localhost:4000/zh/zh/get_started/how_to_read.html The correct URL should be: `` http://localhost:4000/zh/get_started/how_to_read.html ` In addition, you can try another network line, such as hanging a proxy, or trying mobile phone traffic. Download station file download speed is slow, the file cannot be downloaded If you experience slow download speed on the dl.sipeed.com download site, you can use the domestic synchronization server cn.dl.sipeed.com to download, the path is the same, and sync once a day; Some files provide CDN download links, which will be faster. For example, the IDE has a description in readme.txt Micro SD card cannot be read Format Micro SD to FAT format(not FAT32), and try again. At present the hardware can only support SPI protocol reading, try to buy a formal card For example: The two cards on the left in the figure below are not supported by the MaixPy driver, the middle and right are supported, but the class10 card in the middle is the fastest (up to 128GB available) In addition, I tested several SanDisk, Kingston, Samsung cards purchased online, and found that one Samsung card is unusable Why is the IDE frame rate lowered a lot? The K210 has no USB peripherals, so it can only communicate with the IDE using a serial port, which is not as fast as a USB device, so it will affect the frame rate. You can turn off the camera preview of the IDE. Why the preview camera image on the IDE is blurry The K210 has no USB peripherals, so it can only communicate with the IDE using a serial port. The speed is not as fast as a USB device. Therefore, the pictures are compressed. If you need to see a clear image, please see it on the screen of the development board, or save it as a picture and transfer it to the computer for viewing How to increase the camera frame rate Change to a better camera, for example ov7740 will have a higher frame rate thanov2640. But the premise is that the camera circuit must be compatible with the circuit of the development board Increase the camera clock frequency(sensor.reset(freq=)), but be careful not to be too high, it will make the picture worse You can compile the source code yourself, turn on the camera's double buffering option (by default), and sensor.reset (dual_buff = True), the frame rate will increase, but the corresponding memory will also increase (about 384KiB) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"contribute/":{"url":"contribute/","title":"Contribute","keywords":"","body":"Contribute to the project Since this is an open source project, everyone is welcome to join in and improve MaixPy. Due to the large number of people, we need a code convention (including format, style, etc.) The following documents describe the coding convention for both the documentation and code: Documentation convention Code convention powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"contribute/doc_convention.html":{"url":"contribute/doc_convention.html","title":"参与文档编写（规范）","keywords":"","body":"文档贡献规范 有几种情况你可能需要看本文档： 发现文档有误或者有内容需要补充，并且会自己想参与修改 提交 教程/经验/开源项目分享 等等 为了让文档看起来风格统一， 内容不重复不出错， 编写需要遵循同一个规范，请各位贡献者务必根据本文撰写文档； 如果对模板格式，内容存在疑惑请到本项目仓库 MaixPy_DOC 提交 ISSUE。 🙇‍ 感谢各位贡献者的热心支持！ 要参与贡献，你需要提前掌握的知识 git 和 github 的使用 github PR（pull request）的使用 在入门教程里面有简要的介绍， 详细的使用方法请自行学习 如果你没有信心掌握这些技能， 你可以到提交issue 来说明问题或者贡献经验等，我们帮助你进行添加 文档系统简介 文档使用 gitbook 进行构建， 并使用简单高效的 Markdown 编写内容, 这里推荐使用 Typora 或者 VS Code 搭配 MarkDown Preview Enhanced 插件作为文档编辑器 文档源码托管在 github 本地预览方法见 文档源码的 README.md 文档有两种语言， 中文和英文，分别放在zh和en文件夹中， 其中的SUMMARY.md是文档左边的目录项，其它md文件时具体的文档文件，根目录下的assets目录放两种语言公用的图片资源文件 Markdown 语法 Markdown 的基础语法如果没接触过， 请花半个小时进行学习， 推荐github的教程： github Markdown 教程 在本文中， 以下几点我们需要注意： 标题类的语法标记必须使用空格隔开，大标题与正文之间需要一个空行，比如： ## 这是二级标题 * 这是列表项1 * 这是列表项2 而如下所示的则不是正确的，可能会导致解析器出现解析错误格式错乱等 ##这是二级标题 *这是列表项1 *这是列表项2 所有页面只有一个一级标题 由于需要自动生成目录，主要是为了保证自动生成的目录正确。 每个页面这样写 页面标题/一级标题 ======= (这里等号至少需要三个) ( 至少需要一个以上的空行，建议2行 ) ## 二级标题1 ( 这里不能使用一级标题，及不能用一个#号。 也不需要写序号，会自动生成序号) ( 空一行 ) 正文 ( 至少空一行) ### 三级标题 ( 类似二级标题, 也不需要写需要，会自动生成) 正文 ## 二级标题2 正文 标题编号 所有标题不需要写编号， 会自动生成比如 ## 标题一 ### 子标题1 ## 标题二 最终效果： 1. 标题一 1.1 子标题1 2. 标题二 如果手动写了最终显示就会重复， 所以需要注意！ 链接 由于页面众多，而且需要链接图片等资源，在写链接时，均使用相对路径， 比如目录结构如下 assets/ (放公用的资源文件) | ----pic000.png en/ | ----- get_started/ | ---- assets/ (放get_started目录下md文件公用的资源文件) | ------ pic.png | ---- get_hardware.md | ---- how_to_read.md zh/ 如果在get_hardware.md中贴图片，将图片放进assets文件夹后，使用如下代码引用图片 ![pic](assets/pic.png) ![pic](../../assets/pic000.png) 中英文混写 在写中文文档时，在中文中夹杂英文尽量用空格隔开，标点符号尽量使用全角符号， 主要是为了显眼，让文档更优雅。 比如： 在 Micropython 中， 我们常常使用 `deinit` 来表示析构函数，而不是像 STM32 一样来表示设置默认值 在 Micropython 中， 我们常常使用 deinit 来表示析构函数，而不是像 STM32 一样来表示设置默认值 在 Micropython 中， 我们常常使用 deinit 来表示析构函数，而不是像 STM32 一样来表示设置默认值 在 Micropython 中， 我们常常使用 deinit 来表示析构函数，而不是像 STM32 一样来表示设置默认值 目录 多种语言分别放在不同的目录，en和zh目录 生成的文档目录在对应语言的文件夹 SUMMARY.md 中编辑 源文档的文件夹尽量一个功能模块对应一个文件夹，资源文件（图片）放置到对应 md 文档根目录下的 assets 文件夹目录下，这样方便中英文文档都引用同样的图片，而且生成的 URL 相同，同时增删修改时更方便。 同时，为了中英文文档都能使用，图片里面尽量不要标注中文或英文，可以标注标号，然后文档用标号阐述， 针对特定语言的图片放到当前路径下的 assets 目录： assets/ (放公用的资源文件， 中英文都能引用) en/ | ----- get_started/ | ---- assets/ (放get_started目录下md文件的资源文件， 只给英文使用) | ---- get_hardware.md | ---- how_to_read.md zh/ 文件名 文件名除了 README.md 特殊，其它文件名使用 小写+下划线 的命名方式，比如 get_hardware.md 中英文（多语言）的页面文件目录结构和文件名相同 由于最后生成的页面中有多语言切换选项，点击切换后会直接访问对应语言的相同路径，所以中英文的目录结构和文件名必须相同。 比如英文正在访问 en/get_started/how_to_read.md，点击语言切换的按钮后，会自动访问 zh/get_started/how_to_read.md，如果这个文件不存在就会报404错误！ 目录和链接 尽量引导阅读者使用目录，文内跳转链接慎用，如果链接跳得比较乱，会导致文档看起来比较乱，阅读会比较困难。 模块文档内容 文件头部包含模块的介绍，资源介绍，使用注意点， 例程 需要分点说明构造函数、函数、常量等 说明不能偷懒只简单将函数名称翻译一遍，需要详细说明函数的功能、参数的取值范围以及注意点 多版本管理 文档除了做了中英文（多语言）支持（不是自动翻译，需要手动修改）， 也做了多版本管理。 每个版本是一个分支， 对分支名字有要求， 分别为： master 分支为主分支 dev分支为开发分支 其它的发布的历史版本均以小写 v 开头，比如创建一个分支叫 v1.2 创建好新的分支后，需要在每个语言版本的目录下 book.json中修改版本链接，不然读者找不到入口 可以在新建的分支下本地预览（预览方法见根目录 README.md），注意这时候预览的页面就是当前分支的内容，如果要本地预览其它分支内容，需要先切换到其它分之后再预览即可。 确认无误修改完成后推送分支到远程（github），自动构建系统会自动构建并发布到 pages 分支，等构建完毕访问网址即可看到效果。 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"contribute/code_convention.html":{"url":"contribute/code_convention.html","title":"代码编写规范","keywords":"","body":"MaixPy 编程规范 这是一份 MaixPy 开发人员的开发指引。MaixPy 做为一份开源软件，它需要由不同的人采用合作的方式完成，这份文档是开发人员的一个指引。 MaixPy 的开发人员请遵守这样的编程风格。同时对于使用 MaixPy 的用户，也可通过这份文档了解 MaixPy 代码内部一些约定从而比较容易的把握到 MaixPy 的实现方式。 0、规范原则 [x] 朴实，避免晦涩语法 [x] 严谨，逻辑反复思考 [x] 简约，命名简洁、代码精炼 [x] 性能，通过算法、编译器、硬件进行优化 1、目录结构 && 文件名称 目录结构 整个工程按照功能模块划分子目录，每个子目录再划分头文件和源文件目录，以便架构清晰、易懂。 目录名称如果无特殊的需求，请使用全小写的形式；目录名称应能够反应部分的意思，components 目录下能够反映组件的意义。 文件结构 文件名称如果无特殊的需求(如果是引用其他地方，可以保留相应的名称)，请使用全小写的形式。另外为了避免文件名重名的问题，一些地方请尽量不要使用通用化、使用频率高的名称。 3.头文件定义 C语言头文件为了避免多次重复包含，需要定义一个符号。这个符号的定义形式请采用如下 的风格： #ifndef __FILE_H__ #define __FILE_H__ /* header file content */ #endif 即定义的符号两侧采用 \"_\" 以避免重名，另外也可以根据文件名中是否包含多个词语而 采用 \"\" 连接起来。 4.文件头注释 在每个源文件文件头上，应该包括相应的版权信息，Change Log 记录： /** * File : maixpy_main.h * This file is part of MaixPy * Copyright 2019 Sipeed Co.,Ltd. MaixPy Development Team * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 例如采用如上的形式。 5.结构体定义 结构体名称请使用小写英文名的形式，单词与单词之间采用 \"_\" 连接，例如： struct lcd_config { int width; int height; }; 其中，\"{\"，\"}\" 独立占用一行，后面的成员定义使用缩进的方式定义。 结构体等的类型定义请以结构体名称加上 \"_t\" 的形式作为名称，例如： typedef struct lcd_config lcd_config_t; 6.宏定义 在 MaixPy 中，请使用大写英文名称作为宏定义，单词之间使用 \"_\" 连接，例如： #define MAIXPY_TRUE 1 7.函数名称、声明 函数名称请使用小写英文的形式，单词之间使用 \"_\" 连接。提供给上层应用使用的 API 接口，必须在相应的头文件中声明；如果函数入口参数是空，必须使用 void 作为入口参 数，例如： maixpy_err_t lcd_init(void); 8.注释编写 请使用英文做为注释，使用中文注释将意味着在编写代码时需要来回不停的切换中英文输入法从而打断编写代码的思路。并且使用英文注释也能够比较好的与中国以外的技术者进行交流。 源代码的注释不应该过多，更多的说明应该是代码做了什么，仅当个别关键点才需要一些相应提示性的注释以解释一段复杂的算法它是如何工作的。对语句的注释只能写在它的上方或右方，其他位置都是非法的。 9.缩进及分行 缩进请采用 4 个空格的方式。如果没有什么特殊意义，请在 \"{\" 后进行分行，并在下一行都采用缩进的方式，例如： if (condition) { /* others */ } 唯一的例外是 switch 语句，switch-case 语句采用 case 语句与 switch 对齐的方式， 例如： switch (value) { case value1: break; case value2: break; defalut: break; } case 语句与前面的 switch 语句对齐，后续的语句则采用缩进的方式。 分行上，如果没有什么特殊考虑，请不要在代码中连续使用两个以上的空行。 10.大括号与空格 从代码阅读角度，建议每个大括号单独占用一行，而不是跟在语句的后面，例如： if (condition) { /* others */ } 匹配的大括号单独占用一行，代码阅读起来就会有相应的层次而不会容易出现混淆的情况。 空格建议在非函数方式的括号调用前留一个空格以和前面的进行区分，例如： if (x 建议在括号前留出一个空格(涉及的包括 if、for、while、switch 语句)，而运算表达式中，运算符与字符串间留一个空格。另外，不要在括号的表达式两侧留空格，例如： if ( x 这样括号内两侧的空格是不允许的。 11.log 信息 在 MaixPy 中，普遍使用的 log 方式是 printk, 而面向 py 终端的是使用 mp_print, 而在我们对 MaixPy 功能增减之后建议将不需要的 printk 删除或者注释掉 但是注意，最终提交的代码里面不能有printk和printf函数， 只能在调试时使用！！！否则会导致 IDE 使用时断开连接 日志输出应该被设计成正常情况下是关闭状态(例如通过一个变量或宏就能够开启)，并且 当真正输出日志时，日志是易懂易定位问题的方式。\"天书式\"的日志系统是糟糕的，不合理的。 12.函数 在内核编程中，函数应该尽量精简，仅完成相对独立的简单功能。函数的实现不应该太长，函数实现太长，应该反思能够如何修改(或拆分)使得函数更为精简、易懂。 14. 用 astyle 自动格式化代码 参数： --style=allman --indent=spaces=4 --indent-preproc-block --pad-oper --pad-header --unpad-paren --suffix=none --align-pointer=name --lineend=linux --convert-tabs --verbose 规范参考 AliOS-Things -- 《AliOS Things Coding Style Guide》 RT-Thread -- 《RT-Thread 编程风格》 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"others/open_projects.html":{"url":"others/open_projects.html","title":"Related projects","keywords":"","body":"Open source projects related to MaixPy If you have any open source projects related to MaixPy, feel free to open a new pull request or let us know by opening an issue or sending an email (support@sipeed.com)! We are happy to receive your feedback and contributions! powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"what_maix_do.html":{"url":"what_maix_do.html","title":"MaixPy 能做哪些事","keywords":"","body":"Powerful Maix Board(k210) Can Do 大多数是在 MaixPy 上已经有 API， 部分可能来自 Maixduino 或者其它开发者～ 人脸检测 MobileNet 物体识别 tiny yolov2 20分类 人脸识别 识别颜色值、找形状、找直线、面部识别等 视频来自 Hardware.ai MNIST 手写数字识别 Feature map 显示 视频播放和录制 NES 游戏模拟器 （FC 红白机） GBA 游戏模拟器 源码 游戏 Quake I 源码 游戏 Doom 源码 MMD 3D 实时渲染 源码 GUI 界面 littlevGL 云台脸部跟踪 麦克风阵列 FFT 频谱图 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"maixpy_history.html":{"url":"maixpy_history.html","title":"MaixPy 发展历程","keywords":"","body":"MaixPy 发展历程 写下本篇发展历程， 希望让后来的开发者们了解到 MaixPy 都经历了什么，以及一些重大的改变的原因是什么，以及在何时取得了重大的进步等 代码提交历史可以在 historic 和 master 分支看到 2018 年 9 月 MaixPy 项目启动，契机是 K210 芯片流片完成。 于是大家想着做一套让更多人在嵌入式使用的 AI 开发的易使用的软件套件， 因为 Micropython 的易用性，而且 k210 有 6+2MiB 内存，主频 400MHz，完全能够驾驭 Micropython， 故选择了 Micropython 作为编程语法 基于开发板 Maix dock， 这时取名为 荔枝丹， QQ 群名也叫荔枝丹炼丹群 xiaohui 和 wipping 开始尝试对 Micropython 移植 2018 年 12 月 k210 SDK 从 freertos 换成了 standalone SDK, 并且着手片上外设驱动适配 neucrack ，xel 和 zepan 加入项目组 2019 年 2 月 发布第一版固件 v0.1.1 beta, 支持了基本的外设， 继承了 openmv 的 image sensor lcd API，适配了一些开源的工具比如 upyloader，armpy等, 编写文档 并发布在 maixpy.sipeed.com 另外这时也有了 Maix bit 和 Maix Go 两块新开发板 xiaohui 退出项目组 2019 年 3 月 发布第二版固件 v0.2.4, 增加了 jpeg， wav， kpu， nes， avi， lvgl 等支持 2019 年 4 月 适配了 OpenMV IDE 也就是 MaixPy IDE， 在原来软件的基础上只将 USB 通信改成了 k210 支持的 串口通信， 其它功能没有变化 预编译固件开始区分功能分成多个固件， 主要考虑到运行模型内存不足的问题 wipping 退出项目组， zepan 和 xel 专注到其它项目组 2019 年 6 月 重构了项目结构， 之前是直接在 micropython 的目录结构中添加代码， 在 port 目录中添加代码， 但是这会有一个问题， 就是更新 micropython 程序变得比较麻烦， 需要将 micropython 和 MaixPy 增加的代码分开， 而且旧的代码结构太混乱， Makefile 写得也不是很好，构建缓慢。 所以有了现在的目录结构， 使用了 cmake + kconfig 对工程进行构建， 同时将各个组件模块化， 并且可以选择是否编译进固件， 编译框架在这里。 但是仍有遗留问题， 目录下面有一些遗留代码没有完全接偶。 2019 年 7 月 增加 M5Stick-V 开发板的支持， 由 Martin Han 维护 2019 年 12 月 Maixhub 上线， 用于在线模型训练，只需要上传数据集无须编写代码 硬件更新： 上线 M1N 模块， 金手指模块 2020 年 4 月 糖老鸭 加入项目组 2020 年 5 月 大佬鼠 加入项目组 2020 年 6 月 硬件更新： 上线 Maix Cube 开发板 2020 年 7 月 为不同板子增加板级配置文件， 放在文件系统中， 开机读取， 主要是由于 Cube 和 Amigo 增加了电源芯片， 在开机时为了能正常使用必须先设置电源芯片 硬件更新： 上线 Maix Amigo 开发板， 增加了外壳 2020 年 11 月 重新梳理文档， 更完美的文档和社区 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"thanks.html":{"url":"thanks.html","title":"致谢","keywords":"","body":"powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"how_to_read.html":{"url":"how_to_read.html","title":"如何正确阅读本文 (重要！！！)","keywords":"","body":"如何正 阅读 本文 注意： 目前唯一文档官网： maixpy.sipeed.com 首先请仔细阅读一遍左边侧边栏的目录结构看一看文档有那些内容 简介： MiaxPy 的简介，作品展示，以及发展历史等 入门指南： 使用 MaxiPy 的入门教程，包括基础知识，一定要看， 才能避免遇到很多问题，会给后面开发节省很多时间 手把手教程： 这里是一步一步地教各种功能的使用， 对于刚上手不知道该做什么的同学们很有用， 仔细读哦 API 手册： 各个功能模块的 API 手册， 方便编程时查阅 标准库： micropython 的标准库， 很多 API 兼容 python3 的 API machine： 机器相关， 重启控制，机器 UID， 以及各种外设控制 Maix: 一些特殊的模块， 比如 FPIOA， KPU， FFT等 内置类：内置的用 mpy（micorpython 的缩写）编写的类， 可以在源码项目中找到 机器视觉: 一些机器视觉相关的模块， image sensor lcd 大致上兼容 OpenMV 的 API， 但是后期不会实时跟着 OpenMV 更新 附加外设模块： 一些外设模块的使用， 比如触摸屏， 超声波， LED 灯等 内置应用： 内置的应用， 比如 NES 游戏机（FC 红白机，也就是小时候的小霸王游戏机），pye（内置的文档编辑器） 常见问题 FAQ： 大家经常问的问题汇总 进阶： 一些进阶的玩法, 以及如何参与 文档的修改 和 源码的修改，或者 例程 的贡献 社区 & 分享： 收集一些来自社区的好的教程、作品、开源项目等， 大家也可以按照贡献说明来共享自己的作品或者教程 重要必读部分 简介和入门指南，一定要完整看完， 遇到问题也一定要先看 常见问题 开始学习 刚接触，可以根据左边侧边栏的目录从上到下一页一页仔细看，跟着做即可， 入门一定不要跳过！！！ 学会如何更新固件，如何写代码，其中学会使用串口终端也十分重要，不建议过分依赖IDE， 特别是在程序死掉的时候， 用终端可能会获得更多报错信息，更有利于解决问题，在遇到问题在社区提问时，也尽量给出终端运行的完整信息 每个模块/库文档里面的结尾都附有简单例程， 或者到这里:MaixPy_script查找需要的示例， 可以尝试运行看效果 学会搜索 关于模块的接口及参数，在使用时根据自己的需求进行查阅，左上角有搜索框，可以好好利用，同时也可以使用浏览器的页面搜索功能，即按键盘 Ctrl+F ，然后输入要搜索的内容后按确认键 如果有找不到的内容也请不要着急， 可以上 github 的 issue） 页面找一找（/搜一搜）是不是有人提过了，没有的话可以新建 issue, 或者到 论坛 搜索问题，没有再向大家求助， 或者联系技术支持。 本文档常见问题 文档加了 PDF 生成， 但是尽量不要传播 PDF 版本， 因为内容更新后 PDF 得不到及时更新， 尽量访问此网站(https://maixpy.sipeed.com)查看文档 如果网页加载比较慢， 请尝试刷新或者等待， 或者换个线路（使用代理或者换手机流量试试） 本文档有两个域名： https://maixpy.sipeed.com 和 https://cn.maixpy.sipeed.com， 一个访问不了时可以访问另一个 文档使用 gitbook 从 markdown 自动生成为静态页面， 如果遇到有些页面无法访问， 请检查一下网址（路径）是否正确， 可以回到首页 (maixpy.sipeed.com) 重新进入即可。 比如这个网址就是由于网络情况不佳点击过快导致的： http://localhost:4000/zh/zh/how_to_read.html 正确的网址应该是： http://localhost:4000/zh/how_to_read.html MaixPy 常见问题 常见问题请见常见问题 其它教程 除了文档，还可以浏览博客看用户写的教程， 或者百度搜索， 以及各个开发者的博客，都会有很多开发教程开发日记等， 都可以参考 提问技巧 在各种地方提问， 不管是 github 还是 QQ 群，还是论坛， 还是邮件， 提问要尽量提供完整的问题复现步骤，把你所经过的使用过程， 问题是怎么产生的， 现象是什么样的， 一定要完整地说明， 不要怕文字多，要站在解决问题的人的角度想问题，提的问题开发者能解决吗？ 方便开发者百忙之中测试问题并解决！ 更加具体的请看下一节 如何优雅提问 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"how_to_ask.html":{"url":"how_to_ask.html","title":"如何优雅提问 (重要！！！)","keywords":"","body":"如何优雅地提问 在各个地方提问时， 大家会发现有几个现象： 提问题后没人回答 提的问题过了很久才有人回答 对方老是嫌弃自己太菜 问问题前，确认自己已经学习了 入门指南 本文档的 入门指南 章节， 是使用 MaixPy 的基础中的基础， 不管你是否有过开发经验，是大佬还是小白， 请务必从前到后完整阅读并操作一遍。 很多问题会在这个过程中解决， 切忌一开始就到 QQ群、论坛 、issue， 或者邮件随便提问， 很多在文档中一开始就说明了的问题可能不会得到社区的及时的回答， 节省大家的时间，也为了更好的社区环境，大家共同更好地成长，请互相理解 提问时，尽量做到以下几点，会大大提高问题被快速解决的几率： 缕清问题， 弄清楚到底发生了什么，以及我做了什么，包括： 我想实现什么效果，什么功能？ 为了实现这个效果，我是怎么做的， 详细的过程是什么？ 实施的过程中， 什么错误发生了， 现象是什么（比如报错了， 报了什么错，完整的错误内容是什么？ 我是否认真看了报错的信息， 报错信息中是否有提示了错误的原因和解决的方法？ 根据这些报错信息， 仔细思考， 是否能解决问题？ 搜索 文档、 issue， 以及用搜索引擎能不能搜索到问题的解决方法 如果问题自己实在不能解决， 需要请教于人， 需要考虑： 请教谁，在哪里请教， 谁会更有几率回答我的问题？以及实时性如何？ 我应该给他提供什么数据和现象他才能愿意快速帮我解决问题？ 提供我的目的 （方便让回答者知道你在做什么事情） 提供完整的实施过程， 以及过程中出现的现象 （方便回答者跟着你的流程去做一遍， 即问题复现） 给出错误的地方， 指明哪里出现的现象或结果和自己预期的不一样！ （让回答者知道，哪里没达到预期） 提供出现的错误信息， 需要完整， 尽可能更多地截图， 更多的日志，千万别小气地截一张小图，或者之给出日志的一部分（ 因为回答者可能很久没做这件事情了，忘记了一些细节，需要靠截图和完整日志来快速回忆起来; 而且根据详细的日志可以快速定位到问题处在哪里） 怎么提问态度显得比较诚恳，就算我再小白，大家也愿意回答 提问模板 提问尽量做到提问优雅，不需要添加多余的语气词，抱怨的词汇，斟酌每一个词和标点符号，站在回答人的角度思考问题，如何让回答的人快速帮助自己解决问题， 字数太少描述不清楚， 字数太多则让人没有耐心 标题 无论在哪里提问（包括QQ群）， 给自己的问题拟定一个30个字左右标题， 阐明问题的中心思想，包括： 问题类别， 是问题请教，还是 BUG提交，还是经验分享等等。让大家在满是文字的屏幕上可以立马定位到你想做什么 一句话阐明问题的中心你思想，比如 运行摄像头示例程序，报错 reset fail， 可能是硬件问题 所以综合后标题可以是这样： 【MaixPy 提问】 运行摄像头示例程序，报错 reset fail， 可能是硬件问题吗 这样的标题一定不能出现: 啊啊啊啊啊为什么我的板子又不行了 为什么我的代码不能运行了 为什么我的屏幕黑屏了 【MaixPy 提问】 收到了开发板，开发板屏幕是红的，一行小字，为什么呢？ 我运行xxx程序，出了问题 可以这样问： 【MaixPy 提问】 我的板子在我接反电源后，现在板子无法启动，怎么判断板子哪里烧毁了，如果可以，怎么救活呢 【MaixPy BUG】 pix_to_ai 没有对最后一个像素进行转换 内容 首先站在回答者的角度， 如果被问问题: 首先要知道对方要做什么，实现什么目标 为了实现这个目标，他是参考了哪里的步骤做的 实际上采用了哪些具体的步骤，然后在那一步出现了问题， 方便我照着他的步骤去尝试复现一下现象。如果这个问题看起来不好解决，又没有复现的步骤，那可能要花很多时间去复现，先放一放先解决其它问题吧 具体出现的问题是什么，如果他只说出了问题，我怎么知道他出了什么问题，也许是身体不适？所以这很重要，需要让他说明出问题时的现象，并指明与预期有什么不同，不然我还得去猜去对比和预期有什么不同，解决问题的时长又增加了 出问题了，我可能需要他的日志文件，方便我根据日志去看源码等进行分析，不然可能会很难解决问题，那这个问题可以放到后面慢慢看吧 综上， 可以这么提问： 详细阐明自己的目标，想做什么事情， 现象应该是什么样的 我有没有参考哪里的文档、代码或者教学 如何复现错误：具体怎么做的， 每一个步骤写详细，直到问题出现 详细阐述错误出现时的现象，以及和期望的相比哪里不一样，需要证明问题确实出现了 附带日志文件，以及截图，甚至是视频，日志和截图一定要完整，不要只截取一小部分，回答者可能会从你的完整日志和截图中发现一些你没注意到的问题，这很重要！ 另外，粘贴代码注意格式，别粘贴后显示很乱，无法入目，尽量能复制后 直接能运行 最后，对解答问题的社区朋友们表达感谢 错误提问实例 正确提问实例 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"develop_kit_board/get_hardware.html":{"url":"develop_kit_board/get_hardware.html","title":"开发板选购指南(对比)","keywords":"","body":"如何选购开发板 要开始使用 MaixPy, 必须需要一款 K210 开发板, 可以从 Sipeed 官方淘宝店获得心仪的硬件： Sipeed 官方淘宝店 需要的硬件 一款开发板 由于 MaixPy 早期产品线比较多，具体开发板及参数列表如下，用户可以根据自己的动手能力和需求选购对应开发板 MaixPy 系类开发板板载的 ROM 均为 16MB SPI FLASH, RAM: 6MB(通用) + 2MB(KPU 专用) MaixPy 系列开发板 描述 实物图 说明 Maix Amigo 点击购买 Maix Amigo 3.5寸 大屏幕， 预留三个 Grove 接口，三个 SPMOD 接口(其中一个为游戏手柄接口) Maix Cube 点击购买 Maix Cube 迷你开发板，引出 Grove/Spmod 接口 Maix Dock(M1W) 点击购买 Maix Dock(M1W) 全引脚引出，采用 M1W 模块 (内部集成 ESP8285) Maix Dock(M1) 点击购买 Maix Dock(M1) 全引脚引出，采用 M1 模块 Maix Bit 点击购买 Maix Bit 全引脚引出，2x20pin，最小系统板 Maix Duino 点击购买 Maix Duino 兼容 Arduino，支持 ESP32 WIFI，支持 ESP32 5个 ADC 通道的读取 Maix GO 点击购买 Maix GO 已停产 Maix Nano 点击购买 Maix Nano 核心开发板 开发板详细资料请看 Wiki, 选择一款合适自己的开发板～ USB Type-C 连接线 选用 Type-C 是因为它支持正反插，对开发十分友好 从淘宝官方购买可以询问是否附送，目前大部分安卓机也在使用 Type-C 连接线 屏幕 从淘宝官方购买可以询问是否包含, 推荐用户购买带 LCD 的板子或者套餐,方便后续运行程序时结果的直观展示, 板型 屏幕驱动 IC 屏幕分辨率 是否支持触摸 备注 Maix Cube(IPS) ST7789 240*240 不支持 --- Maix Amigo ILI9486 320*480 支持(FT6X36) --- Maix Amigo(IPS 版) ILI9486 320*480 支持(FT6X36) --- Maix Nano(不带屏幕) --- --- --- --- Maix Dock ST7789 320*240 不支持 --- Maix Bit ST7789 320*240 不支持 --- Maix Dock ST7789 320*240 不支持 --- Maix Go ST7789 320*240 支持(FT6X36) --- 摄像头 在售的有：OV2640（常规，M12）、OV7740、GC0328； 由于 K210 DVP 接口支持的分辨率为 VGA（640*480 30W）， 所以实际使用选取 30W 像素的摄像头即可。 截至 MaixPy 固件版本: MaixPy 0.5.0_160 ,支持的摄像头型号如下表 型号 设备 id 像素 说明 备注 OV2640 0x2642 200W 支持度较好 OV7740 0x7742 30W 支持度较好 OV3660 0x3660 300W 兼容运行 GC0328 0x9d 30W 支持度较好 GC2145 0x2145 200W 兼容运行 MT9D111 0x1519 200W 可以运行，支持不完整 OV5640 0x5640 500W 完整实现,支持自动变焦 --- 截止至固件版本 MicroPython v0.5.0-173 相关摄像头测试情况如下: 硬件型号 测试通过的单目或双目摄像头 M1/M1W 模组系列（Maixduino、Dock、Go） OV2640、GC0328、OV7740、GC2145、OV5640 M1n 模组系列（Nano、Cube） OV2640、GC0328、OV7740、GC2145、OV5640 MaixBit OV2640、GC0328、OV7740、GC2145、OV5640 Maix Amigo OV7740（后摄）、GC0328（前摄） 目前摄像头的颜色模式 YUV422 RGB565 & YUV422 OV2640 OV5640 OV7740 GC2145 GC0328 --- 从淘宝官方购买可以询问型号, OV7740 帧率相对高一点; OV2640 比较古老, 画质稍不如 GC0328 注：很多用户一上来就问哪款支持的帧率最高，其实帧率除了硬件上会有差异，而且在你使用的程序，由于程序的处理流程不同，帧率也是会有差异的，所以这里无法标注（以免误导用户）具体最高帧率。 Micro SD 卡 (TF 卡) (可选) 不使用 Micro SD 卡也是可以操作文件的, 在内部 Flash 上已经保留一部分来作为文件系统了, 只是 Flash 速度很慢！ 为了方便图片文件快速操作, 可以选择购买一张 Micro SD 卡, 　 MaixPy　内置了 SPI SD卡协议驱动, 购买时尽量选择速度快协议新的 Micro SD 卡, 比如 SD 2代协议, Class10 的内存卡 因为 K210 没有 SDIO 硬件外设, 所以使用了 SPI 来与 SD 卡通信, 当然, 市面上的 SD 卡品质参差不齐, SPI 模式不一定都能兼容, 尽量买正规的卡, 实在有需求请自行定制驱动～～ 比如：下图左边两张卡 MaixPy 的驱动不支持, 中间和右边的都支持, 但是中间的 class10 卡速度最快(最高测过 128GB可用) 另外测试过网上购买的几张闪迪、金士顿、三星的卡, 其中发现有一张三星的卡无法使用 Sipeed 官方店 SD 卡购买链接 ST-Link (用来给开发板 Maix Go 上的 STM32 更新固件) (可选) 如果购买的是 Maix Go, 上面集成了一颗 STM32 芯片, 用来模拟 USB转串口 工具, 以及模拟 JTAG, 如果想后期自行更新其固件, 建议购买一个 ST-Link 备用; 如果不需要JTAG 功能可以不用购买 JTAG 调试器 (可选) 注意： !!! 烧录过 ken_gen.bin 之后将永久禁用 K210 的 JTAG 调试功能 K210 这款芯片支持 JTAG 调试, 如果需要调试功能, 需要使用 JTAG 调试器, 请在 Sipeed 官方淘宝店咨询购买。 如果是 Maix Go 开发板, 可以不用另外购买 JTAG 调试器, Maix Go 开发板上面集成了一个 STM32芯片, 可以模拟 JTAG(STM32 使用 CMSIS-DAP 或者 open-ec 固件), open-ec 固件目前还不支持, 后续会支持, 请以 open-ec github 项目主页说明为准 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"develop_kit_board/maix_dock.html":{"url":"develop_kit_board/maix_dock.html","title":"Maix Dock","keywords":"","body":"Maix Dock 项目 说明 CPU: 双核 64bit RISC-V / 400MHz* (双精度FPU集成) 内存: 8MiB 64bit 片上 SRAM 存储: 16MiB Flash, 支持 micro SDXC 拓展存储 (最大128GB**) 屏幕（套餐）: 2.4 寸 TFT, 电容触摸屏幕分辨率: 320*240 摄像头（套餐）: 30W 像素 GC0328 摄像头 WIFI: MaixDock(M1W) 采用 M1W（内部集成 ESP8285 WIFI SOC）； MaixDock(M1W) 内部无 WIFI 功能 外观一览 MaixDock(M1W) MaixDock(M1) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"develop_kit_board/maix_bit.html":{"url":"develop_kit_board/maix_bit.html","title":"Maix Bit","keywords":"","body":"Maix Bit 开发板配置： 项目 说明 CPU: 双核 64bit RISC-V / 400MHz (双精度FPU集成) 内存: 8MiB 64bit 片上 SRAM 存储: 16MiB Flash, 支持 micro SDXC 拓展存储 (最大128GB**) 屏幕(套餐): 2.4 寸 TFT, 电容触摸屏幕分辨率: 320*240 摄像头(套餐): 200W 像素(实际使用 30W)，0V2640 型号 M12 摄像头 外观一览 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"develop_kit_board/maix_amigo.html":{"url":"develop_kit_board/maix_amigo.html","title":"Maix Amigo","keywords":"","body":"MaixAmigo 概述 SIPEED MaixAmigo 可开发编程学习套件, MaixAmigo 在硬件上集成前后各 30W 像素摄像头、可扩展 TF 卡槽、用户按键、3.5‘TFT 寸显示屏、520mAh 锂电池、扬声器,麦克风、SPMOD,GROVE 扩展接口等。 软件上 MaixAmigo 默认搭载 MaixPy, 用户可以非常轻松的使用 MicroPython 语法快速进行人脸识别、物体分类等多种 AIoT 开发，同时还预留开发调试接口，也能将其作为一款功能强大的 AI 学习开发板。 MaixAmigo 外观及功能介绍 外观一览 板载硬件功能介绍 项目 说明 CPU: 双核 64bit RISC-V / 400MHz* (双精度FPU集成) 内存: 8MiB 64bit 片上 SRAM 存储: 16MiB Flash, 支持 micro SDXC 拓展存储 (最大128GB**) 屏幕: 3.5寸 TFT 显示屏, 分辨率: 320*480, 支持电容触摸(FT6X36) 摄像头: OV7740 (后摄)与GC0328(前摄) 各 30W 像素(最大分辨率 VGA:640*480) 电池: 板载可充电锂聚合物电池 (容量520mAh ) 板载扬声器与麦克风 集成单音频控制器 ES8374 1W 8Ω 扬声器 板载接口: USB-C *2 (K210 调试供电接口+兼容 STM32 核心板 USB 接口) Grove *3 & SPMOD*3 (可拓展模块) 三轴加速度传感器: MSA301 电池: 520mAh 锂电池 硬件板载扩展接口 MaixAmigo 对用户开放了两个高度扩展的接口: SP-MOD 与 Grove 接口, 用户可以很方便的进行 DIY SP-MOD 接口 SP-MOD 即为 sipeed module, simplify PMOD, super module 接口 接口描述 SP-MODE 接口描述 硬件接口(举例) MaixAmigo 板载了三个 SPMOD 接口 PIN\\NO. SP-MOD1 SP-MOD2 SP-MOD3(游戏手柄) 1 GND GND GND 2 12 29 --- 3 6 28 --- 4 24 22 IO24 5 27 25 IO27 6 10 30 --- 7 11 8 --- 8 3V3 3V3 3V3 Grove 接口 Grove 模块接口 Grove 接口的线缆有 4 种颜色，用户可以根据颜色快速区别 Pin 颜色 描述 1 黄色 (例如, I2C Grove Connectors 上的SCL) 2 白色 (例如, I2C Grove Connectors 上的SDA) 3 红色 VCC (所有的Grove接口红色都是VCC) 4 黑色 GND (所有的Grove接口黑色都是GND) MaixAmigo 板载了三个 GROVE 接口 PIN GROVE 1 GROVE 2 GROVE 3 1 GND GND GND 2 3V3 3V3 3V3 3 IO5 IO3 IO1 4 IO4 IO2 IO0 板载 I2C 设备 MaixAmigo 板载 I2C 传感器/IC IC 设备 id I2C 地址(7位地址) 配置：SCL: IO_24, SDA: IO_27 --- I2C Address MaixPy 读取地址 ES8374 0x08 0x10 D(16) MSA301 0x13 0x26 D(38) AXP173 0x68 0x34 D(52) 上手把玩 MaixAmigo 同样使用 MaixPy 入门 AIoT ，由于硬件特殊性，请在配置 amigo 硬件 后再使用 MaixPy 。 而在开发之前我们需要了解并准备相关工具，以减少我们后边因为准备不足而走的坑路 上手步骤: 下载需要的驱动，软件 开发板连接电脑，并安装 USB 驱动 更新最新固件 下载并打开最新的 MaixPy IDE MaixPy IDE 连接开发板 运行 MaixPy 示例程序 软硬件准备 硬件准备: 电脑一台 MaixAmigo 开发板 可靠的 USB Type-C 数据线一条: 注意一定要可靠的数据线 软件准备: USB 驱动: FT2232 ->下载链接点这里 Kflash_gui: https://dl.sipeed.com/MAIX/tools/kflash_gui MaixPy IDE : https://dl.sipeed.com/MAIX/MaixPy/ide/_/v0.2.5 例程程序库: https://github.com/sipeed/MaixPy_scripts 安装驱动 我们在拿到 Maix Amigo 并连接到电脑的时候，可以打开设备管理器查看串口驱动是否已经安装，打开设备管理器的方法有: 此电脑(右键) -> 属性 -> 设备管理器 开始菜单(右键) -> 设备管理器 控制面板 -> (搜索)设备管理器 当我们的系统是 Win10 系统，系统则会帮我们自动安装驱动，而如果是旧版 Win7，win8 系统我们就需要自己手动安装: 打开上一节的的链接下载驱动 点击安装 安装完成之后，可以在设备管理器看到已经识别到两个串口设备了 更新固件到最新版 用户拿到开发板之后，板载的固件默认或许已经不是最新版的，那么在使用过程中会存在或多或少的 bug， 我们这时候就需要更新固件版本到最新版本 更新方法查看: 更新固件 运行第一个程序 Hello World LCD 实时预览 Camera # -*- coding: UTF-8 -*- import sensor, image, time, utime, lcd from machine import I2C from fpioa_manager import fm from Maix import GPIO ''' 说明: 该例程为 Amigo 前后摄像头切换的 example. 注意事项: 由于 Amigo 电源管理电路的设计 需要配置 PMU AXP173 的输出电压, 才可以正常使用摄像头 ''' # ------------- try: from machine import I2C axp173 = I2C(I2C.I2C3, freq=100000, scl=24, sda=27) axp173.writeto_mem(0x34, 0x27, 0x20, mem_size=8) axp173.writeto_mem(0x34, 0x28, 0x0C, mem_size=8) axp173.writeto_mem(0x34, 0x36, 0xCC, mem_size=8) del axp173 except Exception as e: print(e) lcd.init(freq=20000000) while True: try: sensor.reset(choice=1) sensor.set_pixformat(sensor.YUV422) sensor.set_framesize(sensor.QVGA) sensor.skip_frames(time=2000) for i in range(50): img = sensor.snapshot() lcd.display(img) except Exception as e: print(e) try: sensor.reset(choice=2) sensor.set_pixformat(sensor.YUV422) sensor.set_framesize(sensor.QVGA) sensor.skip_frames(time=2000) for i in range(50): img = sensor.snapshot() lcd.display(img) except Exception as e: print(e) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"develop_kit_board/maix_duino.html":{"url":"develop_kit_board/maix_duino.html","title":"Maix Duino","keywords":"","body":"MaixDuino 开发板 概述 SIPEED MaixDuino 是基于我们 M1 模块(主控:Kendryte K210)开发的一款外形兼容 Arduino 的开发板 MaixDuino 集成摄像头、TF卡槽、用户按键、TFT显示屏、MaixDuino 扩展接口等, 用户可使用 MaixDuino 轻松搭建一款人脸识别门禁系统, 同时还预留开发调试接口, 也能将其作为一款功能强大的 AI 学习开发板. MaixDuino 外观及功能介绍 外观一览 引脚一览 板载功能介绍 项目 说明 CPU: 双核 64bit RISC-V / 400MHz* (双精度FPU集成) 内存: 8MiB 64bit 片上 SRAM 存储: 16MiB Flash, 支持 micro SDXC 拓展存储 (最大128GB**) 屏幕（套餐）: 2.4 寸 TFT, 电容触摸屏幕分辨率: 320*240 摄像头（套餐）: 30W 像素 GC0328 摄像头 电源输入 DC05: 6~12V 直流 电源输入 + 程序下载调试接口: USB Type-C 接口 DVP 24PIN: 标准 Camera DVP 24PIN 接口 TF 扩展槽: ESP32: ESP32 SPI 连接(ESP32 支持 WIFI 与 蓝牙) I2C DAC PA PAM8403A MaixDuino 引脚图 资料相关链接 MaixDuino 原理图 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"develop_kit_board/maix_cube.html":{"url":"develop_kit_board/maix_cube.html","title":"Maix Cube","keywords":"","body":"MaixCube 外观及功能介绍 概述 SIPEED MaixCube 可开发编程学习套件, MaixCube 在硬件上集成 30W 摄像头、可扩展 TF 卡槽、用户按键、IPS 1.3 寸显示屏、200mAh 锂电池、扬声器,麦克风、SPMOD,GROVE 扩展接口等。 软件上 MaixCube 默认搭载 MaixPy, 用户可以非常轻松的使用 MicroPython 语法快速上手 AI IoT 开发，开发人脸识别，物体识别等 AI 应用，同时还预留开发调试接口，也能将其作为一款功能强大的 AI 学习开发板。 MaixCube 外观及功能介绍 外观一览 1.3 寸 IPS 屏幕: 分辨率 240*240 复位按键 电源按键: 短按开机，长按 8S 关机 Grove 接口: Grove 数字接口，传感器，控制器扩展无限可能~ SP-MOD 接口: 搭载更加强大，更高扩展性的 SP-MOD 数字接口，I2C，SPI(标准，双线，四线模式)等接口均可以使用 TF 卡槽: 多媒体资源扩展，支持大容量储存 摄像头: 搭载 0V7740 30W 像素 Sensor Type-C 接口: 三向按键: 板载功能介绍 电源管理控制单元: AXP173 板载 200mAh 锂电池，支持用户充放电控制 音频驱动 IC: ES8374 支持音频录制，播放 三轴加速度传感器: MSA301 Camera OV7740: 1.3 IPS LCD: RGB: 板载两颗 RGB LED USB Type-C:Type-C 接口，正反盲插 板载扩展接口 Maix Cube 对用户开放了两个高度扩展的接口: SP-MOD 与 Grove 接口， 用户可以很方便的进行 DIY SP-MOD 接口 SP-MOD 即为 sipeed module，simplify PMOD，super module 接口 接口描述 SP-MODE 接口描述 硬件接口 Grove 接口 Grove 模块接口 Grove 接口的线缆有 4 种颜色，用户可以根据颜色快速区别 --- 颜色 描述 pin 1 黄色 (例如，I2C Grove Connectors上的SCL) pin 2 白色 (例如，I2C Grove Connectors上的SDA) pin 3 红色 VCC (所有的Grove接口红色都是VCC) pin 4 黑色 GND (所有的Grove接口黑色都是GND) Grove模块主要有 4 种接口: Grove Digital 数字接口: Grove 数字接口由 Grove 插头的四条标准线组成. 两条信号线通常称为 D0 和 D1 . 大多数模块只使用D0，但有些(像LED Bar Grove显示屏)使用两者.通常核心板会将板卡上的第一个Grove连接头称为D0，第二个称为D1.第一个接头会连接到主控芯片的DO/D1管脚，第二个连接头会连接到主控芯片的D1/D2引脚，后面的连接头以此类推. pin Function Note pin1 Dn 第一个数字输入 — pin2 Dn+1 第二个数字输入 — pin3 VCC 供电引脚 5V/3.3V — pin4 GND 地 — Grove UART : The Grove UART 是特殊的一种数字输入输出接口. 它使用引脚 1 和引脚 2 进行串行输入和发送. 引脚1是 RX 线(用于接收数据，因此是输入)， 其中引脚 2 是 TX 线(用于向 Grove 模块传输数据). pin Function Note pin1 RX 串行接收 pin2 TX 串行发送 pin3 VCC 供电引脚 5V/3.3V pin4 GND 地 Grove I2C: 有许多类型的I2C Grove 传感器可用.MaixCube 上的 Grove 只支持 3.3V 传感器 Grove I2C 连接器具有标准布局.引脚 1 是SCL信号，引脚 2 是SDA信号 pin Function Note pin1 SCL I2C 时钟 pin2 SDA I2C 数据 pin3 VCC 供电引脚，5V/3.3V pin4 GND 地 板载 I2C 设备 MaixCube 板载 I2C 传感器/IC IC 设备 id I2C 地址(7位地址) 配置：SCL: IO_30，SDA: IO_31 --- I2C Address MaixPy 读取地址 ES8374 0x08 0x10 D(16) MSA301 0x13 0x26 D(38) AXP173 0x68 0x34 D(52) 上手把玩 由于 MaixCube 出厂自带 GUI 演示界面和示例程序，所以在拿到板子时可以先上手把玩下预设程序， 在之后那么我们就开始以 MaixCube 上手，借助 MaixPy 入门 AIoT. 而在开发之前我们需要了解并准备相关工具，以减少我们后边因为准备不足而走的坑路 上手步骤: 下载需要的驱动，软件 开发板连接电脑，并安装 USB 驱动 更新最新固件 下载并打开最新的 MaixPy IDE MaixPy IDE 连接开发板 运行 MaixPy 示例程序 软硬件准备 硬件准备: 电脑一台 MaixCube 开发板 可靠的 USB Type-C 数据线一条: 注意一定要可靠的数据线 软件准备: USB 驱动: FT2232 ->下载链接点这里 Kflash_gui: https://dl.sipeed.com/MAIX/tools/kflash_gui MaixPy IDE : https://dl.sipeed.com/MAIX/MaixPy/ide/_/v0.2.5 例程程序库: https://github.com/sipeed/MaixPy_scripts 安装驱动 我们在拿到 Maix Cube 并连接到电脑的时候，可以打开设备管理器查看串口驱动是否已经安装，打开设备管理器的方法有: 此电脑(右键) -> 属性 -> 设备管理器 开始菜单(右键) -> 设备管理器 控制面板 -> (搜索)设备管理器 当我们的系统是 Win10 系统，系统则会帮我们自动安装驱动，而如果是旧版 Win7，win8 系统我们就需要自己手动安装: 打开上一节的的链接下载驱动 点击安装 安装完成之后，可以在设备管理器看到已经识别到两个串口设备了 更新固件到最新版 用户拿到开发板之后，板载的固件默认或许已经不是最新版的，那么在使用过程中会存在或多或少的 bug， 我们这时候就需要更新固件版本到最新版本 更新方法查看: 更新固件 运行第一个程序 Hello World LCD 实时预览 Camera import sensor, image, time, lcd sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.skip_frames(time = 2000) sensor.set_hmirror(1) sensor.set_vflip(1) clock = time.clock() lcd.init(type=2) lcd.rotation(2) while(True): clock.tick() img = sensor.snapshot() print(clock.fps()) img.draw_string(60, lcd.height()-120, \"fps:\"+str(clock.fps()), lcd.GREEN, scale=2) lcd.display(img) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"develop_kit_board/maix_go.html":{"url":"develop_kit_board/maix_go.html","title":"Maix Go","keywords":"","body":"Maix Go 板载功能介绍 项目 说明 CPU: 双核 64bit RISC-V / 400MHz* (双精度FPU集成) 内存: 8MiB 64bit 片上 SRAM 存储: 16MiB Flash, 支持 micro SDXC 拓展存储 (最大128GB**) 屏幕: 2.4 寸 TFT, 电容触摸屏幕分辨率: 320*240 摄像头(套餐): 200W 像素(实际使用 30W)，0V2640 型号 M12 摄像头 外观一览 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"develop_kit_board/maix_nano.html":{"url":"develop_kit_board/maix_nano.html","title":"Maix Nano","keywords":"","body":"Maix Nano 项目 说明 CPU: 双核 64bit RISC-V / 400MHz* (双精度FPU集成) 内存: 8MiB 64bit 片上 SRAM 存储: 16MiB Flash, 支持 micro SDXC 拓展存储 (最大128GB**) 屏幕: 无屏幕 摄像头（套餐）: 30W 像素 GC0328 摄像头 Maix Nano 硬件板载扩展接口 Maix Nano 预留了一个 SPMOD 接口 SP-MOD 接口 SP-MOD 即为 sipeed module, simplify PMOD, super module 接口 接口描述 SP-MODE 接口描述 硬件接口 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"modules/grove/":{"url":"modules/grove/","title":"Grove","keywords":"","body":"powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"modules/others/":{"url":"modules/others/","title":"其它","keywords":"","body":"powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/knowledge_micropython.html":{"url":"get_started/knowledge_micropython.html","title":"MaixPy 语法基础知识","keywords":"","body":"MicroPython 背景知识 由于 MaixPy 是基于 MicroPython 之上进行开发构建的, 提供给用户最终的接口是 Micropython ,所以在使用 MaixPy 开发之初我们需要熟悉下 MicroPython 的语法 不用考虑内存的申请和释放,有很多 MicroPython 库可以直接用(并不直接兼容 PC 上的 Python 模块) Python, 是一个很常用的语言, 在图像处理, 机器学习, 网络编程中都使用非常广.而且 Python 是一个非常容易上手的语言, 如果你有其他语言编程基础(例如C, C++, Java), 会更容易上手. 如果之前有 C/C++/Java (或任何其他语言)的编程经验, 推荐 《廖雪峰的 Python 教程》 如果之前没有任何编程经验, 推荐 《笨方法学 Python 》 REPL 和 串口 首先, 断开开发板 与 MaixPy IDE 的连接, 否则串口会冲突！ 打开 MaixPy IDE 中的终端窗口 print('The quick brown fox', 'jumps over', 'the lazy dog') 输出: The quick brown fox jumps over the lazy dog print() 会依次打印每个字符串, 遇到逗号“,”会输出一个空格, 因此, 输出的字符串是这样拼起来的: The quick brown fox jumps over the lazy dog print() 也可以打印整数, 或者计算结果: print(300) 300 print(100 + 200) 300 因此, 我们可以把计算100 + 200的结果打印得更漂亮一点: print('100 + 200 =', 100 + 200) 100 + 200 = 300 注意, 对于 100 + 200, Python 解释器自动计算出结果 300, 但是, '100 + 200 =' 是字符串而非数学公式, Python 把它视为字符串. 变量 在 Python 中, 等号 = 是赋值语句, 可以把任意数据类型赋值给变量, 同一个变量可以反复赋值, 而且可以是不同类型的变量, 例如: a = 123 # a是整数 print(a) a = 'ABC' # a变为字符串 print(a) 这种变量本身类型不固定的语言称之为动态语言, 与之对应的是 静态语言. 静态语言在定义变量时必须指定变量类型, 如果赋值的时候类型不匹配, 就会报错.例如 Java 是静态语言, 赋值语句如下(// 表示注释): int a = 123; // a是整数类型变量 a = \"ABC\";// 错误:不能把字符串赋给整型变量 和静态语言相比, 动态语言更灵活, 就是这个原因. list 列表 Python 内置的一种数据类型是列表: list. list 是一种有序的集合, 可以随时添加和删除其中的元素. 比如, 列出班里所有同学的名字, 就可以用一个 list 表示: classmates = ['Michael', 'Bob', 'Tracy'] classmates ['Michael', 'Bob', 'Tracy'] 变量 classmates 就是一个 list. 用 len() 函数可以获得list元素的个数: len(classmates) 3 用索引来访问 list 中每一个位置的元素, 索引是从 0 开始的: classmates[0] 'Michael' classmates[1] 'Bob' classmates[2] 'Tracy' classmates[3] Traceback (most recent call last): File \"\", line 1, in IndexError: list index out of range 当索引超出了范围时, Python 会报一个 IndexError 错误, 所以, 要确保索引不要越界, 记得最后一个元素的索引是 len(classmates) - 1. 如果要取最后一个元素, 除了计算索引位置外, 还可以用 -1 做索引, 直接获取最后一个元素: classmates[-1] 'Tracy' 以此类推, 可以获取倒数第2个、倒数第3个: classmates[-2] 'Bob' classmates[-3] 'Michael' classmates[-4] Traceback (most recent call last): File \"\", line 1, in IndexError: list index out of range 当然, 倒数第4个就越界了. list 是一个可变的有序表, 所以可以往list中追加元素到末尾: classmates.append('Adam') classmates ['Michael', 'Bob', 'Tracy', 'Adam'] 也可以把元素插入到指定的位置, 比如索引号为1的位置: classmates.insert(1, 'Jack') classmates ['Michael', 'Jack', 'Bob', 'Tracy', 'Adam'] 要删除list末尾的元素, 用pop()方法: classmates.pop() 'Adam' classmates ['Michael', 'Jack', 'Bob', 'Tracy'] 要把某个元素替换成别的元素, 可以直接赋值给对应的索引位置: classmates[1] = 'Sarah' classmates ['Michael', 'Sarah', 'Tracy'] list里面的元素的数据类型也可以不同, 比如: L = ['Apple', 123, True] 如果一个list中一个元素也没有, 就是一个空的list, 它的长度为0: L = [] len(L) 0 tuple 元组 另一种有序列表叫元组: tuple. tuple 和 list 非常类似, 但是 tuple 一旦初始化就不能修改, 比如同样是列出同学的名字: classmates = ('Michael', 'Bob', 'Tracy') 现在, classmates 这个 tuple 不能变了, 它也没有 append(), insert() 这样的方法.其他获取元素的方法和 list 是一样的, 你可以正常地使用 classmates[0], classmates[-1], 但不能赋值成另外的元素. 不可变的 tuple 有什么意义?因为 tuple 不可变, 所以代码更安全. 如果可能, 能用 tuple 代替 list 就尽量用 tuple. tuple 的陷阱:当你定义一个 tuple 时, 在定义的时候, tuple 的元素就必须被确定下来, 比如: t = (1, 2) t (1, 2) 但是, 要定义一个 只有1个元素的 tuple, 如果你这么定义: t = (1) t 1 但此时,定义的不是 tuple, t 是整型变量, 变量 t 的值为1! 这是因为括号()既可以表示tuple, 又可以表示数学公式中的小括号, 这就产生了歧义, 因此, Python规定, 这种情况下, 按小括号进行计算, 计算结果自然是1. 所以, 只有 1 个元素的 tuple 定义时必须加一个逗号,, 来消除歧义: t = (1,) t (1,) Python在显示只有 1 个元素的 tuple 时, 也会加一个逗号,, 以免你误解成数学计算意义上的括号. 条件判断 if 语句的完整形式是: if : elif : elif : else: 比如: age = 20 if age >= 6: print('teenager') elif age >= 18: print('adult') else: print('kid') 循环 Python 的循环有两种, 一种是 for...in 循环, 依次把 list 或 tuple 中的每个元素迭代出来, 看例子: names = ['Michael', 'Bob', 'Tracy'] for name in names: print(name) 执行这段代码, 会依次打印 names 的每一个元素: Michael Bob Tracy 所以 for x in ... 循环就是把每个元素代入变量x, 然后执行缩进块的语句. 如果要计算 1-100 的整数之和, 从 1 写到 100 有点困难, 幸好 Python提供一个 range() 函数, 可以生成一个整数序列, 再通过 list() 函数可以转换为 list. 比如 range(5) 生成的序列是从 0 开始小于 5 的整数: list(range(5)) [0, 1, 2, 3, 4] range(101) 就可以生成 0-100 的整数序列, 计算如下: sum = 0 for x in range(101): sum = sum + x print(sum) 第二种循环是 while 循环, 比如我们要计算 100 以内所有奇数之和, 可以用 while 循环实现: sum = 0 n = 99 while n > 0: sum = sum + n n = n - 2 print(sum) 数据类型转换 Python 内置的常用函数还包括数据类型转换函数, 比如 int() 函数可以把其他数据类型转换为整数: >>> int('123') 123 >>> int(12.34) 12 >>> float('12.34') 12.34 >>> str(1.23) '1.23' >>> str(100) '100' >>> bool(1) True >>> bool('') False 函数 在 Python 中, 定义一个函数要使用 def 语句, 依次写出函数名、括号、括号中的参数和冒号:, 然后在缩进块中编写函数体, 函数的返回值用 return 语句返回. 我们先写一个计算 x2 的函数: def power(x): return x * x 对于 power(x) 函数, 参数 x 就是一个位置参数. 当我们调用 power 函数时, 必须传入有且仅有的一个参数x: power(5) 25 power(15) 225 现在, 如果我们要计算 x3 怎么办?可以再定义一个 power3 函数, 但是如果要计算x4、x5……怎么办?我们不可能定义无限多个函数. 你也许想到了, 可以把 power(x) 修改为 power(x, n), 用来计算 xn , 说干就干: def power(x, n): s = 1 while n > 0: n = n - 1 s = s * x return s 对于这个修改后的power(x, n)函数, 可以计算任意n次方: power(5, 2) 25 power(5, 3) 125 修改后的 power(x, n) 函数有两个参数: x 和 n, 这两个参数都是位置参数, 调用函数时, 传入的两个值按照位置顺序依次赋给参数x和n. 切片 取一个 list 或 tuple 的部分元素是非常常见的操作.比如, 一个list 如下: L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack'] 取前3个元素, 用一行代码就可以完成切片: L[0:3] ['Michael', 'Sarah', 'Tracy'] L[0:3] 表示, 从索引 0 开始取, 直到索引 3 为止, 但不包括索引3.即索引0, 1, 2, 正好是3个元素. 如果第一个索引是0, 还可以省略: L[:3] ['Michael', 'Sarah', 'Tracy'] 也可以从索引1开始, 取出2个元素出来: L[1:3] ['Sarah', 'Tracy'] tuple 也是一种 list, 唯一区别是 tuple 不可变.因此, tuple 也可以用切片操作, 只是操作的结果仍是 tuple: (0, 1, 2, 3, 4, 5)[:3] (0, 1, 2) 字符串 'xxx' 也可以看成是一种 list, 每个元素就是一个字符.因此, 字符串也可以用切片操作, 只是操作结果仍是字符串: 'ABCDEFG'[:3] 'ABC' 对象 Python 是面向对象编程的, 比如一个 LED 灯 from pyb import LED red_led = LED(1) red_led.on() LED 是一个类, red_led 就是一个对象, 可以对这个对象进行操作, 比如点亮 on, 关掉 off, 查看 value. 模块 什么是模块? 随着代码的增多，在一个文件里的代码会越来越长，越来越难看懂。 为了编写可维护的代码，我们把很多函数分组，放到不同的文件里。在Python 中，一个 .py 文件就称之为一个模块(Module). 模块有什么好处? 复用代码方便！如果我写了一个模块，你也写了一个模块，我们就有了两个模块。我们把这些模块都组织起来，大家就可以少写很多代码了！ 在 MaixPy 中如何使用模块? from machine import GPIO import time LED_RED = GPIO(GPIO.GPIOHS0, GPIOHS.PP_OUT) LCD_RED.value(0) time.sleep_ms(500) LCD_RED.value(1) time.sleep_ms(500) import time 就是引入 time 这个模块。通过 import 语句，就可以引入模块。 还有 from xxx import ooo 的语句，意思是通过 xxx 模块引入 ooo类，或者通过 xxx 模块引入 ooo 函数。比如上面的程序可以写成: python powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/knowledge_git_github.html":{"url":"get_started/knowledge_git_github.html","title":"git 和 github","keywords":"","body":"git 和 github 介绍 因为在学习 MaixPy 的过程中， 有很多地方用到 git 和 github， 所以这里简单解释一下它们是什么，以及区别是什么。 什么是 git git 是一款 代码托管 软件， 用来管理代码的版本。 比如： 我今天改了代码， 然后明天也改了代码， 以后我都能看到这两次改动历史， 以及改了什么内容，可以精确到哪一行，方便后面找问题; 或者我发现第二次提交的代码出现了问题， 我需要回到第一次提交后的版本， 都可以用这个工具实现; 另外方便多个人修改同一份代码，能管理大家提交的代码，不容易出现混乱。 再也不用拷贝无数个文件夹来备份修改了！ git 会在目录下创建一个.git隐藏文件夹， 所有更改记录保存在这里面，不能删除这个文件夹。 但是需要注意的是， 现在的 git 主要用来管理文本文件， 不适用拿来管理二进制文件，比如图片 PDF等等， 会让文件夹占用的空间变得很大。 具体的教程，可以看 这里, 中文教程可以看 这里 什么是 github github 是一个 分享代码 的 网站。 可以在这个网站上注册， 然后建立仓库（repository），往这个仓库里面放代码公开分享，让更多地人来使用， 甚至一起修改，一起优化代码， 这就是开源。 每个仓库都是可以单独地使用 git 这个软件来管理的， 大家在自己的电脑上修改代码， 然后使用git提交， 然后使用git推送到github这个网站， 大家就可以看到新的内容了。 MaixPy 的源码的地址是： https://github.com/sipeed/maixpy , 也就是一个 git 仓库。 github 的帮助, 中文 帮助 另外，国内也有几家不过的类似github的网站， 比如gitee git 和 github 的区别 一个是一个软件， 一个是一个网站。 只不过这个网站用到了 git 这个技术来管理仓库。 为什么我无法访问 github， 或者访问速度很慢 github 是国外的网站， 因为距离远，线路问题导致某些运营商的某些线路可能访问慢甚至无法访问， 比如 github 用来存放源文件的域名 https://raw.githubusercontent.com/ 可能无法访问 解决方法： 换个线路， 也就是换个网络， 比如你用电信网， 可以换移动或者联通试试， 换手机流量，或者换个地方等方法 使用 VPN 类软件，这里不教，请注意合法使用 什么是 star 在 github 上， 每个公开的仓库大家都可以去点赞收藏，也就是 star，在 github 右上角 ⭐ 形状的按钮 如果你觉得项目不错，请给个 star，这样会鼓励开发者花更多时间维护仓库，同时也告诉第一次来的访问者这是个不错的项目，值得关注。 star 后， 可以在个人资料里面找到自己的 star 仓库，方便下一次找到 说到这里，大家觉得 MaixPy 不错的话，可以 star 一个哦～ 什么是 Master 分支 在每个仓库中， 可以存在很多个分支，不同分支可以有不同的代码，而且不同的分支之间还可以互相合并，方便保存代码的不同版本，以及方便团队合作， master 分支就是指主分支，也就是最重要的分支，通常仓库默认展示的就是 master 分支。 什么是提交 提交，英文叫commit， 就是每次更改仓库的代码， 都提交一次，就会被记录到提交历史记录里面，后面随时都可以看这次提交了什么内容，也可以将代码回滚到这次提交 每个提交都有一个独立的commit ID， 比如d28cb7ac7db5ad61c0738df95d733717deefda1d， 简写成d28cb7a 什么是子模块 子模块， 英文叫submodule， 就是在仓库中可以引用其它仓库，相当于是一个软链接， 不需要在仓库放实际的代码， 只需要放一个链接即可。 这样的好处是多个仓库可以分开管理， 比如仓库1引用了仓库2作为子模块， 如果仓库2代码更新了， 仓库1可以选择继续使用旧版的仓库2的代码， 也可以选择使用仓库2最新的代码，只是更新一下子模块链接 比如MaixPy用了kendryte-standalone-sdk作为子模块,看这里 可以看到这里文件夹的图标不太一样，它只是一个链接，点击就会跳到相应的仓库而不是直接打开文件夹 所以 MaixPy 使用了子模块 什么是克隆 在github上面的仓库，如果需要下载到本地来， 就需要使用克隆， 使用 git clone 地址 就可以吧仓库克隆到本地了， 克隆的本地的仓库名副其实就是 github 上面的一份克隆， 完全一样，也保留了历史记录等 当然也可以不用克隆，网页有点击下载的按钮，但是下载的缺陷就是不会包含提交代码的历史记录，根据自己的情况选择 需要注意的是， 在克隆包含有子模块的仓库时， 因为克隆默认只会将子模块的链接克隆下来， 子模块的代码没有克隆到本地， 你需要这样克隆 git clone 地址 --recursive 或者 git clone 地址 project_name cd project_name git submodule update --init --recursive 比如: git clone https://github.com/sipeed/MaixPy --recursive 什么是 issue 也就是问题的意思， 在github 上， 每个仓库有一个专门用来提问的地方， 比如 MaixPy的issue 大家在这里提问， 类似论坛一样， 都会被记录下来，方便后面的人查阅 什么是 fork 在 github 上， 仓库页面右上角有一个 fork 按钮 点击可以将仓库 fork 到自己的仓库，就相当于是一份拷贝，叫 fork 的原因是你在 fork 成自己的仓库后，可以对自己这个仓库进行随意修改，算是原来被 fork 仓库的一个发展分支，源自它但是可以不与它相同 什么是 PR 即 github 上的 pull request 功能， 就是参与一个仓库的代码更新， 就是先 fork 成自己的仓库，然后修改，修改后提交合并到被 fork 的源仓库， 具体方法可自行学习 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/knowledge_image.html":{"url":"get_started/knowledge_image.html","title":"MaixPy 图像基础知识","keywords":"","body":"图像处理背景知识 什么是摄像头？ 我们都见过各种摄像头，比如 那么什么是摄像头，说到底，就是一个将光学信号转变成电信号的一个装置。在计算机视觉中，最简单的相机模型是小孔成像模型： 小孔模型是一种理想相机模型，没有考虑实际相机中存在的场曲、畸变等问题。但是在实际使用时，这些问题可以通过在标定的过程中引入畸变参数解决，所以小孔模型仍然是目前最广泛使用的相机模型。 图像透过镜头，照在一个感光芯片上，感光芯片可以把光照的波长和强度等信息转成计算机(数字电路)可以识别的数字信号，感光元件是长这样的： (中间的方形元件就是感光元件) 什么是像素和分辨率？ 感光元件是有很多个感光点构成的，比如有 640 x 480 个点，每个点就是一个像素，把每个点的像素收集整理起来，就是一副图片，那么这张图片的分辨率就是 640x480： 什么是帧率 帧率(FPS)就是每秒钟处理的图片数量，如果超过20帧，人眼就基本分辨不出卡顿。当然，如果用在机器上，帧率是越高越好的，MaixPy 的最大帧率对比： 注：没有标注均为不传输图像给 IDE，因为这个过程很耗费时间。 什么是颜色 物理上，颜色就是不同波长的电磁波。 颜色 频率 波长 紫色 668–789 THz 380–450 nm 蓝色 631–668 THz 450–475 nm 青色 606–630 THz 476–495 nm 绿色 526–606 THz 495–570 nm 黄色 508–526 THz 570–590 nm 橙色 484–508 THz 590–620 nm 红色 400–484 THz 620–750 nm 但是，根据人眼的视觉效果，可以通过 RGB，CMYK，HSB，LAB 色域，来将可见光的颜色描述出来。 RGB 三原色 三原色的原理不是物理原因，而是由于人的生理原因造成的。人的眼睛内有几种辨别颜色的锥形感光细胞，分别对黄绿色、绿色和蓝紫色(或称紫罗兰色)的光最敏感(波长分别为564、534和420纳米)。 所以 RGB 经常用于显示器上，用来显示图片。 LAB 亮度-对比度 Lab颜色空间中，L亮度；a的正数代表红色，负端代表绿色；b的正数代表黄色，负端代表兰色。不像RGB和CMYK色彩空间，Lab颜色被设计来接近人类视觉。 因此L分量可以调整亮度对，修改a和b分量的输出色阶来做精确的颜色平衡。 注意：在MaixPy的查找色块的算法中，运用的就是这个LAB模式！ 光源的选择 如果你的机器是在工业上，或者24小时长时间运行的设备，保持一个稳定的光源是至关重要的，尤其在颜色算法中。亮度一变，整个颜色的值会变化的很大！ 镜头的焦距 因为图像是通过镜头的光学折射，照到感光元件上的。那么镜头就决定了，整个画面的大小和远近。一个最重要的参数就是焦距。 镜头焦距：是指镜头光学后主点到焦点的距离，是镜头的重要性能指标。镜头焦距的长短决定着拍摄的成像大小，视场角大小，景深大小和画面的透视强弱。当对同一距离远的同一个被摄目标拍摄时，镜头焦距长的所成的象大，镜头焦距短的所成的象小。注意焦距越长，视角越小。 还有一点是镜头的畸变，因为光学原理，在感光芯片上不同的位置，与镜头的距离不同的，简单说就是近大远小，所以在边缘会出现鱼眼效果(桶型畸变)。为了解决这个问题，可以在代码中使用算法来矫正畸变，注：MaixPy中使用image.lens_corr(1.8)来矫正2.8mm焦距的镜头。也可以直接使用无畸变镜头。无畸变镜头加入了额外的矫正透镜部分，价格自然会高不少。 下面是，当 MaixPy 距离桌面20cm左右时，不同焦距镜头的对比图 标配镜头 广角镜头 无畸变镜头 长焦镜头 镜头的滤片 在镜头上，通常会有一个滤片。 这个滤片是做什么的呢？ 我们知道，不同颜色的光，是波长不一样。在正常环境中，除了可见光，还有很多红外光，在夜视中，用的就是红外光。 但是，在正常颜色应用中，是不需要红外光的，因为红外光也会使感光元件受到反应，就使得整个画面泛白。所以我们在镜头上放一个只能通过波长 650nm 以内的滤光片，将红外光进行过滤。 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/knowledge_audio.html":{"url":"get_started/knowledge_audio.html","title":"MaixPy 音频基础知识","keywords":"","body":"音频处理背景知识 什么是音频 人是理性的，而世界是感性的。 什么是音频，音频即震动 为什么需要对音频进行处理 # powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/env_install_driver.html":{"url":"get_started/env_install_driver.html","title":"安装驱动","keywords":"","body":"安装 USB 驱动 正式使用 MaixPy 之前，我们需要先安装好串口驱动，才可进行下一步的开发与使用；因为板子是通过 USB 转串口设备与电脑连接（K210 没有 USB 硬件支持功能）。 根据板子的 USB 转串口芯片型号装驱动。 在 Linux 或者 Mac 下操作串口， 如果不想每次都使用 sudo 命令， 执行 sudo usermod -a -G dialout $(whoami) 将自己添加到 dialout 用户组即可，可能需要注销或者重启才能生效 现有开发板板载的 USB 转串口 IC 说明 开发板型号 USB 转串口 IC 说明 Maix Go STM32 STM32 USB 模拟 FT2232 Maix Dock CH340 Maix Duino CH552 CH552 模拟 FT2232 Maix Bit CH552(新版)/CH340(旧版) CH552 模拟 FT2232 Maix Cube GD32(新版)/CH552(旧版) CH552 模拟 FT2232 Maix Amigo GD32 GD32 模拟 FT2232 使用 CH340 IC 的板子直接装 CH340 的驱动即可，其他的均使用 FT2232 的驱动程序 对于 Dan Dock 和 Maix Bit（旧版） 开发板使用了 CH340 ： Linux 不需要装驱动，系统自带了，使用 ls /dev/ttyUSB* 即可看到设备号 Windows 在网上搜索 CH340 驱动 下载安装即可，然后可以在 设备管理器 中看到串口设备 对于 Maix Go 开发板使用了一颗 STM32 来实现模拟串口以及 JTAG 功能， Windows 需要安装 FT2232 的驱动，请自行搜索 FT2232 驱动 下载安装 这款 STM32 芯片的固件出厂默认采用 open-ec 的固件， 如果没问题，则会出现一个或者两个串口， 比如 Linux 下出现两个串口 /dev/ttyUSB0 和 /dev/ttyUSB1， 下载和访问串口时请使用 /dev/ttyUSB1。 Windows 也类似。 如果需要重新烧录这个固件，可以从 github 或者 官网下载 open-ec 固件， 然后使用 ST-LINK 连接板子上引出的 STM32 的 SW 引脚（GND, SWDIO, SWCLK）进行烧录。（目前版本的 Go 板子上的 STM32 不支持串口烧录，只能使用 ST-LINK 进行烧录， 有需要请自行购买，或者使用一款板子用 IO 模拟也可以（比如树莓派） ） 除了 open-ec 还有 CMSIS-DAP 固件， 相比 open-ec 可以模拟 JTAG 来对板子进行调试， open-ec 目前还未支持模拟 JTAG， 可以 从官网下载固件， 使用 ST-LINK 对其进行烧录， 在 Linux 下会出现 /dev/ttyACM0 设备 ST-LINK 对 STM32 的烧录方法资料很全，请自行搜索 请注意对 STM32 更新固件和更新 MaixPy 固件是不一样的， 一般情况不需要更新 STM32的固件， 默认的即够用了， STM32 只是一个 USB转串口的工具而已！！！勿混淆。。。 对于 Maixduino 开发板 和 Maix Bit 新版带麦克风版本（使用CH552） 开发板 开发板使用了 CH552 芯片来实现 USB 转串口功能，没有 JTAG 模拟功能， Windows 需要安装 FT2232 的驱动，请自行搜索 FT2232 驱动 下载安装 安装驱动 USB 驱动: FT2232 ->下载链接点这里 我们在拿到 MaixPy 开发板并连接到电脑的时候, 可以打开设备管理器查看串口驱动是否已经安装,打开设备管理器的方法有: 此电脑(右键) -> 属性 -> 设备管理器 开始菜单(右键) -> 设备管理器 控制面板 -> (搜索)设备管理器 当我们的系统是 Windows 10 系统,系统则会帮我们自动安装驱动，而如果是旧版 Win7，win8 系统，我们就需要自己手动安装 USB 驱动: 打开上一节的的链接下载驱动 点击安装 安装完成之后,可以在设备管理器看到已经识别到两个串口设备了(其中只有一个串口可用) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/install_driver/dock.html":{"url":"get_started/install_driver/dock.html","title":"Maix Dock","keywords":"","body":"powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/upgrade_maixpy_firmware.html":{"url":"get_started/upgrade_maixpy_firmware.html","title":"更新 MaixPy 固件","keywords":"","body":"更新 MaixPy 固件 准备 硬件: USB Type-C 数据线 MaixPy 开发板 PC(电脑) 软件: MaixPy 开发板 USB 驱动程序 kflash_gui 确认驱动已经正确安装 按照前面的说明安装好驱动，并且在电脑中能看到串口设备, Linux 和 Mac OS 执行 ls /dev/ 即可看到设备号，比如名字是ttyUSB0和ttyUSB1; Windows在设备管理器中查看 获得升级工具 下载 kflash_gui, 会得到一个压缩包 kflash_gui 是跨平台的，可以在多个系统下工作（包括 Windows、Linux、MacOS、甚至树莓派） 使用勘智（Kendryte）的Windows版本可能部分开发版无法下载成功，请使用 kflash_gui 这个软件来下载 解压到一个文件夹，双击 kflash_gui.exe(/kflsh_gui) 即可运行, Windows下建议右键固定到开始页面 或者固定到任务栏, Linux 下可以自己新建一个kflash_gui.desktop, 修改文件地址, 使用管理员身份复制到/usr/share/application目录，然后在系统菜单界面就可以看到kflash_gui这款应用了 另外也可以使用命令行版本下载 pip3 install kflash kflash --help kflash -p /dev/ttyUSB0 -b 1500000 -B goE maixpy.bin 获得固件 发布版本的固件从 github 页面下载 最新提交的代码自动构建生成的固件下载： master 分支 固件为 .bin 结尾或者 .kfpkg 的文件 .kfpkg其实就是多个.bin文件的打包版本, 可以使用kflash_gui打包或者手动打包 固件命名说明： 文件名 说明 备注 maixpy_vx.y.z_x_xxx*.bin 默认版本的 MaixPy 固件，包含了大多数功能, 支持连接 MaixPy IDE, 出厂默认固件版本 maixpy_vx.y.z_x_xxx*_m5stickv.bin 针对 M5Stickv 定制的固件, 支持连接 MaixPy IDE — maixpy_vx.y.z_x_xxx*_with_lvgl.bin MaixPy 固件, 支持连接 MaixPy IDE, 带 LVGL 版本.(LVGL是嵌入式 GUI 框架, 写界面的时候需要用到) — maixpy_vx.y.z_x_xxx*_minimum.bin MaixPy 固件最小集合，不支持 MaixPy IDE, 不包含OpenMV的相关算法和各种外设模块 — maixpy_vx.y.z_x_xxx*_minimum_with_ide_support.bin MaixPy 固件最小集合, 支持连接 MaixPy IDE, 不包含OpenMV的相关算法和各种外设模块 运行各种模型，建议使用这个 elf_maixpy_vx.y.z_x_xxx*.7z elf 文件，普通用户不用关心，用于死机调试 — face_model_at_0x300000.kfpkg 人脸模型，放置在地址位 0x300000, 可以和.bin分开多次下载，不冲突 — 下载固件到开发板 打开 kflash_gui 应用 然后选择固件、设置选项, 点击下载即可, 更多特性介绍、使用说明见 kflash_gui 项目主页 使用时注意串口不能被其它软件占用，选择正确的开发板和串口号，可以适当降低波特率和使用低速模式来提高下载成功率 对于最早期的 Maix Go, 如果确认选项是对的，仍然无法下载, 可以尝试将三相拨轮按键拨向 Down 的位置并保持再下载 Sipeed RV JATG 调试器 Sipeed USB-JTAG/TTL RISC-V调试器 STLINK V2 STM8/STM32模拟器 烧录常见问题FAQ 如果在使用 kflash_gui 烧录出现以下等问题 可以按照以下顺序进行排查 检查PC是否有权限打开端口，对于 win10，需要以管理员身份运行 kflash_gui 。 检查端口是否选择正确（如果出现两个设备端口，通常选择端口号小的那一个）。 检查端口是否被其他应用占用（如Maixpy IDE，putty等），应当关闭其他程序占用。 检查设备是否选择正确，对于 Maix Bit2.0（包括M1n模块），应该选择 Maix Bit ( with Mic )。 补充说明：对于Maix Bit 2.0两个串口端口的问题 只有其中一个串口端口有效，用于串口通信与ISP下载程序。 Maix Bit与PC采用串口通信，通过CH552T芯片实现USB虚拟串口功能，而该芯片可以虚拟出两个串口，在Maix Bit（M1n模块底板）中，我们只用到了一个串口，不过有些k210产品两个串口都使用了。 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/env_serial_tools.html":{"url":"get_started/env_serial_tools.html","title":"使用串口终端工具","keywords":"","body":"使用串口工具 连接硬件 连接 Type C 线， 一端电脑一端开发板 查看设备是否已经正确识别： 在 Linux 下可以通过 ls /dev/ttyUSB* 或者 ls /dev/ttyACM* 来查看， 如果没有可以 ls /dev 来找找，具体的设备名跟串口芯片和驱动有关. 也可以用sudo dmesg来看是否有设备挂载记录 在 Windows 下可以打开设备管理器来查看 如果没有发现设备， 需要确认有没有装驱动以及接触是否良好 使用串口工具 Windows Windows 常用的串口终端软件有 putty, mobaxterm xshell 等工具 Putty 然后选择串口模式， 然后设置串口和波特率，打开串口。 然后点击回车键，即可看到 MaixPy 的交互界面了 >>> 输入 help()，可以查看帮助 上图来源： laurentopia 的上手教程 Mobaxterm MobaXterm 是 Windows 下一款非常好用的多功能终端软件（当然也包括串口终端） Linux 使用minicom（推荐） 或者 screen等工具即可 minicom sudo apt update sudo apt install minicom sudo minicom -s # 然后根据提示设置串口号以及波特率为 115200 等，不懂可以利用搜索工具搜索 # 设置 Backspace 为 DEL 功能 # 设置 linewrap 为 Yes sudo minicom 注意 minicom 的默认配置文件保存需要 sudo 权限，所以使用sudo minicom -s 这里按 A 即可设置设备 按 E 即可设置波特率， 波特率需要设置为 115200 这里按 A 和 R 将设置切换为图中的设置一样， 第一个是为了后面使用 pye 编辑器快捷键不冲突， 第二个自动换行的设置是为了能显示完全输出 设置完后保存退出，下次就不需要再设置了，只需要执行 sudo minicom 即可, 如果不想每次都使用sudo命令， 执行sudo usermod -a -G dialout $(whoami) 将自己添加到dialout用户组即可，可能需要注销或者重启才能生效，注意sudo minicom -s 如果需要修改默认配置文件还是需要 sudo 进入minicom后点击回车键或者开发板的复位按钮，即可看到 MaixPy 的交互界面了 输入 help()，可以查看帮助 要退出minicom， 按 Ctrl+A X，按 Enter 确认退出即可 另外，在开发过程中可能串口号会变， 可以在执行 minicom 的时候指定串口号，这样就不用每次串口号变了都设置一遍了，比如：minicom -D /dev/ttyUSB1 -b 115200 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/env_maixpyide.html":{"url":"get_started/env_maixpyide.html","title":"MaixPy IDE 使用说明","keywords":"","body":"MaixPy IDE 安装与使用 关于 MaixPy IDE 首先需要弄清： MaixPy 使用 Micropython 脚本语法，所以不像 C 语言 一样需要编译，其实不用 IDE 也能愉快使用： 使用串口终端工具，前面已经安装了 使用 IDE 则会方便在电脑上实时编辑脚本并上传到开发板以及直接在开发板上执行脚本，以及在电脑上实时查看摄像头图像、保存文件到开发板等 当然， 使用 IDE 因为压缩、传输需要耗费一部分资源，所以性能会有所降低，而且如果MaixPy宕机也没有串口终端好发现问题 MaixPy 固件 要使用 MaixPy IDE , 固件必须是 v0.3.1 版本以上, 否则MaixPyIDE 上会连接不上， 使用前尽量检查固件版本和 IDE 版本，都更新到最新版以保障能正常使用 下载安装包 dl.sipeed.com 文件列表等说明 请看 最新版本文件夹下的 readme.txt 文件， 如果下载速度慢请使用 cdn 链接下载 安装 如果是安装程序(推荐，简单方便) Windows直接双击exe文件运行安装程序; Linux命令行给运行权限然后执行 chmod +x maixpy-ide-linux-x86_64-0.2.2.run ./maixpy-ide-linux-x86_64-0.2.2.run 如果是压缩包(7z) 则解压到文件夹 如果系统不支持 7z， 则需要 下载 7z解压缩工具，然后用 7z 在Linux下也可以双击压缩包进行解压！ 如果需要使用终端解压， 可以参考以下命令： sudo apt install p7zip-full 7z x maixpy-ide-linux-x86_64-0.2.2-installer-archive.7z -r -omaixpy-ide # `-o` 后面直接跟解压缩的路径, 中间没有空格. 解压后, 执行 如果是 Windows： 直接双击maixpyide来执行，可以右键固定到开始页面或者固定到任务栏方便后面使用 Linux： 执行 chmod +x setup.sh ./setup.sh ./bin/maipyide.sh 测试运行 打开 MaixPy IDE, 上方工具栏里面选择开发板的型号. Tool-> Select Board (工具->选择开发板) 点击 connect 连接 MaixPy IDE 连接成功之后，链接按钮会由绿变红． 连接按钮下方是运行按钮，会执行当前编辑区的py文件． 再次点击运行按钮(红色), 停止运行当前代码． 上传文件 在 Tool/工具 菜单中可以选择发送文件 注意 点击连接后，不用和终端工具同时使用，否则会出现串口占用无法打开 如果一直无法成功连接成功， 检查： 请检查是否开发板型号选择错误； 观察开发板屏幕是否有变化，如果没有反应可能是串口选择错误； 尝试升级到最新的 master 分支固件， 以及最新的 MaixPy IDE 软件 根据错误提示寻找原因 程序运行出错时会弹框提示错误，但是错误信息不一定完整，请在终端输出里面查找更详细的错误信息 如有必要，请断开 IDE， 仅使用串口终端运行程序（也许你需要先把程序保存到文件，然后运行文件）查看打印以排错 如果提交问题（bbs、群、github issue等），为了使问题快速得到解决，请务必带上上面所述完整信息 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/upgrade_esp32_firmware.html":{"url":"get_started/upgrade_esp32_firmware.html","title":"更新板载 ESP32 固件","keywords":"","body":"更新板载 ESP32 固件 简介： MaixPy 系列的开发板中 MaixDuino 板载了一块 ESP32 WIFI SOC，在默认情况下我们不需要更新板载的 ESP32 模块，但是但我们发现使用过程中存在 bug 并修复了之后我们就需要更新修复的固件。 更新 ESP32 固件步骤 准备 硬件: MaixDuino, USB Type-C 数据线 软件: ESPFLASH ESP32 固件更新工具：ESP32 flash_download_tools 下载链接：flash_download_tools ESP32 MaixDuino 固件： 下载链接：flash_download_tools 更新流程： 下载 flash_download_tools， 下载 MaixDuino ESP32 固件 连接 MaixDuino, 选择 ESP32 串口(一般都是串口号比较大的) 设置下载选项: 如图配置相应选项, 注意波特率一定要设置为 115200 点击 Start 更新固件，并等待完成更新 验证更新是否完成 使用 XCOM, 打开 ESP32 串口，点击 RST 复位 ESP32，如图即刷入成功 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/upgrade_esp8285_firmware.html":{"url":"get_started/upgrade_esp8285_firmware.html","title":"更新板载 ESP8285 固件","keywords":"","body":"更新板载 ESP8285 固件 简介： 目前 MaixPy 系列采用 M1W 模块的作为核心模块的开发板有: MaixDock(M1W)， MaixGo 通常情况下我们不需要更新模块内部 WIFI SOC ESP8285 的固件，但是如果使用过程中存在 bug，以及有新版本的固件发布是我们就可以更新固件 MaixDock、MaixGo 使用的 M1W 模块中的 ESP8285 默认烧录的是 AT 固件 验证 ESP8285 是否能够正常工作 MaixPy 验证 ESP8285 是否正常工作例程 查看文本末尾例程 外接 USB 转串口模块测试 使用 USB 转串口模块，按照下表连接之后上电 | M1W | USB 模块 | 说明 | | -------------------------------------- | -------- | ---- | | M1W GND | GND | 共地 | | K210 (IO6)/ESP8285 TX | RX | | | K210 (IO7)/ESP8285 RX | TX | | | k210 RST(上电之前接地，全过程拉低 RST) | GND | | 上电之后板子会在串口输出(这里使用 XCOM) 来验证 ESP8285 是否正常启动 AT 指令集 ESP8285 和 ESP8266 为同一系列产品，使用同一套 AT 指令集 ESP8285/ESP8266/ESP32 最新 AT指令集 https://github.com/espressif/esp-at/blob/v2.0.0.0_esp8266/docs/ESP_AT_Commands_Set.md 更新 ESP8285 固件步骤 在烧录 ESP8285 固件之前，先了解下 ESP8285 烧录原理: ESP8285 固件烧录原理 ESP8285 在上电时，会判断 boot stapping 管脚的状态，并决定启动(boot)模式, 如: ets Jan 8 2013,rst cause:1, boot mode:(3,2) 其中打印的 boot mode 的第一位数字（3）代表当前的 boot 模式。 Boot 模式由 strapping 管脚的 3 位值 [GPIO15， GPIO0， GPIO2] 共同决定。如下表所 示： Strapping 管脚的 3 位值/[GPIO15， GPIO0， GPIO2] Boot 模式 7 / [1， 1， 1] SDIO HighSpeed V2 IO 6 / [1， 1， 0] SDIO LowSpeed V1 IO 5 / [1， 0， 1] SDIO HighSpeed V1 IO 4 / [1， 0， 0] SDIO LowSpeed V2 IO 3 / [0， 1， 1] Flash Boot 2 / [0， 1， 0] Jump Boot 1 / [0， 0， 1] UART Boot 0 / [0， 0， 0] Remapping ESP8285 进入不同模式的 IO 电平请看如下表： 模式 CH_PD(EN) RST GPIO15 GPIO0 GPIO2 TXD0 UART 下载模式 高 高 低 低 高 高 Flash 运行模式 高 高 低 高 高 高 Chip 测试模式 - - - - - 低 而以 MaixDock 为例，可以看到 MaixDock 原理图如下： 准备 这里以 MaixDock(M1W), Windows 10 系统为例 硬件: MaixDock, USB Type-C 数据线 软件: ESP 固件更新工具：ESP8285 flash_download_tools 下载链接：乐鑫官网：flash_download_tools ESP8285 AT 固件： 下载链接：ESP8266 AT bin 乐鑫官方下载链接: espressif_esp8266-at 更新（这里以 MaixDock 为例）： 按照下面配置，连接 MaixDock, 打开 flash_download_tools， 下载 MaixDock ESP8285 固件 选择 ESP8285 串口(一般都是串口号比较大的) 设置下载选项: 如图配置相应选项, 注意波特率一定要设置为 115200 点击 Start 更新固件，并等待完成更新 验证更新是否完成 使用 XCOM, 打开 ESP8285 串口，点击 RST 复位 ESP，如图即刷入成功 MaixPy 例程测试： import network, time from machine import UART from Maix import GPIO from fpioa_manager import fm, board_info # En SEP8285 rst #fm.register(8, fm.fpioa.GPIOHS0, force=True) #wifi_en=GPIO(GPIO.GPIOHS0, GPIO.OUT) #wifi_en.value(1) # En SEP8285 rst fm.register(0, fm.fpioa.GPIOHS0, force=True) wifi_io15=GPIO(GPIO.GPIOHS0, GPIO.OUT) wifi_io15.value(0) fm.register(8, fm.fpioa.GPIOHS1, force=True) wifi_en=GPIO(GPIO.GPIOHS1, GPIO.OUT) wifi_en.value(1) # for new MaixGO board, if not, remove it #fm.register(0, fm.fpioa.GPIOHS1, force=True) #wifi_io15_en=GPIO(GPIO.GPIOHS1, GPIO.OUT) #wifi_io15_en.value(0) fm.register(6, fm.fpioa.UART2_RX, force=True) fm.register(7, fm.fpioa.UART2_TX, force=True) uart = UART(UART.UART2,115200,timeout=1000, read_buf_len=4096) def wifi_enable(en): global wifi_en wifi_en.value(en) def wifi_deal_ap_info(info): res = [] for ap_str in info: ap_str = ap_str.split(\",\") info_one = [] for node in ap_str: if node.startswith('\"'): info_one.append(node[1:-1]) else: info_one.append(int(node)) res.append(info_one) return res #wifi_enable(0) time.sleep(2) nic = network.ESP8285(uart) ap_info = nic.scan() ap_info = wifi_deal_ap_info(ap_info) ap_info.sort(key=lambda x:x[2], reverse=True) # sort by rssi for ap in ap_info: print(\"SSID:{:^20}, RSSI:{:>5} , MAC:{:^20}\".format(ap[1], ap[2], ap[3]) ) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/get_started_power_on.html":{"url":"get_started/get_started_power_on.html","title":"上电","keywords":"","body":"MaixPy 开发板上电 当我们拿到 MaixPy 开发板之后 检查硬件 检查硬件是否有损坏， 以及摄像头和屏幕是否接好，排线千万不要接反了，根据前面的开发板描述操作 连接硬件 连接 Type C 线， 一端电脑一端开发板 查看设备是否已经正确识别： 在 Windows 下可以打开设备管理器来查看 在 Linux 下可以通过 ls /dev/ttyUSB* 或者 ls /dev/ttyACM* 来查看， 如果没有可以 ls /dev 来找找，具体的设备名跟串口芯片和驱动有关 如果没有发现设备， 需要确认有没有装驱动以及接触是否良好 上电后， 如果是新出厂的开发板， 可能会显示红色背景，前景是简单的 MaixPy 介绍，包括官网地址，画面是静止的，需要通过接下来的编程让它改变。 检查固件版本 使用串口终端打开串口，然后复位，看输出的版本信息，与github 或者 master 分支 的固件版本对比，根据当前版本情况考虑升级到最新版本 比如： [MaixPy] init end __ __ _____ __ __ _____ __ __ | \\/ | /\\ |_ _| \\ \\ / / | __ \\ \\ \\ / / | \\ / | / \\ | | \\ V / | |__) | \\ \\_/ / | |\\/| | / /\\ \\ | | > 查看版本号： 这里版本是 v0.5.0-12-g284ce83， 也可以使用下面的代码查看版本 注： 固件可以从下载站 dl.sipeed.com 中获取 import sys sys.implementation.version 如果你在开发过程中遇到了问题， 也可以先尝试更新固件到最新版本 执行代码 打开串口终端后，按开发板的复位按钮就可以看到打印的开机信息了，会输出 >>> 即在等待我们输入代码，如果没有这个符号，可能是有开机自动运行的程序正在运行，可以按Ctrl+C来取消正在运行的程序 然后输入程序执行 >>> print(\"hello world\") hello world >>> 粘贴执行多行代码 当我们有多行代码是从其它地方复制过来的，比如 import os f = os.listdir() print(f) 先复制好代码 串口终端按 Ctrl+E 粘贴代码 按 Ctrl+D（注意如果之前没有按 Ctrl+E 则是软件复位命令，MaixPy 会软复位），然后就可以看到所有代码执行了 >>> paste mode; Ctrl-C to cancel, Ctrl-D to finish === import os === f = os.listdir() === print(f) ['boot.py','main.py', 'freq.conf'] >>> 如果数据量比较大，串口可能丢失数据，会导致提示语法错误，可以多试几次 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/get_started_cam_lcd.html":{"url":"get_started/get_started_cam_lcd.html","title":"第一个程序: 使用屏幕和摄像头","keywords":"","body":"第一个程序: 使用屏幕和摄像头 开发板有配套的摄像头和屏幕，请在上电前检查硬件连接是否正确 然后上电，打开串口终端， 按键盘Ctrl+E,然后粘贴以下代码： import sensor, lcd sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames() lcd.init(freq=15000000) while(True): lcd.display(sensor.snapshot()) 按键盘Ctrl+D来开始运行代码 会发现屏幕被点亮了，而且显示出了摄像头拍到的画面 如果显示reset fail， 则是摄像头没有连接好，或者摄像头已经损坏，或者检查是不是使用了不支持的摄像头 上面的程序都可以在 API 手册中查到含义， 在左边目录中可以找到， 也可以使用左上角的搜索框进行搜索。 现在解释上面的程序： import sensor, lcd: 首先导入内置的sensor（摄像头）库和lcd（屏幕）库 sensor.reset(): 初始化摄像头，这里失败需要检查硬件 sensor.set_pixformat(sensor.RGB565): 设置摄像头为RGB565格式，默认都是用RGB565即可 sensor.set_framesize(sensor.QVGA): 分辨率为QVGA，即320x240 sensor.run(1): 开始运行，在现在的版本中也可以不调用，在上面设置完成后，摄像头会自动开始运行 sensor.skip_frames(): 摄像头刚启动时，图像质量还没稳定，所以跳过一些图像 lcd.init(freq=15000000): 初始化 LCD， 这里传了一个参数叫freq即频率， 是指定驱动 LCD 的时钟频率，这里是15MHz，可以根据硬件性能调整 while(True): 这是一个循环，循环里面的代码会被不停地运行 sensor.snapshot():从摄像头取一帧图像数据，返回值是一张图像的对象 lcd.display()： 显示图像到 LCD lcd.display(sensor.snapshot()): 这里就是先执行括号里的获取图像，返回值直接作为参数给 LCD 进行显示 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/get_started_led_blink.html":{"url":"get_started/get_started_led_blink.html","title":"第二个程序: 点亮 LED","keywords":"","body":"点亮 LED 点灯程序作为学习所有开发板的第一个程序，就像学所有编程语言都是先学 hello world 一样，具有着神圣的意义 电路 众所周知， 点亮一个 LED 需要一个电源， 一个电阻， 一个 LED 灯泡， 在 Dan Dock 开发板上， 有三个 LED， 线路如下： 比如我们希望红灯点亮， 即 LED_R 连接的这个 LED， 图中可以看到 LED 的正极已经连接了 3.3V 电源， 所以我们只要让 LED_R 为低电平 LED 即可点亮。 注意， 这里 LED_R 是给这个引脚取的一个别名， 实际上是连接到芯片的一个引脚，比如 Pin13或者说IO13 外设到引脚的映射： FPIOA(现场可编程 IO 阵列， Field Programmable Input and Output Array) 可能你曾经用过一些单片机，在手册上都规定了引脚和片上外设功能（就是芯片内部集成的外设，比如 GPIO、I2C、SPI 等）的绑定，或者重映射。比如规定了 I2C 只能用 Pin9 和 Pin10，启动了重映射功能后，只能用Pin11和Pin12 但是 MaixPy 所使用的硬件 K210 的片上外设对应的引脚（硬件引脚）是可以任意映射的，相比之下 K210 硬件设计和软件设计的自由度更大。 比如 I2C 可以使用 Pin11 和 Pin12，也可以改成其它任意引脚 注意要区分 GPIO 和 IO的区别， IO也可以叫Pin 也就是引脚，是芯片引出来的硬件引脚， 而GPIO是一种外设，可以控制这些Pin/IO 的外设 因为有了这个强大的映射功能， 所以在使用引脚时，需要增加一步映射的步骤： from fpioa_manager import fm # 导入库 fm.register(28, fm.fpioa.GPIO0) 这里我们将引脚 28 映射为了 GPIO0 的功能, 执行了这句命令后，引脚28和GPIO0就映射（绑定）好了，要取消映射（解绑），则需要调用fm.unregister函数，具体看API文档，这里不介绍 另外，Pin 和 外设只能唯一对应， 不能一对多，需要对同一个外设或者引脚重复映射，否则程序可能产生难以发现的错误（BUG） 代码 我们控制 LED 需要使用到 GPIO 程序如下： from fpioa_manager import fm from Maix import GPIO io_led_red = 13 fm.register(io_led_red, fm.fpioa.GPIO0) led_r=GPIO(GPIO.GPIO0, GPIO.OUT) led_r.value(0) 按照前面运行代码的方法在终端里面运行代码， 会发现 LED 灯被点亮了！ 接下来我们分析代码： 从 fpioa_manager 包导入fm 对象，主要用于引脚和外设的映射 从包 Maix 导入了 GPIO 这个类， GPIO 外设相关操作 定义一个变量io_led_red，值为13，即Pin13/IO13, 具体 LED 的引脚连接到了芯片的哪个引脚，请在前面的开发板介绍中看原理图 使用fm(fpioa manager 的缩写)这个内置的对象来注册芯片的外设和引脚的对应关系，　这里　fm.fpioa.GPIO0 是　K210 的一个 GPIO 外设（注意区分 GPIO（外设） 和引脚（实实在在的硬件引脚）的区别 ）， 所以把 fm.fpioa.GPIO0 注册到了 引脚 IO13； 然后定义一个 GPIO 对象led_r， 具体参数看 GPIO API 文档， 在左边侧边栏查找。 使用 led_r.value(1) 或者 led_r.value(0) 来设置高低电平即可, 因为这里设置了低电平， 根据上面的原理图可知低电平导通，LED 灯亮 到这里已经可以点灯了， 现在可以自己尝试用 for 循环来实现 LED 闪烁或者流水灯～做出不同的变换效果 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/get_started_fs.html":{"url":"get_started/get_started_fs.html","title":"文件系统介绍","keywords":"","body":"文件系统介绍 文件系统 文件系统大家都很熟悉，如其名，就是用来管理文件的，在电脑上使用关键管理器就可以轻松访问和管理文件系统 有了文件系统，可以把数据保存进去，就算断电了，数据仍然存在 MaixPy 的文件系统 在 MaixPy 中，也内置了文件系统的支持 在电脑上，文件实际都是存在硬盘上的， 那么在 MaixPy 中，文件系统放在那里的呢， 答案是放在 Flash 里面或者SD卡里面， 开发板的 Flash 需要用来储存程序，我们预留了Flash末尾的3MiB空间，用来存放文件系统， 我们用了 SPIFFS作为文件系统。 另外也支持FAT32格式的SD卡。 如果你没有入门过单片机，你只需要知道， 你有什么数据需要断电后还能保存，它能够帮你做到 如果你之前简单的入门过单片机开发，你可能尝试过将数据保存到 Flash, 也许没有使用文件系统，而是自己手动写数据到Flash，然后自己管理哪些数据应该写到什么位置。有了文件系统，你不用再去管哪些数据应该写到哪儿了， 你只需要调用函数写入数据，文件系统会自动判断应该写到哪里最合适（会考虑效率、寿命等） MaixPy 的文件系统使用 对于文件系统的使用， 和电脑上python读写文件系统一样， 使用os模块 和 open函数 对于内置的 SPIFFS， 开机会被自动挂在到/flash目录， 所以只需要对这个目录进行操作即可，注意不支持文件夹,比如 import uos print(\"files:\", uos.listdir(\"/flash\")) with open(\"/flash/test.txt\", \"w\") as f: f.write(\"hello text\") print(\"files:\", uos.listdir(\"/flash\")) with open(\"/flash/test.txt\", \"r\") as f: content = f.read() print(\"read:\", content) 解读： 导入了uos模块 列出了/flash目录下所有文件 并且向/flash目录写入了一个test.txt文件，内容是hello text, 再列出了/flash目录下所有文件， 会发现多了一个test.txt 读取文件到content变量 打印content变量， 输出hello text，也就是刚刚写入文件的内容 这个内容在开发板断电之后再上电，仍然能读到正确的内容 当然也支持 SD 卡， 如果你需要使用， SD 卡需要满足以下几点： 支持 SPI 模式, 市面上大多数正版卡都支持 分区为 MBR （msdos） 格式化为 FAT32 大小测试过最大 128GiB 可用 断电插入 SD 后， 上电，SD 卡会被挂载在/sd，如过有多个分区，第二个分区是/sd2 注意/（根目录）不能写入数据，只能往/flash或者/sd写入数据 开机如果有SD卡， 会自动将当前目录切换到/sd， 如果没有，则会自动切换到/flash powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/get_started_edit_file.html":{"url":"get_started/get_started_edit_file.html","title":"编辑并运行脚本","keywords":"","body":"编辑并执行文件 MaixPy 内置了文件系统 前面说了， MaixPy 支持 Flash 使用的 SPIFFS（目前不支持创建目录）, 默认分配了 3MB 给 SPIFF（从flash 0xD00000地址开始 3M）, 开机自动挂载到 /flash 目录下 也支持 FAT32 格式MBR分区的 Micro SD （TF）卡 ,开机自动挂在到 /sd 目录下 需要注意的是, 根目录只是用来挂载 Flash 或者 SD 卡, 具体的文件在 /flash 或者 /sd 目录下 为什么需要编辑并执行文件 在前面的实验中,我们直接在终端里面敲代码来一句一句执行,这样也简单方便,我们输入命令后会立即执行并及时得到返回的结果,这种交互方式称为 REPL（Read Eval Print Loop：交互式解释器）, 这种方式的好处就是简单方便,使用起来和 Linux 终端十分相似,只是使用的语法换成了 MaixPy(Micropython)的语法。 但是在实际运行的时候，我们希望代码保存在文件系统， 需要运行是直接运行文件，这样我们不用每次都敲代码,减少了很多麻烦 编辑并保存文件 方法一： 使用内置编辑器 Micropython Editor(pye) 在 MaixPy 中, 我们内置了一款编开源编辑器 Micropython Editor(pye) 使用 os.listdir() 可以查看当前目录下的文件, 使用 pye(\"hello.py\") 可以创建文件并进入编辑模式, 快捷键等使用说明可以在这里查看 比如我们写入代码 print(\"hello maixpy\") 然后按 Ctrl+S 按 Enter 键保存, 按 Ctrl+Q 退出编辑 注意： 使用这款编辑器对使用的串口工具有一定要求, 必须将 BackSpace 按键设置为 DEL 功能, 否则按 BackSpace 调用的是 Ctrl+H 一样的功能（即字符替换）。 Linux 下推荐使用 minicom, 需要使用 sudo minicom -s 来设置,参考前面的教程 Windows 下也一样, 根据自己使用的工具上网搜设置方法, 比如 xshell 搜 xshell如何设置backspace为del 得到结果： 文件 -> 属性 -> 终端 -> 键盘, 把 delete 和 backspace 序列改为 ASCII 127 即可. 方法二： 使用 MaixPy IDE 打开 MaixPy IDE, 连接开发板 编辑文件,然后在顶端Tool（工具）菜单中, 使用顶端Tool(工具)菜单中的发送文件功能来发送文件,会保存到开发板并且文件名和电脑上的文件名相同 当然也可以点击将打开的文件保存为 boot.py 来将代码保存到开发板的boot.py文件,中,下次开发板开机上电会自动执行这个文件 方法三： 使用工具 uPyLoader 读取到 PC（电脑)上编辑后再保存到开发板 下载可执行文件:release 选择串口并点击 Connect 按钮来连接板子 第一次运行该软件需要初始化, 点击 File->Init transfer files 来完成初始化,这会在板子里创建两个文件,分别是 __upload.py 和 __download.py。 然后双机文件名即可打开文件并编辑,编辑完成后点击 save 来保存到开发板即可 方法四： 使用工具 rshell 读取到 PC（电脑)上编辑后再保存到开发板 按照 rshell 项目主页的说明安装好 rshell sudo apt-get install python3-pip sudo pip3 install rshell rshell -p /dev/ttyUSB1 # 这里根据实际情况选择串口 编辑文件 ls /flash edit /flash/boot.py # 编辑器使用方法和 vim 一样 执行文件 使用 os.chdir() 切换当前目录到文件的目录,比如 os.chdir(\"/flash\") 方法一： import 然后执行 import hello 即可看到输出 hello maixpy 使用此方法简单易用,但是需要注意的是, 目前 import 只能使用一次, 如果第二次 import, 则文件不会再执行, 如果需要多次执行,建议使用下面的方法 而且 import 也不会执行if __name__ == \"__main__\":条件下的代码，需要注意 方法二： exec() 使用 exec() 函数来执行 with open(\"hello.py\") as f: exec(f.read()) 方法三： 使用 MaixPy IDE 来执行 打开文件, 然后点击执行按钮来执行，注意：这样执行代码和 REPL执行代码类似，只是将程序发送到开发板，并没有保存到文件系统，是一次性执行的 方法四： 使用 uPyLoader 来执行 连接好后选中文件, 点击 excute 按钮来执行文件 方法五： 使用 ampy 来直接运行电脑上的文件 ampy 执行命令 ampy run file_in_PC.py 来执行位于电脑上的文件（文件不会保存到开发板） MaixPy 支持挂载文件系统到电脑么 不支持， 因为使用的芯片 k210 没有 USB 功能， 无法模拟 U 盘设备，所以不能像 Microbit 和 STM32 的 Micropython 一样虚拟一个 U 盘 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/get_started_upload_script.html":{"url":"get_started/get_started_upload_script.html","title":"上传脚本到开发板","keywords":"","body":"上传脚本&模块到开发板 前面我们接触到了直接执行 pye(\"filename.py\") 命令可以打开一个编辑器，可以直接编辑文件系统中的文件 但是慢慢我们会发现，这样的方法只适合用来改少量的代码，当代码量庞大或者我们需要高亮支持时，它就不适用了，我们需要在电脑上写完代码，然后上传到板子的文件系统里面 目前有以下几种方法： 使用 MaixPy IDE 上传脚本到开发板 打开 MaixPy IDE， 连接开发板 编辑文件，然后在顶端Tool（工具）菜单中，点击将打开的文件保存为 boot.py 来将代码保存到开发板的boot.py文件，中，下次开发板开机上电会自动执行这个文件 当然也可以使用顶端Tool(工具)菜单中的发送文件功能来发送文件，会保存到开发板并且文件名和电脑上的文件名相同，（除了脚本也可以上传其它文件，不要太大） 使用图形工具 uPyLoader 上传、运行脚本 uPyLoader 是一款开源软件，使用它可以方便地连接 MaixPy 并且上传、下载、执行文件，同时监控输出等等功能，功能比较完善 下载可执行文件:release 选择串口并点击 Connect 按钮来连接板子 第一次运行该软件需要初始化， 点击 File->Init transfer files 来完成初始化，这会在板子里创建两个文件，分别是 __upload.py 和 __download.py。 左边选中需要上传的文件，点击 Transfer 即可上传到板子的文件系统。 右边是板子里面的文件， 点击 List files 可以刷新文件列表， 选中 文件名， 点击 Execute 即可执行该脚本文件 点击上面的 View -> terminal 可以打开终端 用来查看运行时的输出或者发送命令 使用工具 rshell 正如使用 linux 终端一样， 使用 rshell 的 cp 命令即可简单地复制文件到开发板 按照 rshell 项目主页的说明安装好 rshell sudo apt-get install python3-pip sudo pip3 install rshell rshell -p /dev/ttyUSB1 # 这里根据实际情况选择串口 ls /flash cp ./test.py /flash/ #复制电脑当前目录的文件 test.py 到开发板 flash 根目录 当然， 还有其它更多功能， 详情请访问其 项目主页 使用命令行工具 ampy ampy 是一个简单易用的命令行上传、下载、执行文件 的工具， 而且开源 注意这个工具是运行在电脑端的，而不是运行在板子上的 使用 ampy --help 来查看帮助信息 使用 ampy run file_in_PC.py 命令还可以不上传脚本到板子而是直接在板子上运行该脚本 SD（TF） 直接运行 拷贝到 SD 卡后， 在终端中执行 import 文件名 或者exec()来运行脚本 SD 卡自动拷贝到 Flash 文件系统 为了方便将 SD 卡的内容拷贝到 Flash 文件系统， 只需要将要拷贝到 Flash 文件系统的文件重命名为cover.boot.py 或者cover.main.py, 然后放到SD卡根目录， 开发板断电插入SD卡，然后开发板上电， 程序就会自动将这两个文件拷贝到/flash/boot.py或者/flash/main.py，这样就算后面取出了SD卡，程序已经在 /flash/boot.py或者/flash/main.py了 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/get_started_boot.html":{"url":"get_started/get_started_boot.html","title":"开机自动运行脚本","keywords":"","body":"开机自启动脚本 系统会在 /flash 或者 /sd(优先) 目录创建 boot.py 文件和main.py， 开机会自动先执行boot.py，然后执行main.py（如果检测到SD卡则执行SD卡里的）， 编辑这两个脚本的内容即可实现开机自启，尽量不要在boot.py里面写死循环程序 另外，也可以在 Micro SD 卡中放 cover.boot.py 或者 cover.main.py 来覆盖 /flash/boot.py 或 /flash/main.py，在开机的时候系统会自动检测并复制，复制完成后会自动重启并运行新的启动文件 注意: * Micro SD 卡应该被格式化为 FAT(FAT32) 文件系统 * FAT 格式的储存卡会被挂载到 `/sd`, 内部 Flash 中的 SPIFFS 会被挂载到`/flash` powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"get_started/maixpy_get_started_video.html":{"url":"get_started/maixpy_get_started_video.html","title":"上手视频教程","keywords":"","body":"MaixPy 视频入门教程 视频简单介绍了基本的上手过程，事实上文档上会更加详细， 视频只是提供一个比较直观的入门参考，对部分人群来说看视频入门会更加容易， 另外，本视频内的文档版本是最初的版本，新文档目录结构有了适当的调整，请大家举一反三： 建议进入Bilibili登录看高清版本哦， 如果觉得节奏太慢可以右键调速～ powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"firmware/why_customize_firware.html":{"url":"firmware/why_customize_firware.html","title":"为什么需要定制固件","keywords":"","body":"为何需要固件定制 主要是为了节省内存。 芯片的内存是6MiB通过内存+2MiB AI 专用内存，相比普通单片机来说确实非常大，如果不用 AI 功能， 整个8MiB内存我们都可以使用， 但是因为很多时候我们需要运行模型，但是一个模型可能达到3MiB甚至更大，而固件也是需要占用内存的， 所以为了能运行更大的模型，我们需要妥协裁剪一些不用了的功能。 在前面更新固件的章节介绍了与编译了许多固件版本， 有minimum的， with_v4_support的，也有with_ide_support的， 还有with_lvgl的， 这些固件可能用在不同的场合。比如： 模型现在有两个大版本V3和V4, V4比V3支持更多算子，但是占用更多内存，运行效率也较低，所以如果你的模型是V3的，那就不需要V4支持的固件，这样就可以剩下一些V4代码占用的内存来给模型使用 同样的， 为了支持IDE，也有一部分代码，如果不需要使用 IDE，也可以裁剪掉这部分代码留出空间给模型使用 同样，固件也兼容了 OpenMV 的部分功能，如果使用模型，这些功能可能就不需要，就可以裁剪掉 多线程的支持也如此， 去掉多线程和系统的支持，也可以空出更多内存 所以，如果你在使用某个功能时， 发现提示错误，找不到库，可能是你使用了不包含这个功能的固件，比如minimum固件不包含 IDE 和 image.find_blobs功能， 如果烧录了这个固件， 再去连接 IDE 就会连接失败， 使用iamge.find_blobs这个函数也会提示找不到函数定义 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"firmware/online_compile.html":{"url":"firmware/online_compile.html","title":"在线编译","keywords":"","body":"固件在线编译 在线编译不需要搭建编译环境，只需要选择需要的模块点击编译，编译过程会在云端完成，固件会以邮件的方式发送 访问 maixhub 进行固件定制 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"firmware/compile.html":{"url":"firmware/compile.html","title":"源码编译","keywords":"","body":"源码编译 预编译的固件可能不满足特定的使用场景， 如果需要修改配置，请配置并编译需要的固件 本机环境编译 编译方法请参考 源码下的编译说明 build.md 使用 docker 环境编译 docker 可以简化开发环境安装 如果你没用过 docker， 关于 docker 的知识请自行学习， 在没学习过的情况下你可以认为它和虚拟机类似，即已经为你准备好了带编译环境的虚拟机，直接下载运行就可以用来编译源码了 docker 镜像已经打包好了环境，直接拉取镜像并且运行即可开始编译， 参考 使用 Docker 编译源码 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"course/readme.html":{"url":"course/readme.html","title":"教程说明","keywords":"","body":"MaixPy 手把手教程说明 看本教程之前， 请务必先看左侧目录【入门必看指南】 教程是在认为已经完全掌握了前面的 入门 部分的内容的基础上写的 本教程主要分模块地介绍 MaixPy 包含的功能的使用方法， 在看教程时，可能需要配合 API 文档 和 例程仓库MaixPy_scripts 一同学习 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"course/ai/basic/dnn_basic.html":{"url":"course/ai/basic/dnn_basic.html","title":"深度神经网络基础知识","keywords":"","body":"深度神经网络（DNN）基础知识 这里介绍使用 MaixPy AI 相关功能需要了解的知识，让你能够理解后面的内容， 不在本篇中深入介绍。 如何解决一个问题--引出机器解决问题 一个问题， 通常分为 输入 和 输出（结果） 比如： 坐标系中的一条直线如下， 上面的数据点值是已知的: 现在提问，假如数据点规律不变， 输入一个 x 坐标 20, y 的值是多少？ 按照大家的知识，都知道这是一个一元一次方程(y = kx + b能解决的， 带入两个点的值，算出方程为y = 3x + 10, 那么当 x=20, y 的值为70， 于是输入是20, 输出是70。 这里就是 输入(20) + 算法（一元一次方程） = 输出（70）， 这就是我们在解决一个问题时的基本方法， 所以关键就是找到这个符合这条线段上数据点规律的一个算法。 人类很强大，会从这些数据中归纳总结学习，最终得到了这个算法（方程），然后其他的人直接使用这个算法就可以快速用于解决同类问题，那么，有没有一种方法， 让机器自动去寻找这个算法呢？ 如何让机器总结出算法 要让机器自动总结出算法，即机器学习（ML，Machine Learning）， 我们先看看，人类是如何得到这个算法（方程）的。 步骤1： 首先，有大量数据点，然后人类根据这些数据点发现了直线都符合y = kx + b这个适应所有直线的算法, 但是发现，这里面有两个未知数k和b, 这就是适应任何直线的参数 步骤2： 然后具体的是什么样的直线，因为方程有两个未知数，即参数，将实际的两个数据点带入这个方程，得到了k = 3和b = 10 步骤3： 然后我们用在步骤2中没有用到的在线上的数据点，去试试这个算法（方程）是否正确，最终发现都验证正确 步骤4： 然后要通过x的值知道其它的点的y的值，只需要代入y = 3x + 10 即可 那么，机器学习是不是也可以利用这个步骤来做呢？ 我们认为地设计一个算法结构， 加入我们碰巧直接设计成了y = kx + b， 我们给具体的直线留下了两个参数，我们暂且称呼这个结构叫 模型结构，因为有未知参数，我们称之为未训练的模型结构。其中x称为输入, y称为输出 现在，我们将我们这条直线的的几个点代入到这个方程， 我们称这个过程为 训练，得到y = 3x + 10 这个算法， 已经没有未知参数了， 我们现在称它为模型 或者 训练好的模型，其中k b是模型内的参数，y = kx + b是这个模型的结构。 而带入训练的数据点，就叫做训练数据，它们的统称就叫训练数据集 然后，我们使用几个在 训练 过程中没有用到的在线段上的数据点作为输入，代入这个模型进行运算，得到结果，比如 x = 10, 得到y = 40, 然后对比输出值是否与预期相符，这里我们发现x = 10, y = 40 确实是在图中这条直线上的， 并且训练时没有使用这个点，说明我们得到的模型在此次核验中通过，这个过程叫 验证， x = 10, y = 40 这个数据叫验证数据。 如果我们用多组数据去验证这个模型， 这些数据的统称就叫验证数据集 现在， 我们获得了一个模型，并且用验证数据集对这个模型进行了验证，貌似也是很准确了，那我们就可以假设这个模型基本满足了我们以后有一个x， 要求着图中线上任意一点的y值，都可以输入x给出这条直线上对应点的y坐标。 这个过程我们其实是在使用模型了，这个过程称之为推理 其实这就算是机器学习了， 我们人类需要的事就是设计y = kx + b这个结构，以及给出训练数据集和验证数据集，经过训练和验证得到一个我们认为可用的模型，然后使用输入 + 模型就可以得到认为的正确输出（结果）了。 什么是深度神经网络？ 深度神经网络（DNN）是机器学习（ML）领域中的一种技术。 前面说了一个比较简单的例子， 根据一条直线数据来预测直线上的任何一个点， y = kx + b这个结构是人为设计的， 很简单，当用于复杂的数据，发现它就不适用了，比如“这张图片里面是球还是玩具” 前面为了模型能够存下一条直线的信息， 用了结构y = kx + b，直线的特征都存在模型里面了。 现在用来存一张图的特征，光是y = kx + b这个线性结构， 以及k 和 b两个参数显然无法满足了， 需要设计一个更好的结构， 这时 神经网络 就出现了， 一种网状结构，能更好地记住图片的特征信息， 而这个网状结构又是多层的，也就是有深度的，所以称之为深度神经网络（DNN， deep neural network）， 所以说 DNN 是一种网络结构，是为了实现机器学习的一种手段。 每一层由多个节点组成， 如下图， 一个 DNN 包含了 输入层， 隐藏层， 输出层， 这里隐藏层由三层组成（A[1], A[2], A[3]层），但是统称隐藏层： 输入层： 图中就是一个深度神经网络结构， x 是输入， 比如x这里可以是图片, 输入有多个节点，每个节点可以是一个像素点值， 这里输入层画了 7 个节点， 加入我们有一张图片是 10 x 10的分辨率，则输入层共需要 100 个节点。 这里输入层是一个一维结构，实际情况可能有多维结构， 比如输入如果是一张灰度图片，分辨率3x3，这其实是一个二维结构，即两行两列的矩阵（关于矩阵的概念请自行学习，或者暂且理解成二维数组），比如： [[109 138 110] [220 37 166] [32 243 67] ] 每个像素点的值取值范围∈[0, 255]，然后我们将其平铺后变成共 9 个数据的一维数组给输入层 [109 138 110 220 37 166 32 243 67] 另外， 一般也会将输入层的值归一化到范围[0, 1] 如果是一张彩色图片，那就是三维，即高、宽、颜色通道，颜色通道比如RGB三个颜色通道，即，输入有形状（包含了维度和每个维度的数据数量），比如上面的一维输入形状为(9)，其它图像通常以(高，宽，通道数)来表示形状，比如(10, 10, 3)表示分辨率10 x 10， 并且有三个颜色通道， 比如RGB。 这里为了入门好理解，原理只介绍一维的情况 输出层： y 是输出，这里输出有两个值，你可以理解成就是 MaixPy 的两个浮点值的 list [Y1, Y2]， Y1是是小球的概率，值∈[0, 1], Y2是是玩具的概率。 所以最终我们使用这个模型， 就是给它一张图片， 机器按照这个模型规定的结构和算法进行计算后得到一个 list， 我们根据这个输出的值就知道图中是什么东西了。 隐藏层: 连接输入层和输出层的隐藏层，以及中间的连接，负责了将输入数据推算成合理的输出值。 中间休息，总结 到现在为止， 你知道， 模型是什么：就是一组数据结构，保存了一个网络的形状，以及里面的参数， 通常，这个模型的数据可以被保存成文件，比如.h5 .tflite .kmodel等文件，都是用来阐述这个模型的形状结构和参数，只不过是不同软件使用。 人们只需要设计模型结构以及参数，用来解决一类问题，比如常见的物体分类， 比如就是上面说的区分一张图里面是小球还是玩具。 这个模型里面有很多参数，具体在需要识别物体的时候，使用已知分类的数据集让机器自动训练得出一套合适的模型参数。 然后我们就可以输入数据，让通过模型推理出来输入的数据时什么类别了。 所以， 如果我们不需要训练模型，直接使用别人训练好的模型，只需要： 确认需求，找到现成的模型，因为模型已经是训练好的了，输入和输出的形状的含义都已经定了 确认模型的输入形状，比如模型输入分辨率10x10的彩图，则使用时需要将符合要求的图片传个输入层 确认输出层的含义，比如前面说的识别小球和玩具，最后输出是分别代表是该物体的概率的 list， 比如 [0.9, 0.1], 第一个值代表是小球的概率，那我们就知道这张图里有 90% 的概率是小球， 只有 10% 的概率是玩具 将模型放到推理程序进行运行。 具体用什么程序先不着急，会在下一章介绍 到这里，应该大致上明白了以下东西： 什么是机器学习 什么是深度神经网络（简单概念） 模型是什么 什么是输入层，输出层，在上面举例的分类应用中分别表示什么含义，层形状是什么样的 到此为止，我可能还不知道什么是模型训练 如果我需要一个模型，我知道如何确认需求 所以，如果你只希望能够使用模型，不需要训练，到此即可， 也不需要知道模型有些什么具体的东西，你就把它当成一个黑盒工具箱使用即可。 如果想要更深的了解，请继续看下面的内容。 继续：深度神经网络（续 既然设计了多层设计，那我们继续深入： 数据流 ， 权重， 偏置: 在模型进行推理时，数据从输入层流动到输出层，就是这些网状箭头的方向（第三节网状图），每个箭头前一层到后一层的计算可以用一个熟悉的公式:y = wx + b, 称w为权重(weight), b为偏置（bias）, 注意是每个箭头都有一个单独的w, b, 也就是说后一层节点的值等于前一层节点经过这个公式计算过后的值， 后一层的节点有多个前一层节点指向，那就等于所有前一层节点的值经过这个公式计算后的值的和。 就这样经历了无数次运算后，结果终于在输出层以一个值的形式出现了，整个推理也就完成了 激活函数： 上面的模型虽然可以通过输入得到结果，但是会发现，所有层计算都是线性函数，那么不管有多少层，整体其实还是一个线性函数，即y0 = w1x + b1 + y = w2y0 + b2 ==> y = w2(w1x + b1) + b2 ==> y = w2w1x + w2b1 + b2, 其实还是一个线性函数，那么多层的意义就没有了，于是我们需要在中间加入非线性函数，让网络内部更加复杂一点， 于是就在每个节点上做手脚， 在每个节点输出数据前，先对其用一个非线性函数运算，比如sigmod或者relu函数，别听到名字害怕，其实很简单，看下图, 总之就是 x 和 y 不成线性关系： 即到现在为止， 除了输入层，所有节点输出的值都需要经过Sigmod(∑(Wn * x + Bn)), 输出一个浮点数值 softmax: 输出层在最后输出的时候，因为前面的运算，值的范围不是很统一，虽然我们可以同过比大小，值最大的即认为是答案，但是为了统一而且可以直观地知道每个类别的可能性（另外也为了训练的准确性，这里不讲），正如前面讲到，我们最后输出的一个类别的概率，取值范围∈[0, 1]， 且所有输出的值和为1，所以在输出层后面对输出层的所有值进行处理，公式为 到此，从输入到输出的推理过程就结束了 深度神经网络训练 前面简单介绍了深度神经网络的结构组成， 以及从输入层到输出层的正向过程，在我们使用模型时，就是这个正向过程。 那么，模型定好了，里面的参数（比如w,b）都是随机的值，怎么让它自动训练得到模型中参数的值呢？ 在前面我们讲到， 使用一些我们已知结果的数据输入，来得到参数，同样地，这里我们也输入已知结果的数据，得到第一次的输出结果 判定输出正确性(accuracy)（或者说误差/loss） 和 损失函数： 在输出层得出结果，比如得到了[0.6, 0.4] 代表是小球的概率0.9, 是玩具的概率0.1, 但是因为是已知答案的数据， 实际正确答案是[1.0, 0.0], 这明显不符合要求。 所以我们得出正确答案和推算的答案的误差为： [0.4, -0.4], 但是发现一个问题就是这个误差值的范围不太好看，要是误差的取值范围∈[0, ∞] 就好了。 在高中数学中有个函数y = log10(x), 坐标图如下： 发现x取值∈[0, 1]时， -y的取值刚好∈[0, ∞]， 而我们的输出结果也刚好∈[0, 1]！ 所以，我们直接这样计算误差： error = -log10(输出)， 也就是输出越接近1，误差就越接近 0，这种方法称之为交叉熵损失（CEE, Cross Entropy Error)， 除了这种方法还有其它的比如均方误差（MSE，Mean Squared Error）等 至此，我们知道了现在结果和实际结果的误差 误差的反向传播 和 参数优化（权重更新）： 因为模型的参数还不符合我们的预期， 那我们需要对参数进行修正，我们使用反向传播的方式。 前面我们得出了误差， 因为参数不够正确， 我们用这个误差去修改模型中的参数，来达到微调模型内参数的效果。 就好像你在开一个水龙头， 水打了（即误差大了），就把开关拧紧一点，小了就拧松一点，对其做调整。 就像我们正向推算一样，这次换成了反向，从后往前，可以得到在每个节点处的误差值，然后再根据一定的学习率去更新模型内参数。这里暂时就不仔细展开讲了。 总之，经过一轮反向的调整参数之后，得到了新的模型 衡量模型好坏：训练集误差和验证集误差： 我们使用训练数据集里面的数据反复去进行正向推理得出误差，然后反向调整这个过程，在使用完训练数据集后，可能会得到误差比较小，但是这只能说明这个模型对这批数据来说比较准确，换一些新的数据可能就不准确了，所以我们要用一些训练集里没有的数据去验证模型的效果： 我们使用 验证数据集 去正向推算，得到误差，因为验证数据集没有参与训练，也就是说现在模型的参数和验证数据集没有任何关系，我们用这个得到的误差来恒定这个模型的好坏，误差越小则认为效果越好 多次迭代： 如果将所有数据集训练完了，发现误差依然很大，那么可以用多次训练的方法来继续训练，即多次迭代，每次迭代完成后都用 验证数据集 去验证效果如何， 如果训练集的误差和验证集的误差都足够小，我们就可以暂且认为模型已经有不错的效果了。 测试集： 这时，我们就可以用又一批新的数据去测试我们的模型效果如何，因为这是全新的数据，没有参与到训练也没参与到验证（即确定什么时候停止训练），理论上更有公信力。如果测试误差较小，那么训练就算成功了 优化训练： 如果最终效果不太好， 有很多地方可以调整， 比如 训练迭代的次数，并不是越多越好，过多的在一批数据集上训练可能导致模型只对这批数据有效，泛化能力不够， 也就是过度拟合 每次训练的学习率也可以调整 检查数据集，是否有一些影响分类的数据存在 优化网络结构，不管是输入输出还是内部结构和参数，根据不同的数据和任务可以有更优的设计，也叫特征工程 说在最后 到这里，应该大致上明白了以下东西： 什么是机器学习 什么是深度神经网络 模型是什么 什么是输入层，输出层，在上面举例的分类应用中分别表示什么含义，层形状是什么样的 什么是训练，有什么作用 数据训练集，验证集，测试集分别是什么，用在什么地方，需要注意什么 衡量模型好坏的标准是什么 如果还不明白的，可以再仔细理解一遍，或者查阅相关资料，如果你发现有更好的阐述方法，欢迎按照左边目录的文档贡献方法参与贡献 修改记录 日期 作者 备注 2020.11.17 neucrack 初始版本，根据 MaixPy 的需要介绍深度神经网络基本概念，初稿 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"course/ai/basic/maixpy_hardware_ai_basic.html":{"url":"course/ai/basic/maixpy_hardware_ai_basic.html","title":"MaixPy AI 硬件加速基础知识","keywords":"","body":"MaixPy AI 硬件加速基本知识 模型使用和硬件加速原理 前面我们知道了模型是一个数据机构以及很多参数， 最终以一个文件比如kmodel格式的文件的形式存在。 而这个模型要能在 MaixPy 的程序里面被使用， 首先需要程序能够理解kmodel这个文件的格式， 并且支持模型里面的算法，这样才能按照模型的描述将输入经过一些裂计算过程后得到输出。 所以，重点就是支持模型里面的算法，称算子， 理论上，我们可以用软件去实现这些算子， 就可以成功运行模型了， 而执行软件的物理器件是CPU， 神经网络模型的计算量很大，加上我们输入的是图片，图片本身的数据量就挺庞大， 就算是K210 400MHz 的主频， 也无法满足流畅的推算模型。 所以， 要么升级 CPU，但是成本太高， 要么做一个专用的硬件， 让这个硬件专门去特定的算法，因为不像 CPU 一样要做通用计算， 所以速度会非常快，在电脑上， 我们通常使用专用的图像加速卡即GPU来加速图形计算， 在K210上，这个专门的硬件叫做KPU（kendryte proccess unit)，第一个但是是公司名， 其实和其它芯片的NPU做的事情是一样的。 在 MaixPy 里面，已经集成了推导模型的代码，同时使用了KPU进行计算加速，使用时无需编写很多代码，只需要调用几个函数即可快速运行模型 关于 KPU 虽然 KPU 是能够加速模型运算了， 但是由于成本、时间、功耗、体积、发热、应用领域定位等各种因素，它的能力并不能像专业领域的强力NPU一样，包含了每一种算子，它只能处理一部分。 KPU 实现了卷积，批归一化，激活，池化 这4钟基础操作的硬件加速， 但是它们不能分开单独使用，是一体的加速模块。 所以， 在 KPU 上面推理模型， 以下要求（如果不需要训练和设计模型，暂时不需要仔细了解）： 内存限制 K210 有 6MB 通用 RAM 和 2MB KPU 专用 RAM。模型的输入和输出特征图存储在 2MB KPU RAM 中。权重和其他参数存储在 6MB 通用 RAM 中。 哪些算子可以被 KPU 完全加速？ 下面的约束需要全部满足。 特征图尺寸：输入特征图小于等于 320x240(WxH) 同时输出特征图大于等于 4x4(WxH)，通道数在 1 到 1024。 Same 对称 paddings (TensorFlow 在 stride=2 同时尺寸为偶数时使用非对称 paddings)。 普通 Conv2D 和 DepthwiseConv2D，卷积核为 1x1 或 3x3，stride 为 1 或 2。 MaxPool(2x2 或 4x4) 和 AveragePool(2x2 或 4x4)。 任意逐元素激活函数 (ReLU, ReLU6, LeakyRelu, Sigmoid...), KPU 不支持 PReLU。 哪些算子可以被 KPU 部分加速？ 非对称 paddings 或 valid paddings 卷积, nncase 会在其前后添加必要的 Pad 和 Crop。 普通 Conv2D 和 DepthwiseConv2D，卷积核为 1x1 或 3x3，但 stride 不是 1 或 2. nncase 会把它分解为 KPUConv2D 和一个 StridedSlice (可能还需要 Pad)。 MatMul, nncase 会把它替换为一个 Pad(到 4x4)+ KPUConv2D(1x1 卷积和) + Crop(到 1x1)。 TransposeConv2D, nncase 会把它替换为一个 SpaceToBatch + KPUConv2D + BatchToSpace。 说明来自这里 模型转换 前面说到， 模型其实就是一组结构和参数数据，不同的软件只能识别特定格式的模型， KPU 只认.kmodel格式的模型， 一般用电脑训练的模型则不是， 比如tensorflow是.h5格式或者.tflite格式， 要给KPU使用， 必须经过变成kmodel, 使用nncase这个工具来达到模型转换的目的 如果你需要转换模型， 具体使用方法看这个仓库里面的介绍 kmodel V3 模型 和 V4 模型 由于代码更新， 在过程中产生了两个大版本,V3 和 V4， 其中V3模型是指用 nncase v0.1.0 RC5 转换出来的模型; V4模型指用nncase v0.2.0转换出来的模型 两者有一定的不同，所以现在两者公存， V3代码量更少，占用内存小，效率也高，但是支持的算子少; V4支持的算子更多，但是都是软件实现的，没有硬件加速，内存使用更多，所以各有所长。 MaixPy 的固件也可以选择是否支持 V4。 MaixPy 中使用模型 kmodel 加载 SD 卡 （TF 卡）中的模型 将模型放到 SD 卡， 然后加载 import KPU as kpu m = kpu.load(\"/sd/test.kmodel\") 加载 Flash 中的模型 将模型下载到 Flash， 然后加载 import KPU as kpu model_addr_in_flash = 0x300000 m = kpu.load(model_addr_in_flash) 此处的 model_addr_in_flash 为模型在 Flash 中的偏移地址，模型可以通过 kflash.py 或者 kflash_gui 烧录到 Flash 对应的地址中 准备输入 一般情况下，我们会使用图像作为输入： 直接使用摄像头采集的数据作为输入：img = sensor.snapshot() 这里 img 就可以直接作为输入， 这里需要注意：snapshot函数采集到图片后，会将图片数据放到两个地方 (1) RGB565内存块， 图像以 RGB565的形式存放在一块内存中，方便图像处理的函数使用，注意在内存中的排序是[像素1 RGB, 像素2 RGB...] (2) RGB888内存块， 图像以R8G8B8的形式存放在另一块内存中，注意在内存中的排序是[所有像素 R, 所有像素 G， 所有像素 B], 我们也称之为AI内存 其中，实际上作为 KPU 输入的数据是RGB888区域， 这个在前面的文档 MaixPy 图像及常用操作 章节中有仔细讲解过 从文件读取，或者修改过的摄像头图像 直接从摄像头采集的图像会自动填充RGB888区域，但是我们使用图像处理函数比如image.resize()时，只会修改RGB565，没有修改RGB888,因为同时修改两处内存需要耗费大量时间，而 KPU 的输入又是RGB888内存， 所以在需要进行 KPU 运算时， 需要同步（刷新）一下RGB888内存块， 使用img.pix_to_ai()来进行同步，否则修改对 KPU没有生效。 比如： img = sensor.snapshot() img = img.resize(240, 240) img.pix_to_ai() img = image.Imag(\"/sd/test.jpg\") img.pix_to_ai() 前向运行模型 前向运行模型，也就是按照 输入到输出的方向走一边模型计算， 通过输入得出输出的值： feature_map = kpu.forward(m, img) 这里得到了feature_map， 是一个特征图， 比如我们前面将的小球和玩具的分类，输出特征图是两个节点， 每个节点表示了是对应物体的概率，我们将特征图转换为list对象 p_list = feature_map[:] print(p_list) 就可以得到类似 [0.9, 0.1] 这样的结果了 KPU使用过程中的常见问题 KPU能够加载多大的模型？ C 语言代码运行模型： 当k210运行 c 代码时，能够加载 * 当运行 MaixPy(minimum版本)时，能够加载4MB左右的模型。 如果不使用摄像头和 LCD， 最大可以加载 5MiB 左右的模型（因为摄像头和 LCD 的缓冲区占用了很多内存，但实际应用也没多大意义了） * 当运行 MaixPy(完整版)时，能够加载 2MiB 左右的模型 * 另外也支持实时从`Flash`加载模型， 理论上只要单层使用内存不超过 2MiB， 整体模型可以无限大，只不过要牺牲一点运算速度。 使用方法看[这里](https://github.com/sipeed/MaixPy_scripts/tree/master/machine_vision/load_big_model)。 如果对原理和实现感兴趣，可以看[这里](https://neucrack.com/p/313) 报错\"memory overflow\"怎么办？ 出现这个问题，根据前面讲到过的系统内存管理可知，一般有两个可能性： 报错的地方跟系统堆无关系， 可能是GC内存不够导致，可是适当增加 GC 的总内存大小 由于模型过大引起的。可以依次尝试如下解决方案: 更换maixpy mini版本固件 进行模型剪枝优化 使用 kpu.load_flash接口运行时实时加载模型，只是执行效率降低一点 如果内存不足，而且kpu.load_flash性能无法满足， 那么你可能需要使用 C SDK进行开发。 报错\"load error,only support kmodel v3/v4\"怎么办？ 出现这个问题可以尝试如下解决方案: 如果为加载 Flash 中的模型，请确保 flash offset 填写正确，并保证和 maixpy 固件的地址没有冲突（模型在 Flash 中的地址太靠前，然后往 Flash 烧录入固件时， 固件大小超过了模型所在的起始地址， 导致模型被破坏） 如果是采用 nncase 0.2.0进行转换的 kmodel V4，请尝试采用nncase 0.1.0进行转换，从而生成kmodel V3 我想实现不同模型的选择加载(例如按下按钮运行目标分类，再次按下按钮则运行目标检测)，应该怎么写程序？ 因为内部RAM有限，所以当需要切换不同模型进行kpu.load(address)前，请先执行kpu.deinit(k210model)释放之前模型占用的内存，然后再加载新的模型。 也就是分时复用内存 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"course/ai/image/face_detect.html":{"url":"course/ai/image/face_detect.html","title":"人脸检测","keywords":"","body":"人脸检测 在一张图片中找出人脸， 并且框出人脸，即知道脸的位置和大小 使用了YOLO V2模型对人脸进行检测 使用方法： 下载模型： 到这里 下载 face_model_at_0x300000.kfpkg 这个模型文件 用 kflash_gui 下载模型到 Flash， 或者放到 SD 卡中 加载模型task = kpu.load(0x300000) # task = kpu.load(\"/sd/face.kmodel\") anchor = (1.889, 2.5245, 2.9465, 3.94056, 3.99987, 5.3658, 5.155437, 6.92275, 6.718375, 9.01025) kpu.init_yolo2(task, 0.5, 0.3, 5, anchor) 因为使用了YOLO V2这个模型， 它有专用的函数接口， 使用init_yolo2来初始化模型 参数分别为： kpu_net: kpu 网络对象, 即加载的模型对象, KPU.load()的返回值 threshold: 概率阈值， 只有是这个物体的概率大于这个值才会输出结果， 取值范围：[0, 1] nms_value: box_iou 门限, 为了防止同一个物体被框出多个框，当在同一个物体上框出了两个框，这两个框的交叉区域占两个框总占用面积的比例 如果小于这个值时， 就取其中概率最大的一个框 anchor_num: anchor 的锚点数， 这里固定为 len(anchors)//2 anchor: 锚点参数与模型参数一致，同一个模型这个参数是固定的，和模型绑定的（训练模型时即确定了）， 不能改成其它值。 然后输入图片数据，运行模型 code = kpu.run_yolo2(task, img) 得到结果， 完整例程看这里 API 文档看 Maix.KPU powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"course/ai/image/1000_type_classifier.html":{"url":"course/ai/image/1000_type_classifier.html","title":"1000 种物体分类","keywords":"","body":"1000 种物体分类模型 可以识别 1000 种物体 使用方法 使用minimum 版本固件 下载模型文件, 下载mobilenet_0x300000.kfpkg 使用 kflash_gui 烧录这个文件到 Flash， 默认地址是 0x300000 保存文件labels.txt (备用链接) 到文件系统，具体方法见入门教程（发挥你的聪明才智）（参考答案：因为内容太多，如果使用 REPL 直接复制粘贴可能数据会出错， 所以要使用 工具传输。最简单的是放到 SD 卡； 如果要放到 /flash，minimum 可能不支持 IDE， 可以使用upyloader发送文件） 因为这个模型有4.2MiB，比较大，所以使用了minimum的固件，同时保证GC使用的内存不要太大，可以通过以下方式设置小一点,把内存留给模型使用 from Maix import utils import machine utils.gc_heap_size(256*1024) machine.reset() 导入模型 import KPU as kpu task = kpu.load(0x300000) 读入 labels f=open('/sd/labels.txt','r') labels=f.readlines() f.close() 初始化摄像头, LCD 可以根据自己的硬件安装情况设置摄像头是否镜像，以及 LCD 是否旋转等 略，请参考前面的教程 识别物体 fmap = kpu.forward(task, img) plist=fmap[:] pmax=max(plist) max_index=plist.index(pmax) 这里把运行的结果转换成了一个list对象， 然后找到了最大值的下标， 通过这个下标我们就知道标签名是什么了（labels[max_index]） 显示结果 img = img.draw_string(0, 0, \"%.2f : %s\" %(pmax, labels[max_index].strip()), color=(255, 0, 0)) lcd.display(img, oft=(0,0)) print(fps) 完整例程看 maixpy_scripts powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"course/ai/image/face_recognization.html":{"url":"course/ai/image/face_recognization.html","title":"人脸识别","keywords":"","body":"人脸识别 除了检测到人脸的位置以外， 还可以识别到这个人是谁（需要先对准人按按钮学习） 效果视频： youtube 或者 bilibili 使用方法 从 maixhub 按照说明下载模型， 获得模型smodel, 就是 加密版本的kmodel 按照入门教程的方法下载模型到开发板 运行脚本 script 程序理解 总共用了三个模型， 分别是： 人脸检测模型， 这和前面的人脸检测使用的是同一个模型， 即找到人脸 人脸关键点检测模型，从前面找到的人脸中找到人脸的 眼睛 鼻子 和 嘴巴 的位置 人脸特征提取模型， 从一张人脸图片中得出一个特征值 步骤如下： 检测到人脸 裁出人脸，找到人脸的眼睛鼻子嘴巴， 这里裁成了128x128的图 把人脸图中的脸旋转到标准位置 用特征提取模型提取出人脸的特征值 有了前面的基础， 这里的程序就能看懂了，也就不再进行详细的阐述了，只不过是从之前的使用一个模型，变成了按照顺序分别使用三个模型，再加上一点简单的图像裁减和旋转处理，都是调用API，仔细看一遍代码就知道具体的细节是如何实现的了 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"course/ai/image/self_learn_classifier.html":{"url":"course/ai/image/self_learn_classifier.html","title":"自学习分类","keywords":"","body":"自学习分类器（self learning classifier） 无需单独训练， 直接在开发板上对物体特征进行学习，然后直接使用 演示视频： youtube 或者 bilibili 使用方法 在这里 下载版本 >= v0.5.0-33 的固件 下载 kmodel 使用 kflash_gui 下载固件和模型 运行 示例脚本 然后运行启动后开始学习物体 按开发板上的 boot 按钮 来捕获 3 个类别 手机, 小车, 键盘， 每个类别只需要捕获一次 然后捕获 15 张图， 对顺序没有要求， 比如捕获 5 张 手机, 5 张 小车 ， 5 张 键盘 的图片 然后它会自动学习这 15 张图的特征 最后识别到的图像类别会展示在左上角 保存/加载学习好的特征 使用 classifier.save(path) 来保存学习好的特征到path文件 使用 KPU.classifier.load() 来加载特征, 参考 self_learning_classifier_load.py 文件 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"course/speech/recognizer_cnn.html":{"url":"course/speech/recognizer_cnn.html","title":"语音识别","keywords":"","body":"maix asr 本文档在 MaixPy 0.5.1_128 minimum_speech_with_ide_support 固件测试通过，使用前请确保录音功能/调用模型可用。 这是一个基于声学模型的语音识别模块，用户设置拼音组成的词汇加载到模块中，就可以开始录音识别用户输入的词汇，并返回可能匹配的词汇列表。 使用方法 警告 不会【使用录音】和【调用模型】的同学，请先去学习前置技能再来使用本篇文档。 烧录声学模型 TODO 之后存放到下载站统一链接。 从这里获取声学模型maix_asr_2900k_0x500000, 烧录到 0x500000 地址即可。 没有烧模型就加载模块会 core dump ，不要跑来问怎么报错了。 创建录音设备 本模块支持所有 Maix 系列硬件使用，我们只需要配置一个 I2S.DEVICE_0 设备，并设置 CHANNEL_0 通道到录音输入就可以了，如果是 Cube 和 amigo 则需要先配置具体的音频解码芯片，再打开 I2C 录音设备。 from Maix import GPIO, I2S from fpioa_manager import fm fm.register(20,fm.fpioa.I2S0_IN_D0, force=True) fm.register(18,fm.fpioa.I2S0_SCLK, force=True) # dock 32 fm.register(19,fm.fpioa.I2S0_WS, force=True) # dock 30 rx = I2S(I2S.DEVICE_0) rx.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode=I2S.STANDARD_MODE) rx.set_sample_rate(16000) print(rx) 运行示例代码 请将代码拉到底，这里创建了一个 maix_asr 的辅助类，可以跳过不看。 from speech_recognizer import asr class maix_asr(asr): asr_vocab = [\"lv\", \"shi\", \"yang\", \"chun\", \"yan\", \"jing\", \"da\", \"kuai\", \"wen\", \"zhang\", \"de\", \"di\", \"se\", \"si\", \"yue\", \"lin\", \"luan\", \"geng\", \"xian\", \"huo\", \"xiu\", \"mei\", \"yi\", \"ang\", \"ran\", \"ta\", \"jin\", \"ping\", \"yao\", \"bu\", \"li\", \"liang\", \"zai\", \"yong\", \"dao\", \"shang\", \"xia\", \"fan\", \"teng\", \"dong\", \"she\", \"xing\", \"zhuang\", \"ru\", \"hai\", \"tun\", \"zhi\", \"tou\", \"you\", \"ling\", \"pao\", \"hao\", \"le\", \"zha\", \"zen\", \"me\", \"zheng\", \"cai\", \"ya\", \"shu\", \"tuo\", \"qu\", \"fu\", \"guang\", \"bang\", \"zi\", \"chong\", \"shui\", \"cuan\", \"ke\", \"shei\", \"wan\", \"hou\", \"zhao\", \"jian\", \"zuo\", \"cu\", \"hei\", \"yu\", \"ce\", \"ming\", \"dui\", \"cheng\", \"men\", \"wo\", \"bei\", \"dai\", \"zhe\", \"hu\", \"jiao\", \"pang\", \"ji\", \"lao\", \"nong\", \"kang\", \"yuan\", \"chao\", \"hui\", \"xiang\", \"bing\", \"qi\", \"chang\", \"nian\", \"jia\", \"tu\", \"bi\", \"pin\", \"xi\", \"zou\", \"chu\", \"cun\", \"wang\", \"na\", \"ge\", \"an\", \"ning\", \"tian\", \"xiao\", \"zhong\", \"shen\", \"nan\", \"er\", \"ri\", \"zhu\", \"xin\", \"wai\", \"luo\", \"gang\", \"qing\", \"xun\", \"te\", \"cong\", \"gan\", \"lai\", \"he\", \"dan\", \"wei\", \"die\", \"kai\", \"ci\", \"gu\", \"neng\", \"ba\", \"bao\", \"xue\", \"shuai\", \"dou\", \"cao\", \"mao\", \"bo\", \"zhou\", \"lie\", \"qie\", \"ju\", \"chuan\", \"guo\", \"lan\", \"ni\", \"tang\", \"ban\", \"su\", \"quan\", \"huan\", \"ying\", \"a\", \"min\", \"meng\", \"wu\", \"tai\", \"hua\", \"xie\", \"pai\", \"huang\", \"gua\", \"jiang\", \"pian\", \"ma\", \"jie\", \"wa\", \"san\", \"ka\", \"zong\", \"nv\", \"gao\", \"ye\", \"biao\", \"bie\", \"zui\", \"ren\", \"jun\", \"duo\", \"ze\", \"tan\", \"mu\", \"gui\", \"qiu\", \"bai\", \"sang\", \"jiu\", \"yin\", \"huai\", \"rang\", \"zan\", \"shuo\", \"sha\", \"ben\", \"yun\", \"la\", \"cuo\", \"hang\", \"ha\", \"tuan\", \"gong\", \"shan\", \"ai\", \"kou\", \"zhen\", \"qiong\", \"ding\", \"dang\", \"que\", \"weng\", \"qian\", \"feng\", \"jue\", \"zhuan\", \"ceng\", \"zu\", \"bian\", \"nei\", \"sheng\", \"chan\", \"zao\", \"fang\", \"qin\", \"e\", \"lian\", \"fa\", \"lu\", \"sun\", \"xu\", \"deng\", \"guan\", \"shou\", \"mo\", \"zhan\", \"po\", \"pi\", \"gun\", \"shuang\", \"qiang\", \"kao\", \"hong\", \"kan\", \"dian\", \"kong\", \"pei\", \"tong\", \"ting\", \"zang\", \"kuang\", \"reng\", \"ti\", \"pan\", \"heng\", \"chi\", \"lun\", \"kun\", \"han\", \"lei\", \"zuan\", \"man\", \"sen\", \"duan\", \"leng\", \"sui\", \"gai\", \"ga\", \"fou\", \"kuo\", \"ou\", \"suo\", \"sou\", \"nu\", \"du\", \"mian\", \"chou\", \"hen\", \"kua\", \"shao\", \"rou\", \"xuan\", \"can\", \"sai\", \"dun\", \"niao\", \"chui\", \"chen\", \"hun\", \"peng\", \"fen\", \"cang\", \"gen\", \"shua\", \"chuo\", \"shun\", \"cha\", \"gou\", \"mai\", \"liu\", \"diao\", \"tao\", \"niu\", \"mi\", \"chai\", \"long\", \"guai\", \"xiong\", \"mou\", \"rong\", \"ku\", \"song\", \"che\", \"sao\", \"piao\", \"pu\", \"tui\", \"lang\", \"chuang\", \"keng\", \"liao\", \"miao\", \"zhui\", \"nai\", \"lou\", \"bin\", \"juan\", \"zhua\", \"run\", \"zeng\", \"ao\", \"re\", \"pa\", \"qun\", \"lia\", \"cou\", \"tie\", \"zhai\", \"kuan\", \"kui\", \"cui\", \"mie\", \"fei\", \"tiao\", \"nuo\", \"gei\", \"ca\", \"zhun\", \"nie\", \"mang\", \"zhuo\", \"pen\", \"zun\", \"niang\", \"suan\", \"nao\", \"ruan\", \"qiao\", \"fo\", \"rui\", \"rao\", \"ruo\", \"zei\", \"en\", \"za\", \"diu\", \"nve\", \"sa\", \"nin\", \"shai\", \"nen\", \"ken\", \"chuai\", \"shuan\", \"beng\", \"ne\", \"lve\", \"qia\", \"jiong\", \"pie\", \"seng\", \"nuan\", \"nang\", \"miu\", \"pou\", \"cen\", \"dia\", \"o\", \"zhuai\", \"yo\", \"dei\", \"n\", \"ei\", \"nou\", \"bia\", \"eng\", \"den\", \"_\"] def get_asr_list(string='xiao-ai-fas-tong-xue'): return [__class__.asr_vocab.index(t) for t in string.split('-') if t in __class__.asr_vocab] def get_asr_string(listobj=[117, 214, 257, 144]): return '-'.join([__class__.asr_vocab[t] for t in listobj if t 对麦克风说话 我们可以看到代码中定义了以下词汇： t.config({ 'xiao-ai-ya' : 0.3, 'hao-de-ya' : 0.2, 'ni-hao-ya' : 0.3, }) print(t.get()) 也就是你对着麦克风在 6 秒内，说【你-好-鸭】、【好-的-鸭】、【小-爱-鸭】就可以完成识别了，配置项为两个字段，第一个字段长度不超过六组拼音，第二个字段表示识别的最低门限，也就是匹配值的阈值，低于该值就丢弃。 最开始测试的时候，说话可以大声一点，具体效果看演示视频。 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"course/ai/train/maixhub.html":{"url":"course/ai/train/maixhub.html","title":"MaixHub 云端训练","keywords":"","body":"Maixhub 模型训练 Maixhub 提供模型训练功能和模型分享功能， 只需要准备好需要训练的数据集， 不需要搭建训练环境和代码， 上传训练数据即可快速训练出模型 目前 Maixhub 支持分类模型 和 目标检测模型的训练。 你需要做的： 确定目标， 是分类还是检测 根据使用说明制作符合要求的数据集 上传数据集等待云端自动训练 训练完成， 结果会通过邮件进行通知， 不管是成功还是失败，都会有邮件通知，里面有详细的任务信息和结果文件 Maixhub 使用说明参考 Maixhub 训练使用说明 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"course/ai/train/local.html":{"url":"course/ai/train/local.html","title":"本地训练","keywords":"","body":"本地模型训练 本地模型训练使用 sipeed/maix_train 这份代码进行， 使用了 Tensorflow 作为训练框架 主要支持： 物体分类模型（使用 Mobilenet V1）： 只识别图片中的物体是什么 物体检测模型（使用 YOLO V2）： 找到图片中认识的图体，并同时找到其坐标和大小 系统环境 首先，需要一台有 Linux 系统的电脑 如果你的主力系统是 Windows， 你可以用以下系统环境： 使用虚拟机, virtual box 或者 vmware 都可以， 系统推荐安装Ubuntu20.04 或者安装双系统，安装方法请自行搜索学习，或者看这个双系统安装教程 使用 Windows 子系统 安装Ubuntu 20.04, 教程看[这里] 你可能想着在 Windows 下面进行开发， 但是这里强烈建议使用Linux而不是Windows： 首先，大多数模型训练框架都是首先支持 Linux， 在Linux下面开发的难度会比Windows下开发更加容易 作为一个开发者， 学会使用Linux是基础技能，当然，除非你是Windows狂热粉， 那我相信你一定有把其它系统的软件移植到Windows的能力 软件安装 训练可以使用 CPU 进行训练，但是速度比较慢， 如果使用专用的显卡（GPU）进行加速，速度会快非常多，个人一般使用Nvidia的显卡， 比如RTX 3090， 当然，使用普通的GTX 1060 6G内存版本就可以愉快使用了 初次接触，建议先使用 CPU 进行训练，环境安装会简单很多很多， 以下只讲 CPU 训练的方法， GPU 请自行学习 GPU 使用可以参考 Tensorflow 官方 GPU 使用教程， 如果你显卡驱动遇到了问题，可以参考这里， 另外如果你用 docker 安装遇到了问题， 也可以看这里 接下来的使用方法摘抄于仓库的 README, 如果有出入， 以仓库的README为准，注意分辨 将训练代码克隆到本地 git clone https://github.com/sipeed/maix_train --recursive 安装依赖 cd maix_train pip3 install -r requirements.txt 中国用户可以使用阿里云或者清华的源， 下载速度更快 pip3 install -r requirements.txt -i https://mirrors.aliyun.com/pypi/simple/ 下载 nncase v0.1.0-rc5 并解压到 maix_train/tools/ncc/ncc_v0.1, 保证可执行文件的路径是 maix_train/tools/ncc/ncc_v0.1/ncc 配置工程 先初始化工程 python3 train.py init 然后根据你的硬件情况，编辑maix_train/instance/config.py配置 准备数据集 准备数据集， 图片大小为 224x224， 格式可以参考maix_train/datasets下的数据集示例 也可以看 Maxhub 的数据集要求 训练分类模型 python3 train.py -t classifier -z datasets/test_classifier_datasets.zip train 或者解压数据集到文件夹，指定数据集文件夹 python3 train.py -t classifier -d datasets/test_classifier_datasets train 训练目标检测模型 python3 train.py -t detector -z datasets/test_detector_xml_format.zip train 使用模型 和使用Maixhub训练的模型一样， 在out文件夹会生成一个zip文件，里面包含了结果，把所有文件拷贝到SD卡根目录，然后开发板上电运行即可 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"course/speech/recognizer_mfcc.html":{"url":"course/speech/recognizer_mfcc.html","title":"关键词识别","keywords":"","body":"isolated word 本文档在 MaixPy 0.5.1_128 minimum_speech_with_ide_support 固件测试通过，使用前请确保硬件录音功能可用。 这是一个孤立词识别的算法模块,用户通过录音生成词汇模板加载到模块中，再通过它识别到用户加载的词汇模板，并返回匹配的可能性，实现请参考基于STM32的孤立词语音识别。 孤立词识别 按照语音发音方式来分，有孤立词识别、连接词识别、连续语音识别 3 种；所谓孤立词识别（Isolated Word Recognition）是指在发待识别音时，每次只含词汇表中的一个词条。 词汇模板 我们将一段用人声说出的词汇录音下来，通过算法制作成可识别的模板，称为词汇模板。 模板匹配 假设算法模块加载了词汇模板，我们通过录音输入数据给算法模块后，它会进行内部匹配得到最有可能的识别结果。 本模块具体识别流程是：预滤波、ADC、分帧、端点检测、预加重、加窗、特征提取、特征匹配。端点检测(VAD)采用短时幅度和短时过零率相结合。检测出有效语音后，根据人耳听觉感知特性，计算每帧语音的Mel频率倒谱系数(MFCC)。然后采用动态时间弯折(DTW)算法与特征模板相匹配，最终输出识别结果。 如何使用？ 目前硬件支持程度：Maix BIT / DOCK / DUINO / GO 。 截至 20201123 由于 Cube & Amigo 经过 ES8374 后，麦克风底噪过大会被判断为噪音环境，还需要修复。 开箱即用示例代码 使用 maixduino / maixbit 的测试用例 isolated_word.py，使用方法请阅读代码，请注意硬件的 麦克风 配置 和 声道 配置。 Maix DOCK 可直接使用的示例代码demo_isolated_word_on_maixdock.py，按屏幕提示说话即可，具体看测试录像。 模块调用流程 为了能够更好地使用本模块，请了解使用流程。 准备 I2S 录音模块 配置一个 I2S.DEVICE_0 设备，并设置 CHANNEL_0 通道到录音输入。 from Maix import GPIO, I2S from fpioa_manager import fm fm.register(20,fm.fpioa.I2S0_IN_D0, force=True) fm.register(18,fm.fpioa.I2S0_SCLK, force=True) # dock 32 fm.register(19,fm.fpioa.I2S0_WS, force=True) # dock 30 rx = I2S(I2S.DEVICE_0) rx.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode=I2S.STANDARD_MODE) rx.set_sample_rate(16000) print(rx) 运行结果： [MAIXPY]i2s0:(sampling rate=16003, sampling points=1024) [MAIXPY]channle0:(resolution=2, cycles=2, align_mode=1, mode=1) [MAIXPY]channle1:(resolution=0, cycles=0, align_mode=0, mode=0) [MAIXPY]channle2:(resolution=0, cycles=0, align_mode=0, mode=0) [MAIXPY]channle3:(resolution=0, cycles=0, align_mode=0, mode=0) 创建 孤立词 模块 isolated_word 初始化的参数如下： [dmac] 录音所使用的 DMA 通道，默认使用【通道 2】。 [i2s] 录音设备，默认使用 I2S.DEVICE_0 。 [size] 词汇模板容量，表示可以加载的模板总数，默认为 10 个。 [shift] 声道选择，Maix 系列的硬件录音设备通常为单声道输入，设置 0 为左声道，所以 1 为右声道。 from speech_recognizer import isolated_word # default: maix dock / maix duino set shift=0 sr = isolated_word(dmac=2, i2s=I2S.DEVICE_0, size=10, shift=0) # maix bit set shift=1 print(sr.size()) print(sr) ## threshold sr.set_threshold(0, 0, 10000) 运行结果如下： 10 [MAIXPY] isolated_word:(80212a60) mfcc_dats=8023a060 size=10 i2s_device_number_t=0 dmac_channel_number_t=2 录入词汇模板 调用如下代码： 如果周围环境很嘈杂，它就会反复输出 2 (isolated_word.Ready) 到 3 (isolated_word.MaybeNoise) ，需要处于安静环境下才能录入词汇模板 如果状态为 isolated_word.Speak 则表示你可以说话了 如果运行 sr.record(0) 它状态变成了 isolated_word.Done 则表示录入完成，并保存到编号 0 的模板。 你可以通过 sr.state() 可以查看当前模块的状态 ## record and get & set while True: time.sleep_ms(100) print(sr.state()) if sr.Done == sr.record(0): data = sr.get(0) print(data) break if sr.Speak == sr.state(): print('speak A') #sr.set(1, data) 同理，如果你要录入第二个【词汇模板】，只需要改变录入的位置，如改成 sr.record(1)（计算机存储数组从 0 开始计数）。 识别词汇模板 假设你已经录入了【词汇模板】则调用如下代码，它会持续识别当前的声音开始匹配录入的【词汇模板】，也就是所谓的孤立词语音识别。 print('recognizer') while True: time.sleep_ms(200) #print(sr.state()) #print(sr.dtw(data)) if sr.Done == sr.recognize(): res = sr.result() print(res) 最终呈现的效果就是打印出最优匹配的【词汇模板】编号以及相关数据，具体请查看 result 函数用法，可以根据实际情况来判断本次识别是否合理，如匹配的帧长/匹配度是否符合预期，过大或过小都是不合理的。 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"develop_kit_board/module_microphone.html":{"url":"develop_kit_board/module_microphone.html","title":"Sipeed 麦克风阵列","keywords":"","body":"Sipeed Microphone Sipeed 麦克风模块 描述 实物图 说明 单麦克风模块 点击购买 麦克风模块 1.麦克风 IC: MSM261S4030H0 2.接口：6P 2.54mm 排线接口 3.供电电压：3.3V@5mA 4.模块尺寸：15.2mm*9.1mm 4.工作温度: -30℃~80℃ 单麦克风模块 点击购买 麦克风模块 1.麦克风 IC: 6 个 MSM261S4030H0 2.接口：10Pfpc / 10 pin 2.54mm 排线接口 3.供电电压：5V@mA 4.模块尺寸：15.2mm*9.1mm 4.工作温度: -30℃~80℃ Sipeed Mic-Array Mic-Array 麦克风阵列，截止 MaixPy 版本 MicroPython v0.5.0-218-g8053a70, 麦克风阵列硬件上的 pin io 支持自定义配置 No. MaixGo(默认配置 IO) 说明 MIC_D0 23 --- MIC_D1 22 --- MIC_D2 21 --- MIC_D3 20 --- MIC_WS 19 --- MIC_SCLK 18 --- --- --- --- LED_DAT 24 SK9822 DAT LED_CLK 25 SK9822 CLK from Maix import MIC_ARRAY as mic import lcd lcd.init() mic.init()#默认配置 # mic.init(i2s_d0=23, i2s_d1=22, i2s_d2=21, i2s_d3=20, i2s_ws=19, i2s_sclk=18, sk9822_dat=24, sk9822_clk=25)#可自定义配置 IO while True: imga = mic.get_map() # 获取声音源分布图像 b = mic.get_dir(imga) # 计算、获取声源方向 a = mic.set_led(b,(0,0,255))# 配置 RGB LED 颜色值 imgb = imga.resize(160,160) imgc = imgb.to_rainbow(1) # 将图像转换为彩虹图像 a = lcd.display(imgc) mic.deinit() powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"course/others/system.html":{"url":"course/others/system.html","title":"主频、复位等","keywords":"","body":"系统控制 复位（reset） import machine machine.reset() 主频（cpu） 可以设置 CPU 和 KPU 的主频， 具体参考Maix.freq模块 from Maix import freq freq.set(cpu = 400, kpu = 400) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"course/others/mem.html":{"url":"course/others/mem.html","title":"内存配置与查看","keywords":"","body":"内存管理 在 MaixPy 中， 目前使用了两种内存管理， 一种是 GC（垃圾回收）， 另一种是系统堆内存， 两者同时存在。 比如：芯片有 6MiB 内存，加入固件使用了前面的 2MiB， 还剩 4MiB， 默认 GC使用 512KiB， 剩下的给系统堆内存管理。 在mpy层面写的代码， 变量都是存在GC管理的内存块中，比如定义一个变量a = [1,2,3,4], 如果GC'内存不足了， 会自动触发gc.collect()函数的执行， GC会自动把没有在使用了的变量给销毁，留出来空间给新的变量使用。 GC使用标记-清除的方式进行内存回收，有兴趣可以看这里 因为GC要扫描内存， 如果除了程序占用的内存，剩下的都给GC，那每次扫描需要耗费大量时间，所以分成了两中内存。 堆内存由 C层面的代码控制，主要用于图片内存， AI内存， LCD 内存， 以及模型加载到内存等 GC 内存的总大小是可以设置的， 所以，根据具体的使用情况可以适当修改GC内存大小， 比如： 为了加载更大的模型，可以把 GC内存设置小一点 如果分配新的变量提示内存不足， 可以适当将GC内存设置大一点即可 如果都不够了， 就要考虑缩减固件大小，或者优化代码了 设置GC内存大小示例： from Maix import utils import machine print(utils.gc_heap_size()) utils.gc_heap_size(1024*1024) # 1MiB machine.reset() 注意修改后需要重启生效 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"course/others/flash.html":{"url":"course/others/flash.html","title":"Flash 分区表","keywords":"","body":"powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"course/others/maixui.html":{"url":"course/others/maixui.html","title":"Maix UI","keywords":"","body":"MaixUI 基础使用指导 如何正确的食用 MaixUI 项目？ 为什么要开发它？它的意义和存在价值是什么？ 在任何芯片下永远存在对 UI 框架的基本需求，但由于 K210 无法在支持 Ai 功能的情况下继续使用 LVGL 环境，导致 UI 失去了本来存在的意义。 也就是在不能用 QT 也不能用 LVGL 的时候，又希望能够使用 Python 编写 UI 应用，所以才诞生了基于 image 的 MaixUI UI 框架。 对 MaixUI 的要求 在最新 MaixPy 固件的基础上 2020年10月7日 满足如下要求。 确保 MicroPython 的 GC 内存在任何时候都是使用可回收可控的。 确保 UI 组件代码独立，不包含在固件，可被调试修改。 确保系统稳定性，保证代码和硬件资源均可重入，不会出现 core dump 现象。 运行可重入，也就运行动态代码展示 UI 样式，类似 HTML5 / CSS 的设计。 Python 的异常捕获实时反馈到屏幕上，快速定位出错行。 UI 相关的绘制函数可被多处装饰使用，也可独立运行。 框架提供的所有 MicroPython 硬件驱动均可独立运行相应的单元测试。 框架运行时允许动态加载外部符合结构的 UI 应用，可以从 storage 或 network 上获取用户自定义应用。 所以在最基础的示例中，它将严格控制内存占用控制在 512k ~ 1M ，并将绘图性能保持 15 ~ 24fps 之间。 如何食用？ 来，我们从最简单的入口代码开始说起，完整的代码在这里 app_main.py 。 # This file is part of MaixUI # Copyright (c) sipeed.com # # Licensed under the MIT license: # http://www.opensource.org/licenses/mit-license.php # import time, gc, math, sys try: from core import agent, system from dialog import draw_dialog_alpha from ui_canvas import ui, print_mem_free from ui_container import container from wdt import protect from creater import get_time_curve except ImportError as e: sys.print_exception(e) from lib.core import agent, system from lib.dialog import draw_dialog_alpha from ui.ui_canvas import ui, print_mem_free from ui.ui_container import container from driver.wdt import protect from lib.creater import get_time_curve 分别是运行它所需要 import 的依赖代码，有如下依赖： from core import agent, system 提供一个 agent 软定时器和一个全局实例 system 软定时器对象。 from dialog import draw_dialog_alpha 提供了一个圆角边框 MessageBox 控件的绘图操作。 from ui_canvas import ui, print_mem_free 提供了一个 UI 画布的基础接口，通过它来管理全局的统一绘图操作。 from ui_container import container 提供了一种运行 UI 应用的容器模块，可以通过它切换不同的 UI 应用。 from wdt import protect 看门狗，保证系统在出现 core dump 后能够重启恢复过来。 from creater import get_time_curve 一种基于时间或计数器的曲线生成函数，用来维持非线性动画效果。 这两段代码是用来 import 加载到不同区域（在 Flash/SD 的根目录或文件夹下）的代码，所以你知道怎么 import 代码了就行。 可以使用 MaixPy IDE 发送文件，也可以使用 mpfshell-lite put 文件到硬件的 flash 或 sd 中。 可以使用 SD 读卡器，把整个 maixui 仓库下的文件夹放到 SD 卡中启动即可。 定义 UI 应用 接着介绍一种典型的基础应用的案例，准备如下代码（class launcher 静态类）。 class launcher: def load(): __class__.ctrl = agent() __class__.ctrl.event(20, __class__.draw) def free(): __class__.ctrl = None @ui.warp_template(ui.blank_draw) @ui.warp_template(ui.grey_draw) @ui.warp_template(ui.bg_in_draw) @ui.warp_template(ui.anime_in_draw) @ui.warp_template(ui.help_in_draw) #@ui.warp_template(taskbar.time_draw) #@ui.warp_template(taskbar.mem_draw) #@catch # need sipeed_button def draw(): height = 100 + int(get_time_curve(3, 250) * 60) pos = draw_dialog_alpha(ui.canvas, 20, height, 200, 20, 10, color=(255, 0, 0), alpha=200) ui.canvas.draw_string(pos[0] + 10, pos[1] + 10, \"Welcome to MaixUI\", scale=2, color=(0,0,0)) ui.display() def event(): __class__.ctrl.cycle() 在这里， class 类似于 实例类 中的 this 指针，可以通过它访问当前类的全局变量。 该静态类拥有有 load / free / event 三个生命周期函数用以提供给 UI 容器维持该 UI 应用的持续运行。 load 只会执行一次，用于 UI 应用的初始化。 free 只会执行一次，用于 UI 应用的释放。 event 将会提供给 UI 容器循环执行其中的操作。 UI 容器指的是 ui/ui_container.py 。 当然你也可以不通过 UI 容器来维持运行。 可以看到该 UI 应用在 load 的时候定义了 agent 软定时器和设置了绘图函数的期望执行周期为 20ms ，设置再小也不会低于真实运行的周期。 __class__.ctrl = agent() __class__.ctrl.event(20, __class__.draw) 然后在 event 函数中维持 软定时器 ctrl 拥有的分时事件（非阻塞 no-block），因此基于此设计你可以制作很多个不同定时的分时任务。 __class__.ctrl.cycle() 它可以周期执行，也可以用完删除，就如下示范。 self.ctrl = agent() # loop self.ctrl.event(5, self.draw) # once def into_launcher(self): container.reload(launcher) self.remove(into_launcher) self.ctrl.event(2000, into_launcher) 接着我们看到具体的 UI 绘图事件，不同于按键/触摸等硬件驱动事件，但无论是哪类事件，我们都期望它能够尽快结束，交出运行核心。 @ui.warp_template(ui.blank_draw) @ui.warp_template(ui.grey_draw) @ui.warp_template(ui.bg_in_draw) @ui.warp_template(ui.anime_in_draw) @ui.warp_template(ui.help_in_draw) #@ui.warp_template(taskbar.time_draw) #@ui.warp_template(taskbar.mem_draw) #@catch # need sipeed_button def draw(): height = 100 + int(get_time_curve(3, 250) * 60) pos = draw_dialog_alpha(ui.canvas, 20, height, 200, 20, 10, color=(255, 0, 0), alpha=200) ui.canvas.draw_string(pos[0] + 10, pos[1] + 10, \"Welcome to MaixUI\", scale=2, color=(0,0,0)) ui.display() 在这里，我们有一个最基础的 draw() 绘图函数，也为它装饰了 5 个基础函数，事实上装饰只是好看，它实际上等效于如下代码，所以是否使用取决于你的喜好。 def draw(): ui.blank_draw() # 准备一个空白的 image 画布对象 ui.grey_draw() # 给 画布 画上灰色 ui.bg_in_draw() # 给 画布 画上内置的 背景图 一个 sipeed 的 logo 。 ui.anime_in_draw() # 给 画布 加载四周水波动画效果 ui.help_in_draw() # 给 画布 画上 内置的 帮助说明。 height = 100 + int(get_time_curve(3, 250) * 60) # 获取基于时间的正弦曲线值 # 在指定位置画出 圆角边框的 MessageBox 的效果，并获取边框的 左上角起点 。 pos = draw_dialog_alpha(ui.canvas, 20, height, 200, 20, 10, color=(255, 0, 0), alpha=200) # 在指定位置打印 \"Welcome to MaixUI\" 字符串。 ui.canvas.draw_string(pos[0] + 10, pos[1] + 10, \"Welcome to MaixUI\", scale=2, color=(0,0,0)) # 把当前的画布显示到屏幕上，多次执行也不影响，执行后会释放当前画布对象。 ui.display() 接入其他按键/触摸/摄像头的事件亦如此，可以在此查看 UI 绘图的具体实现 ui/ui_canvas.py。 运行 UI 框架 在真正进入上述的业务逻辑之前，我们需要把 UI 框架跑起来，因此我们需要一个入口函数，如 if __name__ == \"__main__\": 中的代码。 if __name__ == \"__main__\": container.reload(launcher) while True: container.forever() 讲解一下，我们看到使用 UI 容器 （container.reload(launcher)） 加载一个名为 launcher 的 UI 应用即可运行，可以在此查看 UI 容器的具体实现 ui/ui_container.py。 但仅仅这样写是不够稳定的，所以我们可以通过两个 while True 保持程序永远不会退出（除非系统 core dump 崩溃）。 并通过 last 与 当前 tick_ms 做差得到当前的 fps 值，建议非调试场合建议关闭 print 这个函数，它非常耗时（ms 级）。 while True: while True: last = time.ticks_ms() - 1 while True: try: #time.sleep(0.1) print(1000 // (time.ticks_ms() - last), 'fps') last = time.ticks_ms() except Exception as e: gc.collect() print(e) finally: try: ui.display() except: pass 然后我们加强一下环境的稳定性，加入看门狗的维持（protect.keep()）和 GC 内存回收（gc.collect()），还有维持一个全局的软定时器（system.parallel_cycle()），用作全局的定时器线程。 if __name__ == \"__main__\": container.reload(launcher) while True: while True: last = time.ticks_ms() - 1 while True: try: #time.sleep(0.1) print(1000 // (time.ticks_ms() - last), 'fps') last = time.ticks_ms() gc.collect() container.forever() system.parallel_cycle() protect.keep() #gc.collect() #print_mem_free() except KeyboardInterrupt: protect.stop() raise KeyboardInterrupt #except Exception as e: #gc.collect() #print(e) finally: try: ui.display() except: pass 你可以通过 time.sleep(0.1) 来降低 UI 容器的执行速率来观察 UI 的变化状态是否符合预期，有时候高于 15 fps 的变化人眼感知不到，就可以减少不必要的绘图过程，压缩绘图过程提高性能。 你可以通过 except Exception as e: 来保证任何异常都不会导致 UI 框架的崩溃，但调试的时候可以把这个注释，来捕获可能出现的异常。 默认情况下程序超过 10 秒没有执行 protect.keep() 重置看门狗，则系统自动重启，这从 import wdt 驱动的时候就开始计时了，详细可以看 driver/wdt.py 驱动。 最后再加入捕获 KeyboardInterrupt 异常事件来保证程序可以在 IDE 或 Ctrl + C 输入后，停下来并被重新运行，并停下看门狗事件（protect.stop()），同时还要在 finally 中试图执行 ui.display() 防止绘图事件中存在异常导致没有释放画布，保证 image 画布对象永远都能在循环的最后被释放。 try: protect.keep() except KeyboardInterrupt: protect.stop() raise KeyboardInterrupt except Exception as e: gc.collect() print(e) finally: try: ui.display() except: pass 以上就是 MaixUI 框架最基础的示范，虽然 MaixUI 只会提供 Cube 和 Amigo 的应用案例，但只要基于 MaixPy 均可使用，或者说，支持 image 接口对象的 MicroPython 环境均可使用。 希望我们未来能会同步到 CPython 共用的，也就是可以在 CPython 上进行 UI 样式的开发同步到 MicroPython 环境中，这会高效率的完成开发的，但性能也不能落下。 最后 本文档介绍如何运行最基础的示例，如果想看更多示例，可以参考 app_cube.py & app_amigo.py 两个案例。 截至目前 2020年10月7日 已经完成 MaixPy 的常见功能使用的 App 案例，不过这需要你亲自烧写一下体验看看了 XD ， 说明里只有一点简单的交互与动画展示。 目前 app_main.py 运行效果如下： powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"course/others/lvgl.html":{"url":"course/others/lvgl.html","title":"Lvgl","keywords":"","body":"lvgl LittlevGL 参考官方文档： lvgl blog page 例程 参考 github 的 MaixPy_Scripts powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"course/others/pye.html":{"url":"course/others/pye.html","title":"编辑器 pye","keywords":"","body":"pye (Micropython Editor) 在 MaixPy 中, 我们内置了一款编开源编辑器 Micropython Editor(pye) 注意在minimum版本的固件中不包含此功能 使用 os.listdir() 可以查看当前目录下的文件, 使用 pye(\"hello.py\") 可以创建文件并进入编辑模式, 快捷键等使用说明可以在这里查看 比如我们写入代码 print(\"hello maixpy\") 然后按 Ctrl+S 按 Enter 键保存, 按 Ctrl+Q 退出编辑 注意： 使用这款编辑器对使用的串口工具有一定要求, 必须将 BackSpace 按键设置为 DEL 功能, 否则按 BackSpace 调用的是 Ctrl+H 一样的功能（即字符替换）。 Linux 下推荐使用 minicom, 需要使用 sudo minicom -s 来设置,参考前面的教程 Windows 下也一样, 根据自己使用的工具上网搜设置方法, 比如 xshell 搜 xshell如何设置backspace为del 得到结果： 文件 -> 属性 -> 终端 -> 键盘, 把 delete 和 backspace 序列改为 ASCII 127 即可. powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/Maix/audio.html":{"url":"api_reference/Maix/audio.html","title":"Audio","keywords":"","body":"audio 抽象的音频对象，该对象可以被当做参数传入也可以直接使用其方法来播放音频 模块函数 构造函数 构造 Audio 对象 audio.Audio(array=None, path=None, points=1024) 参数 该接口能传入一个参数，每个参数会决定不同的音频类型 array: bytearray类型的数据，可以将该数据转换为音频对象， 默认 None path: 打开的音频文件路径，目前仅支持 wav 格式， 默认 None, 注意需要标明关键字path，audio.Audio(\"/sd/1.wav\")这样是错的！！ audio.Audio(path = \"/sd/1.wav\") 才是正确的 points: 开辟有 points 个采样点数的音频缓冲，一个采样点大小为 32bit。为0的情况下将不开辟缓冲, 默认 1024 返回值 返回一个 Audio 对象 to_bytes: bytes转换函数 将音频对象中的音频数据转换为 bytearray 类型的对象 audio_data = test_audio.to_bytes() 参数 无 返回值 返回的音频数据 bytearray 对象 play_process: 播放预处理函数 用于预处理音频对象，在播放之前需要对音频文件进行解析，所以需要预处理。这里需要传入一个播放用的 I2S 设备 wav_info = test_audio.play_process(i2s_dev) 参数 i2s_dev: 用于播放的i2s设备 返回值 该 wav 文件的头部信息 ,list类型，分别是numchannels, samplerate, byterate, blockalign, bitspersample, datasize play: 播放函数 读取音频文件并且解析播放，一般配合循环来使用 参数 无 返回值 None： 格式不支持播放 0： 播放结束 1： 正在播放 finish： 音频后处理函数 完成音频播放，该函数必须在播放完毕后调用，回收底层分配的资源 参数 无 返回值 无 例程 播放 wav 音频 from fpioa_manager import * from Maix import I2S, GPIO import audio # disable wifi fm.register(8, fm.fpioa.GPIO0) wifi_en=GPIO(GPIO.GPIO0,GPIO.OUT) wifi_en.value(0) # register i2s(i2s0) pin fm.register(34,fm.fpioa.I2S0_OUT_D1) fm.register(35,fm.fpioa.I2S0_SCLK) fm.register(33,fm.fpioa.I2S0_WS) # init i2s(i2s0) wav_dev = I2S(I2S.DEVICE_0) # init audio player = audio.Audio(path = \"/sd/6.wav\") player.volume(40) # read audio info wav_info = player.play_process(wav_dev) print(\"wav file head information: \", wav_info) # config i2s according to audio info wav_dev.channel_config(wav_dev.CHANNEL_1, I2S.TRANSMITTER,resolution = I2S.RESOLUTION_16_BIT ,cycles = I2S.SCLK_CYCLES_32, align_mode = I2S.RIGHT_JUSTIFYING_MODE) wav_dev.set_sample_rate(wav_info[1]) # loop to play audio while True: ret = player.play() if ret == None: print(\"format error\") break elif ret==0: print(\"end\") break player.finish() powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"course/others/video.html":{"url":"course/others/video.html","title":"video","keywords":"","body":"video 视频 支持播放和录制 avi 视频 全局函数 open(path, record=False, interval=100000, quality=50, width=320, height=240, audio=False, sample_rate=44100, channels=1) 打开一个文件来播放或者录制 参数 path： 文件路径， 比如 /sd/badapple.avi record： 是否进行录制， 如果选择 Ture， 则会进行录制视频，否则是播放视频。 默认 False interval： 录制的帧间隔， 单位是微秒， fps = 1000000/interval， 默认 100000， 即每秒10帧 quality： jpeg 压缩质量（%）， 默认50 width： 录制屏幕宽度， 默认 320 height： 录制屏幕高度， 默认 240 audio： 是否录制音频， 默认 False sample_rate： 录制音频采样率， 默认 44100 (44.1k) channels： 录制音频声道数， 默认 1， 即单声道 返回值 返回一个对象， 根据不同格式返回的对象不同。 目前只支持 avi 格式， 返回 由 avi 类创建的对象 类 avi 由 video.open() 函数返回 play() 播放视频， 每调用一次解析一次数据（音频或者视频） 返回值 0： 播放结束 1： 正在播放 2： 暂停（保留） 3： 当前解码的帧是视频帧 4： 当前解码的帧是音频帧 volume(volume) 设置音量 参数 volume： 音量值， 取值范围：[0,100] 返回值 设置的音量值， 取值范围 [0,100] record() 录制视频和音频， 每调用一次录制一帧，函数内部会限制速度，如果没有到录制设置的间隔，在到达设定的间隔之前会阻塞 返回值 录制的视频的当前帧的长度 例程 例程 1： 播放 avi 视频 首先保证视频是 320x240 大小， 视频压缩格式为 mjpeg， 音频压缩格式位 PCM。 可以在这里下载测试可以用的视频： badapple.avi import video,time from Maix import GPIO fm.register(34, fm.fpioa.I2S0_OUT_D1) fm.register(35, fm.fpioa.I2S0_SCLK) fm.register(33, fm.fpioa.I2S0_WS) fm.register(8, fm.fpioa.GPIO0) wifi_en=GPIO(GPIO.GPIO0,GPIO.OUT) wifi_en.value(0) v = video.open(\"/sd/badapple.avi\") print(v) v.volume(50) while True: if v.play() == 0: print(\"play end\") break v.__del__() 默认使用了 I2S0 来播放音频， 所以需要设置 I2S0 对应的引脚， 关闭WiFi是因为Dock板WiFi对音质的干扰 例程2： 录制 avi 视频 import video, sensor, image, lcd, time lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames(30) v = video.open(\"/sd/capture.avi\", record=1, interval=200000, quality=50) i = 0 tim = time.ticks_ms() while True: tim = time.ticks_ms() img = sensor.snapshot() lcd.display(img) img_len = v.record(img) # print(\"record\",time.ticks_ms() - tim) i += 1 if i > 100: break print(\"finish\") v.record_finish() lcd.clear() 可以取消打印屏蔽来看实际的录制间隔有没有达到设置的帧间隔（比如这里设置的200000us） 实际打印应该是 200ms， 如果实际帧间隔大于设置的值，则说明实际性能没有达到设置的要求，需要调大设置的帧间隔即减小帧率。 另外去掉显示和打印也可以一定程度上增加帧率。 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"course/others/nes.html":{"url":"course/others/nes.html","title":"NES 游戏机","keywords":"","body":"NES 游戏模拟器 经典的 FC 红白机 游戏模拟器， 带我们回到小时候吧～～ ** 警告，该模块只在标准固件（> 2m）中被编译包含，其他固件不带有，如有需求，请重新编译固件。 函数 init(rc_type=nes.KEYBOARD, cs, mosi, miso, clk, repeat=16, vol=5) 初始化 NES 模拟器 参数 tc_type： 遥控器类型， 键盘（nes.KEYBOARD）（注意是串口与电脑通信，而不是直接接USB键盘到开发板）或者手柄（nes.JOYSTICK）。 建议使用PS2手柄，体验会更好， 键盘通过串口工具输入可能不能同时按多个按键，当然也可以通过自己在PC写一个脚本来转发键值就能解决（去这里找找？） cs： 如果使用 SPI 接口的 PS2 手柄， 传入 cs 外设编号（注意不是引脚号，需要先映射引脚） mosi： 如果使用 SPI 接口的 PS2 手柄， 传入 mosi 外设编号（注意不是引脚号，需要先映射引脚） miso： 如果使用 SPI 接口的 PS2 手柄， 传入 miso 外设编号（注意不是引脚号，需要先映射引脚） clk： 如果使用 SPI 接口的 PS2 手柄， 传入 clk 外设编号（注意不是引脚号，需要先映射引脚） repeat： 这个参数只对使用键盘（/串口）时， 指按键的重复率 vol： 初始化时的音量， 后面可以通过按键调整 run(nes) 运行 NES 游戏 ROM 参数 nes： 游戏 ROM 路径， 比如 /sd/mario.nes 快捷键 代码输入 nes.input ： (①号机手柄, ②号机手柄, 菜单功能) 键盘（/串口） 移动 ： W A S D A ： J B ： K start ： M 或者 Enter option： N 或者 \\ 退出 ： ESC 音量 - ： - 音量 + ： = 运行速度 - ： R 运行速度 + ： F 手柄 移动 ： 方向键 ^ V -> A ： □ B ： × start ： START select： SELECT 退出 ： 暂无 音量 - ： R2 音量 + ： R1 运行速度 - ： L1 运行速度 + ： L2 例程 例 0： 代码输入 import nes, lcd lcd.init(freq=15000000) try: nes.init(nes.INPUT) nes.load(\"mario.nes\") while True: # tmp = i2c.readfrom(66, 1) # handle i2c addr # tmp = i2c.readfrom(74, 1) # handle i2c addr # nes.input(tmp[0], 0, 0) nes.loop() finally: nes.free() 例 1： 键盘（串口） import nes, lcd lcd.init(freq=15000000) nes.init(nes.KEYBOARD) nes.run(\"/sd/mario.nes\") while True: nes.loop() 例 2： PS2 手柄 import nes, lcd from fpioa_manager import fm fm.register(19, fm.fpioa.GPIOHS19) fm.register(18, fm.fpioa.GPIOHS18) fm.register(23, fm.fpioa.GPIOHS23) fm.register(21, fm.fpioa.GPIOHS21) lcd.init(freq=15000000) nes.init(nes.JOYSTICK, cs=fm.fpioa.GPIOHS19, clk=fm.fpioa.GPIOHS18, mosi=fm.fpioa.GPIOHS23, miso=fm.fpioa.GPIOHS21) nes.run(\"/sd/mario.nes\") while True: nes.loop() powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/standard/":{"url":"api_reference/standard/","title":"标准库","keywords":"","body":"标准库 cmath gc math sys ubinascii ucollections uctypes uerrno uhashlib uheapq ujson uos ure uselect usocket ustruct utime uzlib powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/standard/cmath.html":{"url":"api_reference/standard/cmath.html","title":"cmath","keywords":"","body":"cmath – 复数的数学函数 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档: cmath. cmath 模块提供了一些处理复数的基本数学函数。 函数 cos cmath.cos(z) 返回z的余弦。 exp cmath.exp(z) 返回z的指数。 log cmath.log(z) 返回z的自然对数。分支切割沿负实轴。 log10 cmath.log10(z) 返回z的以10为底的对数。分支切割沿负实轴。 phase cmath.phase(z) 返回数字“z”的相位，范围（-pi，+ pi）。 polar cmath.polar(z) 作为元组返回z的极性形式。 rect cmath.rect(r, phi) 返回模数r和相位phi的复数。 sin cmath.sin(z) 返回z的正弦值。 sqrt cmath.sqrt(z) 返回z的平方根。 Constants cmath.e 自然对数的基础 cmath.pi 圆周长与直径的比值 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/standard/gc.html":{"url":"api_reference/standard/gc.html","title":"gc","keywords":"","body":"gc – 内存回收 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：gc. 函数 gc.enable() 启用自动垃圾回收。 gc.disable() 禁用自动垃圾回收。仍然可以分配堆内存，仍然可以使用 gc.collect() 手动启动垃圾收集。 gc.collect() 运行垃圾回收。 gc.mem_alloc() 返回分配的堆 RAM 的字节数。 Difference to CPython 此功能是 MicroPython 扩展。 gc.mem_free() 返回可用堆RAM的字节数，如果堆剩余数量未知，则返回-1。 与CPython的区别 此功能是MicroPython扩展。 gc.threshold([amount]) 设置或查询其他GC分配阈值。通常，仅当不能满足新分配时，即在内存不足（OOM）条件下才触发集合。如果调用此函数，除了OOM之外，每次分配了大量字节后都会触发一个集合（总共，因为上一次分配了这么多的字节）。 amount通常被指定为小于完整堆大小，意图在堆耗尽之前触发集合，并希望早期集合可以防止过多的内存碎片。这是一种启发式度量，其效果因应用程序而异，以及量参数的最佳值。 不带参数调用函数将返回阈值的当前值。值-1表示禁用的分配阈值。 与CPython的区别 此函数是MicroPython扩展。 CPython有一个类似的函数 - set_threshold()，但是由于不同的GC实现，它的签名和语义是不同的。 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/standard/math.html":{"url":"api_reference/standard/math.html","title":"math","keywords":"","body":"math – 数学函数 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：math. math模块提供了一些处理浮点数的基本数学函数。 函数 math.acos(x) 返回x的反余弦值。 math.acosh(x) 返回x的反双曲余弦值。 math.asin(x) 返回x的反正弦。 math.asinh(x) 返回x的反双曲正弦值。 math.atan(x) 返回x的反正切。 math.atan2(y, x) 返回y /x的反正切的主值。 math.atanh(x) 返回x的反双曲正切。 math.ceil(x) 返回一个整数，“x”向正无穷大四舍五入。 math.copysign(x, y) 以y的符号返回x。 math.cos(x) 返回x的余弦。 math.cosh(x) 返回x的双曲余弦值 math.degrees(x) 返回弧度x转换为度数。 math.erf(x) 返回x的错误函数。 math.erfc(x) 返回x的互补误差函数。 math.exp(x) 返回x的指数。 math.expm1(x) 返回exp（x） - 1。 math.fabs(x) 返回x的绝对值。 math.floor(x) 返回一个整数，“x”向负无穷大舍入。 math.fmod(x, y) 返回x /y的余数。 math.frexp(x) 将浮点数分解为尾数和指数。返回的值是元组（m，e），使得x == m * 2 ** e完全正确。如果x == 0则函数返回（0.0,0），否则关系0.5 成立。 math.gamma(x) 返回x的伽玛函数。 math.isfinite(x) 如果x是有限的，则返回True。 math.isinf(x) 如果x是无限的，则返回True。 math.isnan(x) 如果x不是数字，则返回True math.ldexp(x, exp) 返回x *（2 ** exp）。 math.lgamma(x) 返回x的伽玛函数的自然对数。 math.log(x) 返回x的自然对数。 math.log10(x) 返回x的以10为底的对数。 math.log2(x) 返回x的base-2对数。 math.modf(x) 返回两个浮点数的元组，是“x”的分数和整数部分。两个返回值都与x具有相同的符号。 math.pow(x, y) 将x返回到'y`的幂。 math.radians(x) 返回度数x转换为弧度。 math.sin(x) 返回x的正弦值。 math.sinh(x) 返回x的双曲正弦值。 math.sqrt(x) 返回x的平方根。 math.tan(x) 返回x的正切值。 math.tanh(x) 返回x的双曲正切。 math.trunc(x) 返回一个整数，“x”向0舍入。 Constants math.e 自然对数的基础 math.pi 圆周长与直径的比值 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/standard/sys.html":{"url":"api_reference/standard/sys.html","title":"sys","keywords":"","body":"sys – 系统特定功能 该模块实现了相应CPython模块的子集，如下所述。 有关更多信息，请参阅原始CPython文档：sys. 功能函数 sys.exit(retval=0) 使用给定的退出代码终止当前程序。 根据此，此函数引发“SystemExit”异常。 如果给出了一个参数，它的值作为SystemExit的参数给出。 sys.print_exception(exc, file=sys.stdout) 使用回溯到类文件对象文件（或默认情况下为sys.stdout）打印异常。 和 CPython 的不同 这是一个函数的简化版本，它出现在CPython的回溯模块中。 与traceback.print_exception（）不同，此函数只接受异常值而不是异常类型，异常值和回溯对象; file参数应该是位置的; 不支持其他参数。 可以在micropython-lib中找到与CPython兼容的回溯模块。 常量 sys.argv 当前程序启动时的可变参数列表。 sys.byteorder 系统的字节顺序（“小端”或“大端”`）。 sys.implementation 包含有关当前Python实现的信息的对象。 对于MicroPython，它具有以下属性： name - 字符串“micropython” version - 元组 (major, minor, micro), e.g. (1, 7, 0) 此对象是区分MicroPython与其他Python实现的推荐方法（请注意，它仍然可能不存在于非常小的端口中）。 和 CPython 的不同 CPython要求为此对象提供更多属性，但实际有用的最低要求是在MicroPython中实现的。 sys.maxsize 本机整数类型可以在当前平台上保存的最大值，或MicroPython整数类型可表示的最大值，如果它小于平台最大值（对于没有长int支持的MicroPython端口的情况）。 此属性对于检测平台的“位数”（32位与64位等）非常有用。 建议不要直接将此属性与某个值进行比较，而是计算其中的位数： bits = 0 v = sys.maxsize while v: bits += 1 v >>= 1 if bits > 32: # 64-bit (or more) platform ... else: # 32-bit (or less) platform # Note that on 32-bit platform, value of bits may be less than 32 # (e.g. 31) due to peculiarities described above, so use \"> 16\", # \"> 32\", \"> 64\" style of comparisons. sys.modules 加载模块的字典。 在某些端口上，它可能不包含内置模块。 sys.path 用于搜索导入模块的可变目录列表。 sys.platform 运行 MicroPython 的平台。 对于OS / RTOS端口，这通常是OS的标识符，例如，“LINUX”。 对于裸金属端口，它是电路板的标识符，例如 “pyboard”用于原始的 MicroPython 参考板。 因此，它可用于区分一块板与另一块板。 如果您需要检查您的程序是否在 MicroPython 上运行（与其他 Python 实现相比），请使用sys.implementation。 sys.stderr 标准错误 stream. sys.stdin 标准输入 stream. sys.stdout 标准输出 stream. sys.version 实现的 Python 版本， 返回一个字符串 sys.version_info 实现的 Python 版本， 返回一个由整数组成的元组 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/standard/ubinascii.html":{"url":"api_reference/standard/ubinascii.html","title":"ubinascii","keywords":"","body":"ubinascii – 二进制/ ASCII转换 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：binascii. 该模块以ASCII格式（两个方向）实现二进制数据与其各种编码之间的转换。 函数 ubinascii.hexlify(data[, sep]) 将二进制数据转换为十六进制表示。返回字节字符串。 与CPython的区别 如果提供了附加参数sep，则它将用作十六进制值之间的分隔符。 ubinascii.unhexlify(data) 将十六进制数据转换为二进制表示。返回字节字符串。 （即hexlify的倒数） ubinascii.a2b_base64(data) 解码base64编码的数据，忽略输入中的无效字符。符合 RFC 2045 s.6.8. 返回一个bytes对象。 ubinascii.b2a_base64(data) 以base64格式编码二进制数据，如 RFC 3548所述。返回编码数据，后跟换行符，作为bytes对象。 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/standard/ucollections.html":{"url":"api_reference/standard/ucollections.html","title":"ucollections","keywords":"","body":"ucollections – 集合和容器类型 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档 collections. 此模块实现高级集合和容器类型以保存/累积各种对象。 类 ucollections.deque(iterable, maxlen[, flags]) Deques（双端队列）是一个类似列表的容器，支持O（1）追加并从双端队列的任一侧弹出。使用以下参数创建新的deques： iterable必须是空元组，并且新的deque被创建为空。 必须指定maxlen，并且双端队列将限制为此最大长度。一旦双端队列已满，添加的任何新项目将丢弃对方的项目。 添加项目时，可选标志可以为1以检查溢出。 除了支持bool和len之外，deque对象还有以下方法： deque.append(x) 将x添加到双端队列的右侧。如果启用了溢出检查并且没有剩余空间，则引发 IndexError。 deque.popleft() 从双端队列的左侧移除并返回一个项目。如果没有项目，则引发 IndexError。 ucollections.namedtuple(name, fields) 这是工厂函数，用于创建具有特定名称和字段集的新的namedtuple类型。 namedtuple是元组的子类，它不仅可以通过数字索引访问其字段，还可以使用符号字段名称访问属性访问语法。 Fields是指定字段名称的字符串序列。为了与CPython兼容，它也可以是一个以空格分隔的字段命名的字符串（但效率较低）。使用示例： from ucollections import namedtuple MyTuple = namedtuple(\"MyTuple\", (\"id\", \"name\")) t1 = MyTuple(1, \"foo\") t2 = MyTuple(2, \"bar\") print(t1.name) assert t2.name == t2[1] ucollections.OrderedDict(...) dict类型子类，它记住并保留添加的键的顺序。当迭代命令dict时，按照添加的顺序返回键/项： from ucollections import OrderedDict # To make benefit of ordered keys, OrderedDict should be initialized # from sequence of (key, value) pairs. d = OrderedDict([(\"z\", 1), (\"a\", 2)]) # More items can be added as usual d[\"w\"] = 5 d[\"b\"] = 3 for k, v in d.items(): print(k, v) Output: z 1 a 2 w 5 b 3 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/standard/uctypes.html":{"url":"api_reference/standard/uctypes.html","title":"uctypes","keywords":"","body":"uctypes – 以结构化方式访问二进制数据 该模块为MicroPython实现“外部数据接口”。 它背后的想法类似于CPython的ctypes模块，但实际的API是不同的，流线型和小尺寸优化。 该模块的基本思想是定义具有与C语言允许的功能大致相同的数据的数据结构布局，然后使用熟悉的点语法访问它以引用子字段。 警告 uctypes模块允许访问机器的任意内存地址（包括I / O和控制寄存器）。 不小心使用它可能会导致崩溃，数据丢失，甚至硬件故障。 也可参考 ustruct模块 用于访问二进制数据结构的标准Python方法（不能很好地扩展到大型和复杂的结构）。 例程： import uctypes # Example 1: Subset of ELF file header # https://wikipedia.org/wiki/Executable_and_Linkable_Format#File_header ELF_HEADER = { \"EI_MAG\": (0x0 | uctypes.ARRAY, 4 | uctypes.UINT8), \"EI_DATA\": 0x5 | uctypes.UINT8, \"e_machine\": 0x12 | uctypes.UINT16, } # \"f\" is an ELF file opened in binary mode buf = f.read(uctypes.sizeof(ELF_HEADER, uctypes.LITTLE_ENDIAN)) header = uctypes.struct(uctypes.addressof(buf), ELF_HEADER, uctypes.LITTLE_ENDIAN) assert header.EI_MAG == b\"\\x7fELF\" assert header.EI_DATA == 1, \"Oops, wrong endianness. Could retry with uctypes.BIG_ENDIAN.\" print(\"machine:\", hex(header.e_machine)) # Example 2: In-memory data structure, with pointers COORD = { \"x\": 0 | uctypes.FLOAT32, \"y\": 4 | uctypes.FLOAT32, } STRUCT1 = { \"data1\": 0 | uctypes.UINT8, \"data2\": 4 | uctypes.UINT32, \"ptr\": (8 | uctypes.PTR, COORD), } # Suppose you have address of a structure of type STRUCT1 in \"addr\" # uctypes.NATIVE is optional (used by default) struct1 = uctypes.struct(addr, STRUCT1, uctypes.NATIVE) print(\"x:\", struct1.ptr[0].x) # Example 3: Access to CPU registers. Subset of STM32F4xx WWDG block WWDG_LAYOUT = { \"WWDG_CR\": (0, { # BFUINT32 here means size of the WWDG_CR register \"WDGA\": 7 定义结构布局 结构布局由“描述符”定义 - 一个Python字典，它将字段名称编码为键，以及将它们作为关联值访问它们所需的其他属性： { \"field1\": , \"field2\": , ... } 目前，uctypes需要明确规定每个字段的偏移量。 从结构开始以字节为单位给出偏移量。 以下是各种字段类型的编码示例： 标量类型: \"field_name\": offset | uctypes.UINT32 换句话说，该值是标量类型标识符，与结构起始处的字段偏移量（以字节为单位）进行或运算。 递归结构： \"sub\": (offset, { \"b0\": 0 | uctypes.UINT8, \"b1\": 1 | uctypes.UINT8, }) 即，值是2元组，其第一个元素是偏移量，第二个是结构描述符字典（注意：递归描述符中的偏移量与其定义的结构相关）。 当然，递归结构不仅可以通过文字字典指定，还可以通过按名称引用结构描述符字典（前面定义）来指定。 原始类型的数组： \"arr\": (offset | uctypes.ARRAY, size | uctypes.UINT8), 即，值是一个2元组，其第一个元素是ARRAY标志与偏移进行OR运算，第二个是标量元素类型ORed数组中的元素数。 *聚合类型数组： \"arr2\": (offset | uctypes.ARRAY, size, {\"b\": 0 | uctypes.UINT8}), 即，值是一个3元组，其第一个元素是ARRAY标志，与偏移相关，第二个是数组中的元素数，第三个是元素类型的描述符。 *指向原始类型的指针： \"ptr\": (offset | uctypes.PTR, uctypes.UINT8), 即，值是2元组，其第一个元素是PTR标志与偏移进行OR运算，第二个元素是标量元素类型。 *指向聚合类型的指针： \"ptr2\": (offset | uctypes.PTR, {\"b\": 0 | uctypes.UINT8}), 即，值是2元组，其第一个元素是PTR标志与偏移量进行OR运算，第二个元素是指向的类型的描述符。 *比特场： \"bitf0\": offset | uctypes.BFUINT16 | lsbit 即，value是一种包含给定位域的标量值（类型名称类似于标量类型，但前缀为“BF”），与包含位域的标量值的偏移进行OR运算，并进一步与位位置和位长度的值进行“或”运算。标量值内的位域，分别移位BF_POS和BF_LEN位。位域位置从标量的最低有效位（具有0的位置）开始计数，并且是字段的最右位的数量（换句话说，它是标量需要向右移位的位数）提取位域）。 在上面的例子中，首先在偏移0处提取UINT16值（当访问硬件寄存器时，这个细节可能很重要，需要特定的访问大小和对齐），然后是最右边的位是此UINT16的lsbit位的位域，以及length是bitsize bits，将被提取。例如，如果lsbit为0且bitsize为8，那么它将有效地访问UINT16的最低有效字节。 注意，位域操作独立于目标字节字节序，特别是上面的例子将在小端和大端结构中访问UINT16的最低有效字节。但它取决于最低有效位被编号为0.某些目标可能在其原生ABI中使用不同的编号，但是“uctypes”总是使用上述的标准化编号。 模块内容 class uctypes.struct(addr, descriptor, layout_type=NATIVE) 基于内存中的结构地址，描述符（编码为字典）和布局类型（参见下文）来实例化“外部数据结构”对象。 uctypes.LITTLE_ENDIAN little-endian压缩结构的布局类型。 （打包意味着每个字段占用描述符中定义的字节数，即对齐为1）。 uctypes.BIG_ENDIAN big-endian压缩结构的布局类型。 uctypes.NATIVE 本机结构的布局类型 - 数据字节顺序和对齐符合运行MicroPython的系统的ABI。 uctypes.sizeof(struct, layout_type=NATIVE) 以字节为单位返回数据结构的大小。 struct参数可以是结构类，也可以是特定的实例化结构对象（或其聚合字段）。 uctypes.addressof(obj) 返回对象的地址。 参数应该是字节，字节数组或其他支持缓冲区协议的对象（该缓冲区的地址实际上是返回的）。 uctypes.bytes_at(addr, size) 以给定的地址和大小捕获内存作为bytes对象。 由于bytes对象是不可变的，因此内存实际上是复制并复制到bytes对象中，因此如果内存内容稍后更改，则创建的对象将保留原始值。 uctypes.bytearray_at(addr, size) 将给定地址和大小的内存捕获为bytearray对象。 与上面的bytes_at（）函数不同，内存是通过引用捕获的，因此它也可以写入，并且您将在给定的内存地址访问当前值。 uctypes.UINT8 uctypes.INT8 uctypes.UINT16 uctypes.INT16 uctypes.UINT32 uctypes.INT32 uctypes.UINT64 uctypes.INT64 结构描述符的整数类型。 提供了8,16,32和64位类型的常量，包括有符号和无符号。 uctypes.FLOAT32 uctypes.FLOAT64 结构描述符的浮点类型。 uctypes.VOID VOID是UINT8的别名，用于方便地定义C的void指针：（uctypes.PTR，uctypes.VOID）。 uctypes.PTR uctypes.ARRAY 输入指针和数组的常量。 请注意，结构没有显式常量，它是隐式的：没有PTR或ARRAY标志的聚合类型是一种结构。 结构描述符和实例化结构对象 给定结构描述符字典及其布局类型，您可以使用uctypes.struct（）构造函数在给定的内存地址实例化特定的结构实例。 内存地址通常来自以下来源： *访问裸机系统上的硬件寄存器时的预定义地址。 在特定MCU / SoC的数据表中查找这些地址。 *作为调用某些FFI（外部函数接口）函数的返回值。 *来自uctypes.addressof（），当您想要将参数传递给FFI函数时，或者访问I / O的某些数据（例如，从文件或网络套接字读取的数据）。 结构对象 结构对象允许使用标准点表示法访问单个字段：`my_struct.substruct1.field1。如果字段是标量类型，获取它将产生与字段中包含的值对应的原始值（Python整数或浮点数）。 标量字段也可以分配给。 如果某个字段是一个数组，则可以使用标准的下标运算符[]访问其各个元素 - 同时读取和分配。 如果一个字段是一个指针，它可以使用[0]语法解除引用（对应于C *运算符，尽管[0]也适用于C）。 还支持使用其他整数值（但是为0）订阅指针，其语义与C中相同。 总而言之，访问结构字段通常遵循C语法，除了指针取消引用，当您需要使用[0]运算符而不是*时。 限制 访问非标量字段会导致分配中间对象以表示它们。这意味着应该特别注意布局在禁用内存分配时（例如从中断）需要访问的结构。建议如下： 避免访问嵌套结构。例如，代替mcu_registers.peripheral_a.register1，为每个外设定义单独的布局描述符，作为peripheral_a.register1进行访问。或者只缓存特定的外设：peripheral_a = mcu_registers.peripheral_a。如果寄存器由多个位域组成，则需要缓存对特定寄存器的引用：reg_a = mcu_registers.peripheral_a.reg_a。 避免使用其他非标量数据，如数组。例如，使用peripheral_a.register0而不是peripheral_a.register [0]。同样，另一种方法是缓存中间值，例如register0 = peripheral_a.register [0]。 uctypes模块支持的偏移范围是有限的。支持的确切范围被认为是实现细节，一般建议是将结构定义拆分为从几千字节到几十千字节的最大值。在大多数情况下，这是一种自然情况，例如，在一个结构中定义MCU的所有寄存器（扩展到32位地址空间）没有意义，而是通过外设块定义外设块。在某些极端情况下，您可能需要人工分割几个部分的结构（例如，如果在中间访问具有多兆字节数组的本机数据结构，尽管这将是非常合成的情况）。） powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/standard/uerrno.html":{"url":"api_reference/standard/uerrno.html","title":"uerrno","keywords":"","body":"uerrno — 系统错误代码 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：errno。 该模块描述了 OSError 错误的错误标识。特定的代码库存取决于 Micropython 的移植， 错误会在特定的会出现错误的函数进行说明。 常量 EEXIST, EAGAIN, 等 基于 ANSI C / POSIX 标准的错误代码。所有错误代码均以 “E” 开头。如上所述，代码库存取决于 MicroPython 的移植。错误通常可以作为exc.args [0]访问，其中exc是OSError的一个实例。用法示例： try: uos.mkdir(\"my_dir\") except OSError as exc: if exc.args[0] == uerrno.EEXIST: print(\"Directory already exists\") uerrno.errorcode 字典将数字错误代码映射到带有符号错误代码的字符串（参见上文）： >>> print(uerrno.errorcode[uerrno.EEXIST]) EEXIST powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/standard/uhashlib.html":{"url":"api_reference/standard/uhashlib.html","title":"uhashlib","keywords":"","body":"uhashlib –哈希算法 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：hashlib。 该模块实现二进制数据哈希算法。可用算法的确切清单取决于电路板。在可以实现的算法中： SHA256-SHA2系列的最新现代哈希算法。它适用于密码安全的目的。除非它具有特定的代码大小限制，否则建议将其包含在MicroPython内核中，并建议任何开发板都提供此功能。 在 K210 中有硬件加速，不是软件计算 例程： a = bytes([0]*65) b = hashlib.sha256(a) c = b.digest() print(c) 构造函数 类 uhashlib.sha256([data]) 创建一个SHA256哈希对象，并有选择地向其中馈送数据。 方法 hash.update(data) 将更多的二进制数据输入哈希。 hash.digest() 返回通过哈希传递的所有数据的哈希，作为字节对象。调用此方法后，无法再将更多数据馈入哈希。 注意： 在micropython中， 使用此函数会完成最后的计算， 不是单纯的将结果显示出来， 所以只能调用一次， 如果你要多次使用这个值， 请保存到变量 c = b.digest() print(c) 多次调用会发现返回值不相同 c = b.digest() d = b.digest() print(c == d) # False hash.hexdigest() 未实现此方法。使用 ubinascii.hexlify(hash.digest()) 可获得类似的效果。 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/standard/uheapq.html":{"url":"api_reference/standard/uheapq.html","title":"uheapq","keywords":"","body":"uheapq – 堆队列算法 该模块实现了对应 CPython 模块的子集，如下所述。 有关更多信息，请参阅原始CPython文档：heapq。 该模块实现堆队列算法。 堆队列只是一个以某种方式存储其元素的列表。 函数 heappush uheapq.heappush(heap, item) 将元素放入堆。 heappop uheapq.heappop(heap) 弹出堆中的第一个元素，然后将其返回。 如果heap为空，则引发IndexError。 heapify uheapq.heapify(x) 将列表x转换为堆。 这是一个 in-place（划分交换排序）操作。 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/standard/ujson.html":{"url":"api_reference/standard/ujson.html","title":"ujson","keywords":"","body":"ujson – JSON encoding and decoding 该模块实现了相应 CPython 模块的子集，如下所述。有关更多信息，请参阅原始 CPython 文档：json. 此模块允许在 Python 对象和 JSON 数据格式之间进行转换。 函数 dump ujson.dump(obj, stream) 将 obj 序列化化为 JSON 字符串，将其写入给定的流。 dumps ujson.dumps(obj) 返回表示为 JSON 字符串的 obj。 load ujson.load(stream) 解析给定的流，将其解释为 JSON 字符串并将数据反序列化为 Python 对象。返回结果对象。 解析继续，直到遇到文件结尾。如果未正确形成流中的数据，则会引发 ValueError。 loads ujson.loads(str) 解析JSON str并返回一个对象。如果字符串格式出错，则引发ValueError。 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/standard/uos.html":{"url":"api_reference/standard/uos.html","title":"uos","keywords":"","body":"uos – 基本的“操作系统”服务 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：os。 uos模块包含用于文件系统访问和挂载，终端重定向和复制以及uname和urandom等函数。 常用函数 uos.uname() 返回一个元组（可能是一个命名了的元组），其中包含有关底层机器和/或其操作系统的信息。元组按以下顺序有五个字段，每个字段都是一个字符串： sysname - 底层系统的名称 nodename - 节点名（/板子名称）（可以与sysname相同） release - 底层系统的版本 version - MicroPython版本和构建日期 machine - 底层硬件的标识符（例如，板，CPU） uos.urandom(n) 返回一个包含n个随机字节的字节对象。只要有可能，它就由硬件随机数生成器生成。 文件系统访问 uos.chdir(path) 更改当前目录。 uos.getcwd() 获取当前目录。 uos.ilistdir([dir]) 此函数返回一个迭代器，然后生成与列出的目录中的条目对应的元组。如果不传参数，它列出了当前目录，否则它列出了dir给出的目录。 元组具有形式（名称，类型，inode [，大小]）： name： 是一个字符串（如果dir是一个字节对象，则为字节），并且是条目的名称; type： 是一个整数，指定条目的类型，目录为 0x4000，常规文件为 0x8000; inode： 是对应于文件inode的整数，对于没有这种概念的文件系统可以是0。 某些平台可能会返回包含条目大小的4元组。对于文件条目，size是表示文件大小的整数，如果未知则为-1。目前条目的含义目前尚未定义。 uos.listdir([dir]) 如果没有参数，请列出当前目录。否则列出给定目录。 uos.mkdir(path) 创建一个新目录。 uos.remove(path) 删除文件。 uos.rmdir(path) 删除目录。 uos.rename（old_path，new_path） 重命名文件。 uos.stat(path) 获取文件或目录的状态。 uos.statvfs(path) 获取文件系统的状态。 按以下顺序返回包含文件系统信息的元组： f_bsize - 文件系统块大小 f_frsize - 片段大小 f_blocks - f_frsize单位中fs的大小 f_bfree - 空闲块数 f_bavail - 无特权用户的空闲块数 f_files - inode数量 f_ffree - 免费inode的数量 f_favail - 无特权用户的免费inode数 f_flag - 挂载标志 f_namemax - 最大文件名长度 与inode相关的参数：f_files，f_ffree，f_avail和f_flags参数可能返回'0`，因为它们在特定于硬件的实现中不可用。 uos.sync() 同步所有文件系统。 终端重定向和复制 uos.dupterm(stream_object，index = 0) 在给定的stream类对象上复制或切换MicroPython终端（REPL）。 stream_object参数必须实现readinto（）和write（）方法。流应处于非阻塞模式，如果没有可用于读取的数据，readinto（）应返回'None`。 调用此函数后，将在此流上重复所有终端输出，并且流上可用的任何输入都将传递到终端输入。 index参数应为非负整数，并指定设置的复制槽。给定端口可以实现多个槽（槽0将始终可用），并且在这种情况下，终端输入和输出在所有设置的槽上复制。 如果None作为stream_object传递，则在索引给出的槽上取消复制。 该函数返回给定槽中的前一个类似流的对象。 文件系统挂载 某些端口提供虚拟文件系统（VFS）以及在此VFS中安装多个“真实”文件系统的功能。文件系统对象可以安装在VFS的根目录中，也可以安装在根目录中的子目录中。这允许Python程序看到的文件系统的动态和灵活配置。具有此功能的端口提供mount（）和umount（）函数，以及可能由VFS类表示的各种文件系统实现。 uos.mount(fsobj，mount_point，*，readonly) 将文件系统对象fsobj挂载到mount_point字符串指定的VFS中的位置。 fsobj可以是一个具有mount（）方法或块设备的VFS对象。如果它是块设备，则会自动检测文件系统类型（如果未识别文件系统，则会引发异常）。 mount_point可以是'/'在根目录下挂载fsobj，或者'/ '挂载到根目录下的子目录中。 如果readonly为“True”，则文件系统以只读方式挂载。 在mount过程中，在文件系统对象上调用mount（）方法。 如果mount_point已经挂载，将引发OSError（EPERM）。 uos.umount(mount_point) 卸载文件系统。 mount_point可以是命名安装位置的字符串，也可以是先前安装的文件系统对象。在卸载过程中，在文件系统对象上调用方法umount（）。 如果找不到mount_point，会引发OSError（EINVAL）。 class uos.VfsFat(block_dev) 创建使用FAT文件系统格式的文件系统对象。 FAT文件系统的存储由block_dev提供。可以使用mount（）挂载由此构造函数创建的对象。 static mkfs(block_dev) 在block_dev上构建FAT文件系统。 文件系统格式化 在MaixPy中，我们提供了对flash进行文件系统格式化的操作。如果用户想要清空flash文件系统那么可以使用该接口 flash_format 来实现 uos.flash_format() 该接口不需要传入参数，直接使用将对开发板的 flash 进行格式化。请注意，格式化将清空所有文件，在使用前请确认 flash 中文件都是需要删除的 块设备 块设备是实现块协议的对象，块协议是由 AbstractBlockDev 类在下面描述的一组方法。该类的具体实现通常允许访问类似存储器的功能作为硬件（如闪存）。特定文件系统驱动程序可以使用块设备来存储其文件系统的数据。 class uos.AbstractBlockDev()...) 构造块设备对象。构造函数的参数取决于特定的块设备。 readblocks(block_num, buf) 从索引block_num给出的块开始，将块从设备读入buf（字节数组）。要读取的块数由buf的长度给出，该长度将是块大小的倍数。 writeblocks(block_num, buf) 从索引block_num给出的块开始，将buf（字节数组）中的块写入设备。要写入的块数由buf的长度给出，该长度将是块大小的倍数。 ioctl(op, arg) 控制块设备并查询其参数。要执行的操作由op给出，它是以下整数之一： 1 - 初始化设备（arg未使用） 2 - 关闭设备（arg未使用） 3 - 同步设备（arg未使用） 4 - 获取块数的计数，应该返回一个整数（arg未使用） 5 - 获取块中的字节数，应该返回一个整数，或者“None”，在这种情况下使用默认值512（arg未使用） 例程 例程1 以fat32举例，下面的类将实现一个块设备，它使用bytearray将其数据存储在RAM中： class RAMBlockDev: def __init__(self, block_size, num_blocks): self.block_size = block_size self.data = bytearray(block_size * num_blocks) def readblocks(self, block_num, buf): for i in range(len(buf)): buf[i] = self.data[block_num * self.block_size + i] def writeblocks(self, block_num, buf): for i in range(len(buf)): self.data[block_num * self.block_size + i] = buf[i] def ioctl(self, op, arg): if op == 4: # get number of blocks return len(self.data) // self.block_size if op == 5: # get block size return self.block_size 或者： import uos bdev = RAMBlockDev(512, 50) uos.VfsFat.mkfs(bdev) vfs = uos.VfsFat(bdev) uos.mount(vfs, '/ramdisk') 例程2 以spiffs举例，下面的类将实现一个块设备，它使用bytearray将其数据存储在RAM中： class RAMFlashDev: def __init__(self): self.fs_size = 256*1024 self.fs_data = bytearray(256*1024) self.erase_block = 32*1024 self.log_block_size = 64*1024 self.log_page_size = 4*1024 def read(self,buf,size,addr): for i in range(len(buf)): buf[i] = self.fs_data[addr+i] def write(self,buf,size,addr): for i in range(len(buf)): self.fs_data[addr+i] = buf[i] def erase(self,size,addr): for i in range(size): self.fs_data[addr+i] = 0xff blkdev = RAMFlashDev.RAMFlashDev() vfs = uos.VfsSpiffs(blkdev) vfs.mkfs(vfs) uos.mount(vfs,'/ramdisk') powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/standard/ure.html":{"url":"api_reference/standard/ure.html","title":"ure","keywords":"","body":"ure – 简单的正则表达式 该模块实现了相应CPython模块的子集，如下所述。 有关更多信息，请参阅原始CPython文档：re. 该模块实现了正则表达式操作。 支持的正则表达式语法是CPythonre模块的子集（实际上是POSIX扩展正则表达式的子集）。 支持的运算符和特殊序列 . : 匹配任何字符。 [...] : 匹配字符集。 支持单个字符和范围，包括否定集（例如[^ a-c]）。 ^ : 匹配字符串的开头。 $ : 匹配字符串的结尾。 ? : 匹配零个或前一个子模式之一。 * : 匹配前一个子模式的零个或多个。 + : 匹配前一个子模式中的一个或多个。 ?? : 非贪婪版的？，匹配零或一，偏好为零。 *? : *的非贪婪版本，匹配零或更多，优先选择最短匹配。 +? : 非贪婪的“+”版本，匹配一个或多个，优先匹配最短。 | : 匹配此运算符的左侧或右侧子模式。 (...) : 分组。 每个组都在捕获（它捕获的子字符串可以使用`match.group（）方法访问）。 \\d : 匹配数字。 相当于[0-9]。 \\D : 匹配非数字。 相当于[^ 0-9]。 \\s : \\S : 匹配空白。 相当于 [^ \\t-\\r]. \\w : 匹配“单词字符”（仅限ASCII）。 相当于 [A-Za-z0-9_]. \\W : 匹配非“单词字符”（仅限ASCII）。 相当于 [^A-Za-z0-9_]. \\ : 转义字符。 除了上面列出的那些之外，反斜杠后面的任何其他字符都是字面意思。 例如，\\*等同于文字*（不被视为*运算符）。 请注意，\\r，\\n，等不是专门处理的，并且相当于文字字母r，n等。因此，不建议使用原始Python字符串（r“”）用于正则表达式。 例如，r“\\r \\n”用作正则表达式时相当于“rn”。 要匹配CR后跟LF的字符，请使用\"\\r\\n\"。 不支持的表达式 重复计算 ({m,n}) 命名组 ((?P...)) 非捕获组 ((?:...)) 更高级的断言 (\\b, \\B) 像\\r，\\n这样的特殊字符转义 - 使用Python自己的转义 其它 例子： import ure # As ure doesn't support escapes itself, use of r\"\" strings is not # recommended. regex = ure.compile(\"[\\r\\n]\") regex.split(\"line1\\rline2\\nline3\\r\\n\") # Result: # ['line1', 'line2', 'line3', '', ''] 方法 ure.compile(regex_str[, flags]) 编译正则表达式， 返回regex 对象。 ure.match(regex_str, string) 编译regex_str并匹配字符串。 匹配始终从字符串中的起始位置开始。 ure.search(regex_str, string) 编译regex_str并在字符串中搜索它。 与match不同，这将搜索字符串以匹配正则表达式的第一个位置（如果正则表达式被锚定，它仍然可以是0）。 ure.sub(regex_str, replace, string, count=0, flags=0) 编译regex_str并在字符串中搜索它，用replace替换所有匹配项，并返回新字符串。 replace可以是字符串或函数。 如果它是一个字符串，那么\\和\\g形式的转义序列可用于扩展到相应的组（或不匹配组的空字符串）。 如果replace是一个函数，那么它必须采用一个参数（匹配）并且应该返回一个替换字符串。 如果指定了count并且非零，那么在进行许多替换之后，替换将停止。 flags参数被忽略。 注意：此函数的可用性取决于MicroPython port。 ure.DEBUG 标记值，显示有关已编译表达式的调试信息。 （可用性取决于MicroPython 移植实现。） Regex 对象 编译了的正则表达式。 使用ure.compile()创建此类的实例。 regex.match(string) regex.search(string) regex.sub(replace, string, count=0, flags=0) 类似于模块级函数match（），search（）和sub（）。 如果将相同的正则表达式应用于多个字符串，则使用方法会更高效。 regex.split(string, max_split=-1) 使用正则表达式拆分字符串。 如果给出 max_split，则指定要执行的最大拆分数。 返回字符串列表（如果指定了，则最多可以有 max_split + 1 个元素）。 Match 对象 匹配match（）和search（）方法返回的对象，并传递给sub（）中的替换函数。 match.group(index) 返回匹配（子）字符串。 整个匹配的索引为0，每个捕获组的索引为1和更高。 仅支持数字组。 match.groups() 返回包含匹配组的所有子串的元组。 注意：此方法的可用性取决于MicroPython 移植实现。 match.start([index]) match.end([index]) 返回匹配的子字符串组的开头或结尾的原始字符串中的索引。 index默认为整个组，否则将选择一个组。 注意：这些方法的可用性取决于MicroPython 移植实现。 match.span([index]) 返回2元组（match.start（index），match.end（index））。 注意：此方法的可用性取决于MicroPython 移植 是否实现。 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/standard/uselect.html":{"url":"api_reference/standard/uselect.html","title":"uselect","keywords":"","body":"powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/standard/usocket.html":{"url":"api_reference/standard/usocket.html","title":"usocket","keywords":"","body":"usocket – 套接字模块 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档: socket. 该模块提供对BSD套接字接口的访问 与CPython的区别 为了提高效率和一致性，MicroPython中的套接字对象直接实现了stream（类文件）接口。在CPython中，您需要使用makefile（）方法将套接字转换为类文件对象。 MicroPython仍支持此方法（但是无操作），因此在与CPython兼容的情况下，请务必使用它。 套接字地址格式 usocket模块的本机套接字地址格式是getaddrinfo函数返回的不透明数据类型，必须用它来解析文本地址（包括数字地址）： sockaddr = usocket.getaddrinfo('www.micropython.org', 80)[0][-1] # You must use getaddrinfo() even for numeric addresses sockaddr = usocket.getaddrinfo('127.0.0.1', 80)[0][-1] # Now you can use that address sock.connect(addr) 使用getaddrinfo是最有效的（在内存和处理能力方面），而且也是使用地址的可移植方式。 但是，socket模块（注意与此处描述的本机MicroPythonusocket模块的区别）提供了与CPython兼容的方式来使用元组指定地址，如下所述。请注意，取决于MicroPython端口，可以在内置或需要从micropython-lib安装套接字模块（如“MicroPython Unix端口”的情况），并且某些端口仍然只接受元组中的数字地址格式，并要求使用getaddrinfo函数来解析域名。 总的来说： 编写便携式应用程序时始终使用getaddrinfo。 如果您的端口支持快速黑客和交互式使用，则下面描述的元组地址可用作快捷方式。 socket模块的元组地址格式： IPv4：（ipv4_address，port），其中ipv4_address是带有点符号数字IPv4地址的字符串，例如， “8.8.8.8”，端口号和整数端口号在1-65535范围内。请注意，域名不被接受为ipv4_address，应首先使用usocket.getaddrinfo（）解析它们。 IPv6：（ipv6_address，port，flowinfo，scopeid），其中ipv6_address是带冒号数字IPv6地址的字符串，例如： “2001：db8 :: 1”，port是1-65535范围内的整数端口号。 flowinfo必须为0. scopeid是链路本地地址的接口范围标识符。请注意，域名不被接受为ipv6_address，应首先使用usocket.getaddrinfo（）解析它们。 IPv6支持的可用性取决于MicroPython端口。 方法 usocket.socket(af=AF_INET, type=SOCK_STREAM, proto=IPPROTO_TCP) 使用给定的地址系列，套接字类型和协议号创建一个新套接字。请注意，在大多数情况下不需要指定proto（不推荐使用，因为一些MicroPython端口可能会省略IPPROTO_ *常量）。相反，type参数将自动选择所需的协议： # Create STREAM TCP socket socket(AF_INET, SOCK_STREAM) # Create DGRAM UDP socket socket(AF_INET, SOCK_DGRAM) usocket.getaddrinfo(host, port, af=0, type=0, proto=0, flags=0) 将 host / port 参数转换为5元组序列，其中包含用于创建连接到该服务的套接字的所有必要参数。参数af，type和proto（与socket（）函数具有相同的含义）可用于过滤返回哪种地址。如果未指定参数或为零，则可以返回所有地址组合（需要在用户端进行过滤）。 生成的5元组列表具有以下结构： (family, type, proto, canonname, sockaddr) 以下示例显示如何连接到给定的URL： s = usocket.socket() # This assumes that if \"type\" is not specified, an address for # SOCK_STREAM will be returned, which may be not true s.connect(usocket.getaddrinfo('www.micropython.org', 80)[0][-1]) 建议使用过滤参数： s = usocket.socket() # Guaranteed to return an address which can be connect'ed to for # stream operation. s.connect(usocket.getaddrinfo('www.micropython.org', 80, 0, SOCK_STREAM)[0][-1]) 与CPython的区别 如果此函数出错，CPython会引发socket.gaierror异常（OSError子类）。 MicroPython没有socket.gaierror并直接引发OSError。请注意，getaddrinfo（）的错误号形成一个单独的命名空间，可能与uerrno模块中的错误号不匹配。为了区分getaddrinfo（）错误，它们用负数表示，而标准系统错误是正数（错误号可以使用来自异常对象的e.args [0]属性访问）。使用负值是临时细节，可能在将来发生变化。 usocket.inet_ntop(af, bin_addr) 将给定地址族af的二进制网络地址bin_addr转换为文本表示： >>> usocket.inet_ntop(usocket.AF_INET, b\"\\x7f\\0\\0\\1\") '127.0.0.1' usocket.inet_pton(af, txt_addr) 将给定地址族af的文本网络地址txt_addr转换为二进制表示： >>> usocket.inet_pton(usocket.AF_INET, \"1.2.3.4\") b'\\x01\\x02\\x03\\x04' 常量 usocket.AF_INET usocket.AF_INET6 解决家庭类型。可用性取决于特定的MicroPython端口。 usocket.SOCK_STREAM usocket.SOCK_DGRAM 套接字类型。 usocket.IPPROTO_UDP usocket.IPPROTO_TCP IP协议号。可用性取决于特定的MicroPython端口。注意，在调用usocket.socket（）时不需要指定它们，因为SOCK_STREAM套接字类型会自动选择IPPROTO_TCP和SOCK_DGRAM - IPPROTO_UDP。因此，这些常量的唯一实际用途是作为setsockopt（）的参数。 usocket.SOL_* 套接字选项级别（setsockopt（）的参数）。确切的库存取决于MicroPython端口。 usocket.SO_* 套接字选项（setsockopt（）的参数）。确切的库存取决于MicroPython端口。 类 socket 方法 socket.close() 标记套接字已关闭并释放所有资源。一旦发生这种情况，套接字对象上的所有未来操作都将失败。如果协议支持，远程端将接收EOF指示。 套接字在被垃圾收集时会自动关闭，但建议你在完成它们之后立即“关闭”它们。 (maixpy 未实现)socket.bind(address) 将套接字绑定到地址。套接字必须尚未绑定。 (maixpy 未实现)socket.listen([backlog]) 使服务器接受连接。如果指定了积压，则必须至少为0（如果低，则将其设置为0）;并指定在拒绝新连接之前系统将允许的未接受连接数。如果未指定，则选择默认的合理值。 (maixpy 未实现)socket.accept() 接受连接。套接字必须绑定到一个地址并侦听连接。返回值是一对（conn，address），其中conn是可用于在连接上发送和接收数据的新套接字对象，address是绑定到连接另一端的套接字的地址。 socket.connect(address) 连接到地址处的远程套接字。 socket.send(bytes) 将数据发送到套接字。套接字必须连接到远程套接字。返回发送的字节数，可能小于数据长度（“短写”）。 socket.sendall(bytes) 将所有数据发送到套接字。套接字必须连接到远程套接字。与send（）不同，此方法将尝试通过连续发送数据块来发送所有数据。 此方法在非阻塞套接字上的行为未定义。因此，在MicroPython上，建议使用write（）方法，它具有相同的“无短写入”策略来阻塞套接字，并将返回在非阻塞套接字上发送的字节数。 socket.recv(bufsize) 从套接字接收数据。返回值是表示接收数据的字节对象。一次接收的最大数据量由bufsize指定。 socket.sendto(bytes, address) 将数据发送到套接字。套接字不应连接到远程套接字，因为目标套接字由地址指定。 socket.recvfrom(bufsize) 从套接字接收数据。返回值是一对（字节，地址），其中bytes是表示接收数据的字节对象，address是发送数据的套接字的地址。 socket.setsockopt(level, optname, value) 设置给定套接字选项的值。所需的符号常量在套接字模块中定义（SO_ *等）。该值可以是整数或表示缓冲区的类字节对象。 socket.settimeout(value) 注意：并非每个端口都支持此方法，请参阅下文。 阻止套接字操作设置超时。 value参数可以是表示秒的非负浮点数，也可以是None。如果给出非零值，则如果在操作完成之前已经过了超时时间值，则后续的套接字操作将引发“OSError”异常。如果给出零，则套接字处于非阻塞模式。如果给出None，则套接字处于阻塞模式。 并非每个“MicroPython端口”都支持此方法。更便携和通用的解决方案是使用uselect.poll对象。这允许同时等待多个对象（而不仅仅是在套接字上，而是在支持轮询的通用stream对象上）。例： # Instead of: s.settimeout(1.0) # time in seconds s.read(10) # may timeout # Use: poller = uselect.poll() poller.register(s, uselect.POLLIN) res = poller.poll(1000) # time in milliseconds if not res: # s is still not ready for input, i.e. operation timed out 与CPython的区别 CPython在超时的情况下引发socket.timeout异常，这是一个OSError子类。 MicroPython直接引发了一个OSError。如果你使用除了OSError：来捕获异常，你的代码将在MicroPython和CPython中都有效。 socket.setblocking(flag) 设置套接字的阻塞或非阻塞模式：如果flag为false，则套接字设置为非阻塞，否则设置为阻塞模式。 这个方法是某些settimeout（）调用的简写： sock.setblocking(True) 相当于sock.settimeout(None) sock.setblocking(False) i相当于 sock.settimeout(0) socket.makefile(mode='rb', buffering=0) 返回与套接字关联的文件对象。确切的返回类型取决于给makefile（）的参数。支持仅限于二进制模式（'rb'，'wb'和'rwb'）。 CPython的参数：不支持编码，错误和换行符。 与CPython的区别 由于MicroPython不支持缓冲流，因此忽略缓冲参数的值，并将其视为0（无缓冲）。 与CPython的区别 关闭makefile（）返回的文件对象也将关闭原始套接字。 socket.read([size]) 从插槽中读取大小字节。返回一个字节对象。如果没有给出大小，它会读取插座中可用的所有数据，直到EOF;因此，在套接字关闭之前，该方法不会返回。此函数尝试读取所请求的数据（没有“短读取”）。但是，对于非阻塞套接字，这可能是不可能的，然后将返回更少的数据。 socket.readinto(buf[, nbytes]) 将字节读入buf。如果指定了nbytes，则最多读取多个字节。否则，最多读取len（buf）字节。就像read（）一样，此方法遵循“无短读”策略。 返回值：读取并存储到buf中的字节数。 socket.readline() 读一行，以换行符结尾。 返回值：读取的行。 socket.write(buf) 将字节缓冲区写入套接字。此函数将尝试将所有数据写入套接字（无“短写”）。但是，对于非阻塞套接字，这可能是不可能的，并且返回值将小于buf的长度。 返回值：写入的字节数。 exception usocket.error MicroPython没有此异常。 与CPython的区别 CPython曾经有一个socket.error异常现在已被弃用，它是OSError的别名。在MicroPython中，直接使用OSError。 例程 例程 1： 下载图片并显示 注意需要设置 WiFi SSID 和 密码 import socket import network import gc import os import lcd, image fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_TX,fm.fpioa.UART2_RX) uart = machine.UART(machine.UART.UART2,115200,timeout=1000, read_buf_len=4096) nic=network.ESP8285(uart) nic.connect(\"Sipeed_2.4G\",\"------\") sock = socket.socket() addr = socket.getaddrinfo(\"dl.sipeed.com\", 80)[0][-1] sock.connect(addr) sock.send('''GET /MAIX/MaixPy/assets/Alice.bmp HTTP/1.1 Host: dl.sipeed.com cache-control: no-cache ''') img = b\"\" sock.settimeout(5) while True: data = sock.recv(4096) if len(data) == 0: break print(\"rcv:\", len(data)) img = img + data print(len(img)) img = img[img.find(b\"\\r\\n\\r\\n\")+4:] print(len(img)) print(\"save to /sd/Alice.bmp\") f = open(\"/sd/Alice.bmp\",\"wb\") f.write(img) f.close() print(\"save ok\") print(\"display\") img = image.Image(\"/sd/Alice.bmp\") lcd.init() lcd.display(img) 例程 2： 发送图片 import os import socket import network import gc fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_TX,fm.fpioa.UART2_RX) uart = machine.UART(machine.UART.UART2,115200,timeout=1000, read_buf_len=4096) nic=network.ESP8285(uart) nic.connect(\"Sipeed_2.4G\",\"-------\") addr = (\"192.168.0.183\", 3456) sock = socket.socket() sock.connect(addr) sock.settimeout(5) f = open(\"/sd/Alice.bmp\",\"rb\") while True: img = f.read(2048) if not img or (len(img) == 0): break sock.send(img) f.close() sock.close() powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/standard/ustruct.html":{"url":"api_reference/standard/ustruct.html","title":"ustruct","keywords":"","body":"ustruct – 打包和解包原始数据类型 该模块实现了相应的CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档： struct. 支持的大小/字节顺序前缀: @, , >, !. 支持的格式代码： b, B, h, H, i, I, l, L, q, Q, s, P, f, d （后者2取决于浮点支持）。 函数 calcsize ustruct.calcsize(fmt) 返回存储给定fmt所需的字节数。 pack ustruct.pack(fmt, v1, v2, ...) 根据格式字符串fmt打包值v1，v2，...。返回值是编码值的字节对象。 pack_into ustruct.pack_into(fmt, buffer, offset, v1, v2, ...) 根据格式字符串fmt将值v1，v2，...打包到从offset开始的缓冲区中。从缓冲区的末尾开始计数可能是负数。 unpack ustruct.unpack(fmt, data) 根据格式字符串fmt从data解包。返回值是解压缩值的元组。 unpack_from ustruct.unpack_from(fmt, data, offset=0) 根据格式字符串fmt从 offset 开始从data解包。 offset可能是负数，从缓冲区的末尾开始计数。返回值是解压缩值的元组。 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/standard/utime.html":{"url":"api_reference/standard/utime.html","title":"utime","keywords":"","body":"utime – 时间相关的功能 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档： time. utime模块提供获取当前时间和日期，测量时间间隔和延迟的功能。 时间纪元: Unix移植版本使用标准为1970-01-01 00:00:00 UTC的POSIX系统时代。但是，嵌入式移植版本使用的是2000-01-01 00:00:00 UTC的纪元。 维护实际日历日期/时间: 这需要实时时钟（RTC）。在具有底层OS（包括一些RTOS）的系统上，RTC可能是隐含的。设置和维护实际日历时间是OS / RTOS的责任，并且在MicroPython之外完成，它只使用OS API来查询日期/时间。在裸机移植上，系统时间依赖于machine.RTC（）对象。可以使用machine.RTC（）。datetime（tuple）函数设置当前日历时间，并通过以下方式维护： 通过备用电池（可能是特定电路板的附加可选组件）。 使用联网时间协议（需要由移植/用户设置）。 每次上电时由用户手动设置（许多电路板在硬复位时保持RTC时间，但有些可能需要在这种情况下再次设置）。 如果未使用系统/ MicroPython RTC维护实际日历时间，则低于此要求参考当前绝对时间的函数可能与预期不符。 函数 utime.localtime([secs]) 将自纪元（见上文）以秒为单位的时间转换为8元组，其中包含:(年，月，日，小时，分钟，秒，工作日，晚期）如果未提供秒数或无，则为当前时间来自RTC使用。 年份包括世纪（例如2014年）。 月是1-12 mday是1-31 小时是0-23 分钟是0-59 秒是0-59 周一至周日的工作日为0-6 yearday是1-366 utime.mktime() 这是本地时间的反函数。它的参数是一个完整的8元组，表示按当地时间表示的时间。它返回一个整数，它是自2000年1月1日以来的秒数。 utime.sleep(seconds) 睡眠给定的秒数。有些电路板可能会接受秒作为浮点数来休眠几秒钟。请注意，其他板可能不接受浮点参数，因为与它们的兼容性使用 sleep_ms() 和 sleep_us() 函数。 utime.sleep_ms(ms) 给定毫秒数的延迟应为正或0。 utime.sleep_us(us) 给定微秒数的延迟应为正或0。 utime.ticks_ms() 返回一个带有任意参考点的递增毫秒计数器，它在某个值之后回绕。 环绕值未明确公开，但我们将其称为TICKS_MAX以简化讨论。值的周期为TICKS_PERIOD = TICKS_MAX + 1. TICKS_PERIOD保证为2的幂，但在不同硬件的移植之间可能不同。相同的句点值用于所有ticks_ms（），ticks_us（），ticks_cpu（）函数（为简单起见）。因此，这些函数将返回范围[0 .. TICKS_MAX]中的值，包括总TICKS_PERIOD值。请注意，仅使用非负值。在大多数情况下，您应该将这些函数返回的值视为不透明。可用的唯一操作是ticks_diff（）和ticks_add（）函数，如下所述。 注意：直接对这些值执行标准数学运算（+， - ）或关系运算符（，> =）将导致无效结果。执行数学运算然后将其结果作为参数传递给ticks_diff（）或ticks_add（）也将导致后者函数的无效结果。 utime.ticks_us() 就像上面的'ticks_ms（）`一样，但是在几微秒内。 utime.ticks_cpu() 类似于ticks_ms（）和ticks_us（），但系统中的分辨率最高。这通常是CPU时钟，这就是函数以这种方式命名的原因。但它不必是CPU时钟，而是可以使用系统中可用的一些其他定时源（例如，高分辨率定时器）。在'utime`模块级别没有指定此函数的确切时间单位（分辨率），但特定硬件的文档可能提供更具体的信息。此功能用于非常精细的基准测试或非常紧凑的实时循环。避免在便携式代码中使用它。 utime.ticks_add(ticks, delta) 偏移值按给定数字计算，可以是正数也可以是负数。给定一个ticks值，该函数允许在tick值的模块算术定义之后或之后计算ticks值delta ticks（参见上面的ticks_ms（））。 ticks参数必须是调用ticks_ms（），ticks_us（）或ticks_cpu（）函数（或从之前调用ticks_add（））的直接结果。但是，delta可以是任意整数或数字表达式。 ticks_add（）对于计算事件/任务的截止日期非常有用。 （注意：你必须使用ticks_diff（）函数来处理截止日期。） 例子: # Find out what ticks value there was 100ms ago print(ticks_add(time.ticks_ms(), -100)) # Calculate deadline for operation and test for it deadline = ticks_add(time.ticks_ms(), 200) while ticks_diff(deadline, time.ticks_ms()) > 0: do_a_little_of_something() # Find out TICKS_MAX used by this port print(ticks_add(0, -1)) utime.ticks_diff(ticks1, ticks2) 测量从ticks_ms（），ticks_us（）或ticks_cpu（）函数返回的值之间的差异，作为可以回绕的有符号值。 参数顺序与减法运算符相同，ticks_diff（ticks1，ticks2）与ticks1 - ticks2具有相同的含义。但是，ticks_ms（）等函数返回的值可能会回绕，因此直接使用减法会产生不正确的结果。这就是为什么需要ticks_diff（），它实现模块化（或更具体地说，环）算术，即使对于环绕值也能产生正确的结果（只要它们之间不太远，见下文）。该函数返回范围为[-TICKS_PERIOD / 2 .. TICKS_PERIOD / 2-1]的有符号值（这是二进制补码有符号二进制整数的典型范围定义）。如果结果是否定的，则意味着ticks1在时间上早于ticks2。否则，这意味着ticks1发生在ticks2之后。如果ticks1和ticks2彼此分开不超过TICKS_PERIOD / 2-1滴答，则仅保留**。如果不成立，将返回不正确的结果。具体来说，如果两个刻度值相隔TICKS_PERIOD / 2-1刻度，则该值将由该函数返回。但是，如果实时滴答的TICKS_PERIOD / 2已在它们之间传递，则该函数将返回-TICKS_PERIOD / 2，即结果值将回绕到可能值的负范围。 上述限制的非正式理由：假设您被锁在一个房间内，除了标准的12档时钟外无法监控时间的流逝。然后，如果你现在看表盘，不再看13个小时（例如，如果你长时间睡觉），那么一旦你再看一遍，你可能觉得只有1个小时过去了。为了避免这个错误，请定期查看时钟。您的应用程序也应该这样做。 “太长时间睡眠”这个比喻也直接映射到应用程序行为：不要让你的应用程序运行任何单个任务太长时间。分步运行任务，并在两者之间进行计时。 ticks_diff() 旨在适应各种使用模式，其中包括： 超时轮询。在这种情况下，事件的顺序是已知的，你只会处理ticks_diff（）的正面结果： # Wait for GPIO pin to be asserted, but at most 500us start = time.ticks_us() while pin.value() == 0: if time.ticks_diff(time.ticks_us(), start) > 500: raise TimeoutError 调度事件。 在这种情况下，如果事件过期，则ticks_diff（）结果可能为负： # This code snippet is not optimized now = time.ticks_ms() scheduled_time = task.scheduled_time() if ticks_diff(scheduled_time, now) > 0: print(\"Too early, let's nap\") sleep_ms(ticks_diff(scheduled_time, now)) task.run() elif ticks_diff(scheduled_time, now) == 0: print(\"Right at time!\") task.run() elif ticks_diff(scheduled_time, now) 注意：不要将time（）值传递给ticks_diff（），你应该对它们使用常规的数学运算。但请注意，time（）可能（也会）溢出。这被称为https://en.wikipedia.org/wiki/Year_2038_problem . utime.time() 返回自纪元以来的整数秒数，假设如上所述设置和维护基础RTC。如果未设置 RTC，则此函数返回自特定硬件移植参考时间点以来的秒数（对于没有电池供电的 RTC 的嵌入式电路板，通常自上电或复位后）。如果要开发便携式 MicroPython 应用程序，则不应依赖此函数来提供高于第二的精度。如果你需要更高的精度，使用ticks_ms（）和ticks_us（）函数，如果你需要日历时间，localtime（）没有参数是一个更好的选择。 与CPython的区别 在 CPython 中，此函数返回自 Unix 纪元（1970-01-01 00:00 UTC）以来的秒数，作为浮点数，通常具有微秒精度。 使用 MicroPython，只有 Unix 移植版本使用相同的纪元，如果浮点精度允许，则返回亚秒精度。 嵌入式硬件通常没有浮点精度来表示长时间范围和亚秒精度，因此它们使用具有第二精度的整数值。 某些嵌入式硬件也缺少电池供电的 RTC，因此返回自上次上电或其他相对硬件特定点（例如复位）以来的秒数。 time.ticks() 等同于 time.ticks_ms time.clock() 获取 clock 对象 返回值 clock 对象 clock 对象 由 time.clock() 返回 clock.tick() 记录开始时间（ms）， 与clock.fps()搭配使用可以计算fps 返回值 None clock.fps() 根据上一个调用clock.tick()到现在的时间计算出帧率（fps） 比如： import sensor import time clock = time.clock() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) while True: clock.tick() sensor.snapshot() print(\"fps = \",clock.fps()) clock.reset() 重置所有标记 clock.avg() 根据上一个调用clock.tick()到现在的时间计算出每帧消耗的时间 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/standard/uzlib.html":{"url":"api_reference/standard/uzlib.html","title":"uzlib","keywords":"","body":"uzlib — zlib 解压缩 该模块实现了相应CPython模块的子集，如下所述。有关更多信息，请参阅原始CPython文档：zlib。 该模块允许解压使用 DEFLATE 算法压缩的二进制数据（通常用于zlib库和gzip存档器）。 压缩尚未实现。 函数 decompress 解压 uzlib.decompress(data, wbits=0, bufsize=0) 参数 wbits： 压缩期间使用的 DEFLATE 字典窗口大小（8-15，字典大小是该值的2的幂）。 另外，如果值为正，则假定数据为 zlib 流（使用 zlib 头）。 否则，如果它是负数，则假定它是原始 DEFLATE 流。 bufsize： 参数用于与CPython兼容， 可忽略。 返回值 将解压缩的数据作为bytes类型返回。 DecompIO 创建一个流包装器，允许对另一个流中的压缩数据进行透明解压缩。 这允许处理具有大于可用堆大小的数据的压缩流。 除了decompress（）中描述的值之外，wbits可以取值 24..31（16+8..15），这意味着输入流具有gzip头。 class uzlib.DecompIO(stream, wbits=0) 与 CPython 的不同 这个类是MicroPython扩展。它包含在临时基础上，可能会在以后的版本中进行大量更改或删除。 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/machine/":{"url":"api_reference/machine/","title":"machine","keywords":"","body":"machine machine 库主要包含了与硬件相关的各种接口，如下： I2C SPI Timer PWM UART 方法 unique_id() 获取唯一 ID 返回值 32 字节的唯一ID 方法 reset() 重启 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/machine/i2c.html":{"url":"api_reference/machine/i2c.html","title":"I2C","keywords":"","body":"machine.I2C I2C 总线协议，简单地使用两条线（SCL，SDA）可以控制多个从机（主机模式）。 支持主机模式和从机模式 7 位/10 位寻址模式 标准模式 快速模式 超快速模式 高速模式 3.4Mb/s 构造函数 class machine.I2C(id, mode=I2C.MODE_MASTER, scl=None, sda=None, freq=400000, timeout=1000, addr=0, addr_size=7, on_recieve=None, on_transmit=None, on_event=None) 通过指定的参数新建一个 I2C 对象 参数 id： I2C ID, [0~2] (I2C.I2C0~I2C.I2C2) [3~5] (I2C.I2C3~I2C.I2C5) 是软模拟 I2C 的编号 mode： 模式， 主机(I2C.MODE_MASTER)和从机（I2C.MODE_SLAVE)模式 scl： SCL 引脚，直接传引脚编号即可，取值范围： [0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 sda： SDA 引脚，直接传引脚编号即可，取值范围： [0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 freq： I2C通信频率， 支持标准100Kb/s, 快速400Kb/s， 以及更高速率（硬件支持超快速模式1000Kb/s，以及高速模式3.4Mb/s） timeout： 超时时间，目前这个参数保留，设置无效 addr： 从机地址，如果是主机模式不用设置， 从机模式则代表从机（本机）地址 addr_size： 地址长度， 支持 7 位寻址和 10 位寻址， 取值7或者10 on_recieve： 从机模式的接收回调函数 on_transmit： 从机模式的发送回调函数 on_event： 从机模式的事件函数（开始事件和结束事件） 方法 init 类似构造函数 i2c = I2C.init(id, mode=Timer.MODE_MASTER, scl, sda, freq=400000, timeout=1000, addr=0, addr_size=7, on_recieve=None, on_transmit=None, on_event=None) 参数 与构造函数相同 返回值 无 scan 扫描I2C总线上的从机 i2c.scan() 参数 无 返回值 list 对象， 包含了所有扫描到的从机地址 readfrom 从总线读取数据 i2c.readfrom(addr, len, stop=True) 参数 addr: 从机地址 len： 数据长度 stop： 是否产生停止信号，保留，目前只能使用默认值Ture 返回值 读取到的数据，bytes 类型 readfrom_into 读取数据并放到制定变量中 i2c.readfrom_into(addr, buf, stop=True) 参数 addr: 从机地址 buf： bytearray类型， 定义了长度，读取到的数据存放在此 stop： 是否产生停止信号，保留，目前只能使用默认值Ture 返回值 无 writeto 发送数据到从机 i2c.writeto(addr, buf, stop=True) 参数 addr: 从机地址 buf： 需要发送的数据 stop： 是否产生停止信号，保留，目前只能使用默认值Ture 返回值 成功发送的字节数 readfrom_mem 读取从机寄存器 i2c.readfrom_mem(addr, memaddr, nbytes, mem_size=8) 参数 addr: 从机地址 memaddr： 从机寄存器地址 nbytes： 需要读取的长度 mem_size： 寄存器宽度， 默认为8位 返回值 返回bytes类型的读取到的数据 readfrom_mem_into 读取从机寄存器值到指定变量中 i2c.readfrom_mem_into(addr, memaddr, buf, mem_size=8) 参数 addr: 从机地址 memaddr： 从机寄存器地址 buf： bytearray类型， 定义了长度，读取到的数据存放在此 mem_size： 寄存器宽度， 默认为8位 返回值 无 writeto_mem 写数据到从机寄存器 i2c.writeto_mem(addr, memaddr, buf, mem_size=8) 参数 addr: 从机地址 memaddr： 从机寄存器地址 buf： 需要写的数据 mem_size： 寄存器宽度， 默认为8位 返回值 无 deinit/_del_ 注销I2C硬件，释放占用的资源，关闭I2C时钟 i2c.deinit() 参数 无 返回值 无 例子 i2c.deinit() 或者 del i2c 常量 I2C0: I2C 0 I2C1: I2C 1 I2C2: I2C 2 MODE_MASTER: 作为主机模式 MODE_SLAVE: 作为从机模式 I2C_EV_START: 事件类型，开始信号 I2C_EV_RESTART: 事件类型，重新开始信号 I2C_EV_STOP: 事件类型，结束信号 例程 例程 1： 扫描从机设备 from machine import I2C i2c = I2C(I2C.I2C0, freq=100000, scl=28, sda=29) devices = i2c.scan() print(devices) 例程 2： 读写 import time from machine import I2C i2c = I2C(I2C.I2C0, freq=100000, scl=28, sda=29) i2c.writeto(0x24,b'123') i2c.readfrom(0x24,5) 例程 3： 从机模式 from machine import I2C count = 0 def on_receive(data): print(\"on_receive:\",data) def on_transmit(): count = count+1 print(\"on_transmit, send:\",count) return count def on_event(event): print(\"on_event:\",event) i2c = I2C(I2C.I2C0, mode=I2C.MODE_SLAVE, scl=28, sda=29, addr=0x24, addr_size=7, on_receive=on_receive, on_transmit=on_transmit, on_event=on_event) 例程 4： OLED(ssd1306 128x64) import time from machine import I2C SSD1306_CMD = 0 SSD1306_DATA = 1 SSD1306_ADDR = 0x3c def oled_init(i2c): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xAE, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x20, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x10, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xb0, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xc8, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x00, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x10, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x40, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x81, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xff, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa1, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa6, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa8, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x3F, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xa4, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xd3, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x00, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xd5, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xf0, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xd9, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x22, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xda, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x12, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xdb, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x20, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x8d, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x14, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xaf, mem_size=8) def oled_on(i2c): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X8D, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X14, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0XAF, mem_size=8) def oled_off(i2c): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X8D, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0X10, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0XAE, mem_size=8) def oled_fill(i2c, data): for i in range(0,8): i2c.writeto_mem(SSD1306_ADDR, 0x00, 0xb0+i, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x10, mem_size=8) i2c.writeto_mem(SSD1306_ADDR, 0x00, 0x01, mem_size=8) for j in range(0,128): i2c.writeto_mem(SSD1306_ADDR, 0x40, data, mem_size=8) i2c = I2C(I2C.I2C0, mode=I2C.MODE_MASTER, freq=400000, scl=28, sda=29, addr_size=7) time.sleep(1) oled_init(i2c) oled_fill(i2c, 0xff) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/machine/pwm.html":{"url":"api_reference/machine/pwm.html","title":"PWM","keywords":"","body":"machine.PWM PWM： 脉宽调制模块， 硬件支持的PWM， 可以指定任意引脚（0到47引脚） 每个 PWM 依赖于一个定时器， 即当定时器与 PWM 功能绑定后， 不能作为普通定时器使用了。 因为有 3 个定时器， 每个定时器有 4 个通道， 即最大可以同时产生 12 路 PWM 波形 构造函数 pwm = machine.PWM(tim, freq, duty, pin, enable=True) 通过指定的参数新建一个 PWM 对象 参数 tim: 每个PWM依赖一个定时器来产生波形， 所以这里需要传一个定时器对象，这个定时器对象必须初始化时必须指定定时器 ID 和通道号 freq： PWM 波形频率 duty： PWM 占空比， 指高电平占整个周期的百分比，取值：[0,100] [pin]： PWM 输出引脚。 可以不设置，而是使用 fm 统一管理引脚映射。 enable： 是否立即开始产生波形，默认位True，及对象生成后立即开始在指定的引脚上产生 PWM 波形 方法 init 类似构造函数 pwm.init(tim, freq, duty, pin, enable=True) 参数 与构造函数相同 返回值 无 freq 获取或者设置 PWM 频率 pwm.freq(freq) 参数 freq： PWM 频率， 可选参数， 如果不传参数则步设置只返回当前频率值 返回值 当前设置的实际的 PWM 频率 duty 获取或者设置 PWM 占空比 pwm.duty(duty) 参数 duty： PWM 占空比 可选， 如果不传参数则步设置只返回当前占空比值 返回值 当前设置的 PWM 占空比值 enable 使能 PWM 输出， 使指定的引脚上立即产生波形 pwm.enable() 参数 无 返回值 无 disable 失能 PWM 输出， 指定的引脚不再产生波形 pwm.disable() 参数 无 返回值 无 deinit/_del_ 注销 PWM 硬件，释放占用的资源，关闭 PWM 时钟 pwm.deinit() 参数 无 返回值 无 例子 pwm.deinit() 或者 del pwm 常量 无 例程 例程 1 （呼吸灯） from machine import Timer,PWM import time from fpioa_manager import board_info tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PWM) ch = PWM(tim, freq=500000, duty=50, pin=board_info.LED_G) duty=0 dir = True while True: if dir: duty += 10 else: duty -= 10 if duty>100: duty = 100 dir = False elif duty 例程 2 import time import machine from fpioa_manager import board_info tim = machine.Timer(machine.Timer.TIMER0, machine.Timer.CHANNEL0, mode=machine.Timer.MODE_PWM) ch0 = machine.PWM(tim, freq=3000000, duty=20, pin=board_info.LED_G, enable=False) ch0.enable() time.sleep(3) ch0.freq(2000000) print(\"freq:\",ch0.freq()) ch0.duty(60) time.sleep(3) ch0.disable() powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/machine/spi.html":{"url":"api_reference/machine/spi.html","title":"SPI","keywords":"","body":"machine.SPI SPI（Serial Peripheral Interface） 是一个同步串行协议，由主机和从机组成。 标准4线模式由 SCK（SCLK）， CS（片选）， MOSI， MISO 4条线连接主从机 在 K210 上， SPI 有一下特征： 共有 4 个 SPI 设备， 其中 SPI0 、SPI1、 SPI3 只能工作在主机模式下， SPI2 只能工作在从机模式时下， 在 MaixPy 上， SPI3 已经用来连接了 SPI Flash 作为保留硬件资源。 支持 1/2/4/8 线全双工模式， 在 MaixPy 中， 目前只支持标准（摩托罗拉）4线全双工模式（即 SCK， MOSI， MISO， CS 四个引脚） 最高传输速率 45M：1/2主频，约 200Mbps 支持 DMA 4个可配置任意引脚的硬件片选 构造函数 spi = machine.SPI(id, mode=SPI.MODE_MASTER, baudrate=500000, polarity=0, phase=0, bits=8, firstbit=SPI.MSB, sck, mosi, miso, cs0, cs1, cs2, cs3) 通过指定的参数新建一个 SPI 对象 参数 id： SPI ID， 取值范围[0,4]， 目前只支持 0 和 1 、4 ， 并且只能是主机模式， 2 只能作为从机，目前未实现， 3 保留, 4 使用软模拟 SPI（.SPI_SOFT） mode： SPI 模式， MODE_MASTER 或者MODE_MASTER_2或者MODE_MASTER_4或者MODE_MASTER_8或者MODE_SLAVE， 目前只支持MODE_MASTER baudrate： SPI 波特率（频率） polarity： 极性， 取值为 0 或 1， 表示 SPI 在空闲时的极性， 0 代表低电平， 1 代表高电平 phase： 相， 取值位 0 或 1， 表示在时钟的第一个还是第二个跳变沿采集数据， 0 表示第一个， 1 表示第二个 bits： 数据宽度， 默认值为8， 取值范围[4,32] firstbit： 指定传输采用 MSB 还是 LSB 顺序传输， 默认 SPI.MSB sck: SCK（时钟）引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 mosi: MOSI（主机输出） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 miso: MISO（主机输入） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 cs0: CS0（片选） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 cs1: CS1（片选） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 cs2: CS2（片选） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 cs3: CS3（片选） 引脚， 可直接传引脚数值，取值范围：[0,47]。 可以不设置，而是使用 fm 统一管理引脚映射。 d0~d7： 数据引脚， 在非标准4线模式中使用，目前保留。 可以不设置，而是使用 fm 统一管理引脚映射。 方法 init 类似构造函数 spi.init(id, mode=SPI.MODE_MASTER, baudrate=500000, polarity=0, phase=0, bits=8, firstbit=SPI.MSB, sck, mosi, miso, cs0) 参数 与构造函数相同 返回值 无 read 读取数据 spi.read(nbytes, write=0x00, cs=SPI.CS0) 参数 nbytes： 需要读取的长度 cs： 选择片选引脚， 在初始化时已经为cs0~cs3设置了引脚，这里只需要选择SPI.CS0~SPI.CS3即可，默认为SPI.CS0 write： 因为是全双工，设置在读取时MOSI引脚的值，默认为0x00，即始终为低电平 返回值 bytes类型的数据 readinto 读取数据，并放到指定变量中 spi.readinto(buf, write=0x00, cs=SPI.CS0) 参数 buf： bytearray 类型， 定义了长度，读取完成后数据保存在此 cs： 选择片选引脚， 在初始化时已经为cs0~cs3设置了引脚，这里只需要选择SPI.CS0~SPI.CS3即可，默认为SPI.CS0 write： 因为是全双工，设置在读取时MOSI引脚的值，默认为0x00，即始终为低电平 返回值 无 write 发送数据 spi.write(buf, cs=SPI.CS0) 参数 buf： bytearray 类型， 定义了数据及长度 cs： 选择片选引脚， 在初始化时已经为cs0~cs3设置了引脚，这里只需要选择SPI.CS0~SPI.CS3即可，默认为SPI.CS0 返回值 无 write_readinto 发送数据，同时读取数据到变量，即全双工 spi.write(write_buf, read_buf, cs=SPI.CS0) 参数 write_buf： bytearray 类型， 定义了需要发送的数据及长度 read_buf： bytearray 类型， 定义了接收数据存放的位置 cs： 选择片选引脚， 在初始化时已经为cs0~cs3设置了引脚，这里只需要选择SPI.CS0~SPI.CS3即可，默认为SPI.CS0 返回值 无 deinit/_del_ 注销 SPI，释放硬件，关闭 SPI 时钟 spi.deinit() 参数 无 返回值 无 例子 spi.deinit() 或者 del spi 常量 SPI0: SPI 0 SPI1: SPI 1 SPI2: SPI 2 MODE_MASTER: 作为主机模式 MODE_MASTER_2: 作为主机模式 MODE_MASTER_4: 作为主机模式 MODE_MASTER_8: 作为主机模式 MODE_SLAVE: 作为从机模式 MSB： MSB， 即先发送高位或高字节 LSB： LSB， 即先发送低位或者低字节 CS0： 片选0 CS1： 片选1 CS2： 片选2 CS3： 片选3 例程 例程 1： 基本读写 from machine import SPI spi = SPI(SPI.SPI1, mode=SPI.MODE_MASTER, baudrate=10000000, polarity=0, phase=0, bits=8, firstbit=SPI.MSB, sck=28, mosi=29, miso=30, cs0=27) w = b'1234' r = bytearray(4) spi.write(w) spi.write(w, cs=SPI.CS0) spi.write_readinto(w, r) spi.read(5, write=0x00) spi.readinto(r, write=0x00) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/machine/timer.html":{"url":"api_reference/machine/timer.html","title":"Timer","keywords":"","body":"machine.Timer 硬件定时器，可以用来定时触发任务或者处理任务，设定时间到了后可以触发中断（调用回调函数），精度比软件定时器高。 需要注意的是，定时器在不同的硬件中可能会有不同的表现。MicroPython 的 Timer 类定义了在给定时间段内（或在一段延迟后执行一次回调）执行回调的基本操作，并允许特定的硬件上定义更多的非标准行为（因此不能移植到其他板）。 共有 3 个定时器， 每个定时器有 4 个通道可以使用 构造函数 tim = machine.Timer(id, channel, mode=Timer.MODE_ONE_SHOT, period=1000, unit=Timer.UNIT_MS, callback=None, arg=None, start=True, priority=1, div=0) 通过指定的参数新建一个 Timer 对象 参数 id: Timer ID, [0~2] (Timer.TIMER0~TIMER2) channel: Timer 通道, [Timer.CHANNEL0~Timer.CHANNEL3] mode: Timer 模式, MODE_ONE_SHOT 或者 MODE_PERIODIC 或者 MODE_PWM period: Timer 周期, 在启动定时器后 period 时间， 回调函数将会被调用，(0,~) unit: 设置周期的单位，默认位毫秒（ms），Timer.UNIT_S 或者 Timer.UNIT_MS 或者 Timer.UNIT_US 或者Timer.UNIT_NS callback: 定时器回调函数， 定义了两个参数， 一个是定时器对象Timer， 第二个是在定义对象是希望传的参数arg，更多请看arg参数解释 注意：回调函数是在中断中调用的，所以在回调函数中请不要占用太长时间以及做动态分配开关中断等动作 arg: 希望传给回调函数的参数，作为回调函数的第二个参数 start: 是否在对象构建成功后立即开始定时器， True：立即开始， False:不立即开启，需要调用start()函数来启动定时器 priority: 硬件定时器中断优先级， 与特定的CPU相关， 在K210中，取值范围是[1,7]， 值越小优先级越高 div: 硬件定时器分频器，取值范围[0,255]， 默认为0， clk_timer（定时器时钟频率） = clk_pll0（锁相环0频率）/2^(div+1) clk_timer*period(unit:s) 应该 =1 方法 init 类似构造函数 tim.init(id, channel, mode=Timer.MODE_ONE_SHOT, period=1000, unit=Timer.UNIT_MS, callback=None, arg=None, start=True, priority=1, div=0) 参数 类似构造函数 返回值 无 callback_arg 获取设置的传给回调函数的参数，只能是 Timer 对象调用， 类 Timer 不能调用 callback 获取或者设置回调函数 tim.callback(callback) 参数 callback： 设置的回调函数，可选参数， 如果不传参数，则只返回先有的回调函数 返回值 当前的回调函数 例子 def on_timer(timer): print(\"time up:\",timer) print(\"param:\",timer.callback_arg()) tim.callback(on_timer) print(on_timer, tim.callback()) period 获取或者设置定时周期 tim.period(period) 参数 period： 可选参数，配置周期， 如果不传参数， 则只返回当前周期值 返回值 当前周期值 例子 tim.period(2000) print( tim.period() ) start 启动定时器 tim.start() 参数 无 返回值 无 例子 tim.start() stop 停止定时器 tim.stop() 参数 无 返回值 无 restart 重新开启定时器 tim.restart() 参数 无 返回值 无 deinit/_del_ 注销定时器，并且注销硬件的占用，关闭硬件的时钟 tim.deinit() 参数 无 返回值 无 例子 tim.deinit() 或者 del tim 常量 TIMER0: Timer0 id TIMER1: Timer1 id TIMER2: Timer2 id CHANNEL0: Timer 通道 0 CHANNEL1: Timer 通道 1 CHANNEL2: Timer 通道 2 CHANNEL3: Timer 通道 3 MODE_ONE_SHOT: Timer 只运行一次（回调一次） MODE_PERIODIC: Timer 始终运行（连续回调） MODE_PWM: 定时器不用来回调函数，用以产生PWM UNIT_S: 单位秒 (s) UNIT_MS: 单位毫秒 (ms) UNIT_US: 单位微秒 (us) UNIT_NS: 单位纳秒 (ns) 例程 例程 1 定时3秒后打印信息 from machine import Timer def on_timer(timer): print(\"time up:\",timer) print(\"param:\",timer.callback_arg()) tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_ONE_SHOT, period=3000, callback=on_timer, arg=on_timer) print(\"period:\",tim.period()) 例程 2 每隔 1 秒打印消息， 停止 5 秒后再重启， 5 秒后关闭并注销定时器 import time from machine import Timer def on_timer(timer): print(\"time up:\",timer) print(\"param:\",timer.callback_arg()) tim = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PERIODIC, period=1, unit=Timer.UNIT_S, callback=on_timer, arg=on_timer, start=False, priority=1, div=0) print(\"period:\",tim.period()) tim.start() time.sleep(5) tim.stop() time.sleep(5) tim.restart() time.sleep(5) tim.stop() del tim powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/machine/uart.html":{"url":"api_reference/machine/uart.html","title":"UART","keywords":"","body":"machine.UART uart 模块主要用于驱动开发板上的异步串口，可以自由对 uart 进行配置。k210 一共有3个 uart，每个 uart 可以进行自由的引脚映射。 构造 引脚映射 在使用 uart 前，我们需要使用 fm 来对芯片引脚进行映射和管理。如下所示，将 PIN10 设置为 uart2 的发送引脚，PIN11 设置为 uart2 的接收引脚 fm.register(board_info.PIN10,fm.fpioa.UART2_TX) fm.register(board_info.PIN11,fm.fpioa.UART2_RX) 构造函数 uart = machine.UART(uart,baudrate,bits,parity,stop,timeout, read_buf_len) 通过指定的参数新建一个 UART 对象 参数 uart UART 号，使用指定的 UART，可以通过 machine.UART. 按tab键来补全 baudrate: UART 波特率 bits: UART 数据宽度，支持 5/6/7/8 (默认的 REPL 使用的串口（UARTHS）只支持 8 位模式)， 默认 8 parity: 奇偶校验位，支持 None, machine.UART.PARITY_ODD, machine.UART.PARITY_EVEN （默认的 REPL 使用的串口（UARTHS）只支持 None）， 默认 None stop: 停止位， 支持 1， 1.5, 2， 默认 1 timeout: 串口接收超时时间 read_buf_len： 串口接收缓冲，串口通过中断来接收数据，如果缓冲满了，将自动停止数据接收 返回值 UART对象 方法 init 用于初始化 uart，一般在构造对象时已经初始化，这里用在重新初始化 uart uart.init(baudrate,bits,parity,stop,timeout, read_buf_len) 参数 同构造函数，但不需要第一个UART号 返回值 无 read 用于读取串口缓冲中的数据 uart.read(num) 参数 num: 读取字节的数量，一般填入缓冲大小，如果缓冲中数据的数量没有 num 大，那么将只返回缓冲中剩余的数据 返回值 bytes类型的数据 readline 用于读取串口缓冲数据的一航 uart.readline(num) num: 读取行的数量 返回值 *bytes类型的数据 write 用于使用串口发送数据 uart.write(buf) 参数 buf: 需要发送到数据 返回值 写入的数据量 deinit 注销 UART 硬件，释放占用的资源 uart.deinit() 参数 无 返回值 无 repl_uart() 获取用于 REPL 的串口对象 返回值 用于 REPL 的串口对象， 默认初始化位 115200 8 N 1 例程 例程 1 在运行里程之前，请确认 PIN15 已经连接到 PIN10， PIN17 已经连接到 PIN9 运行程序后，可以在终端看到 baudrate:115200 bits:8 parity:0 stop:0 ---check Successfully 的打印信息 from fpioa_manager import fm from machine import UART fm.register(board_info.PIN15,fm.fpioa.UART1_TX) fm.register(board_info.PIN17,fm.fpioa.UART1_RX) fm.register(board_info.PIN9,fm.fpioa.UART2_TX) fm.register(board_info.PIN10,fm.fpioa.UART2_RX) uart_A = UART(UART.UART1, 115200, 8, None, 1, timeout=1000, read_buf_len=4096) uart_B = UART(UART.UART2, 115200, 8, None, 1, timeout=1000, read_buf_len=4096) write_str = 'hello world' for i in range(20): uart_A.write(write_str) read_data = uart_B.read() read_str = read_data.decode('utf-8') print(\"string = \",read_str) if read_str == write_str: print(\"baudrate:115200 bits:8 parity:None stop:1 ---check Successfully\") uart_A.deinit() uart_B.deinit() del uart_A del uart_B 例程 2 AT模块串口 fm.register(board_info.WIFI_RX,fm.fpioa.UART2_TX) fm.register(board_info.WIFI_TX,fm.fpioa.UART2_RX) uart = machine.UART(machine.UART.UART2,115200,timeout=1000, read_buf_len=4096) 例程 3 修改 REPL 串口波特率 from machine import UART repl = UART.repl_uart() repl.init(1500000, 8, None, 1, read_buf_len=2048) 例程 3 修改 REPL 串口 from machine import UART fm.register(board_info.PIN15,fm.fpioa.UART1_TX) fm.register(board_info.PIN17,fm.fpioa.UART1_RX) uart = machine.UART(UART.UART1, 115200) UART.set_repl_uart(uart) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/machine/network.html":{"url":"api_reference/machine/network.html","title":"network","keywords":"","body":"network 该模块用于初始化各种网卡驱动，网卡具有连接路由，断开路由，查看网卡连接信息，检查是否连接等功能。 使用WiFi请确保已经接上了天线 esp8285 在部分开发板上带了 一个 使用AT方式交互的网卡模块，比如esp8285，与k210通过串口连接 引脚8是使能脚，可以创建一个GPIO对象来控制它的高低电平来实现使能和失能，也可以用它复位（先低后高），复位后需要等待一小段时间才能操作， 可以查看例程wifi_ap_scan.py esp32 目前在MaixDuino开发板中有一个 esp32 模块通过 spi 与k210相连 同时也有单独的TF插卡式模块 ESP8285_Module network.ESP8285(uart) 构造一个ESP8285网卡对象，使用该方法需要传入一个uart对象，在MaixPy目前支持的dock和GO上，是使用AT指令模块作为WiFi。所以该uart对象是与AT模块通信的对象，可以查看uart模块例程 调用此方法会初始化ESP8285， 如果失败会抛出异常 参数 uart: 与AT模块通信的UART对象 返回值 ESP8285: 网卡对象 ESP8285 connect(ssid, key) 连接热点（AP/路由器） 参数 ssid: 热点的SSID key: 热点的密码 返回值 无， 如果发生错误会抛出异常 2.2. ifconfig 查看wifi连接信息，目前network不支持设置网卡配置 nic.ifconfig() 参数 无 返回值 tuple 类型， 元素都是字符串：(ip, netmask, gateway, dns_server, dhcp_server, mac, ssid)， 如果没有查询到或者无效，值为\"0\" isconnected 查看wifi是否连接 nic.isconnected() 参数 无 返回值 True: 已经连接 False: 断开连接 disconnect 断开wifi连接 参数 无 返回值 无 scan 扫描周围的热点信息 参数 无 返回值 一个 list对象， 每个元素包含了一个字符串， 字符串来自AT模块的响应，内容和esp8285的AT指令文档所描述的相同，如下： ',,,,,,,, ,,' ：加密⽅式 0：OPEN 1：WEP 2：WPA_PSK 3：WPA2_PSK 4：WPA_WPA2_PSK 5：WPA2_Enterprise（⽬前 AT 不⽀持连接这种加密 AP） ：字符串参数，AP 的 SSID ：信号强度 ：字符串参数，AP 的 MAC 地址 ：信道号 ：AP 频偏，单位：kHz。此数值除以 2.4，可得到 ppm 值 ：频偏校准值 : 0：CIPHER_NONE 1：CIPHER_WEP40 2：CIPHER_WEP104 3：CIPHER_TKIP 4：CIPHER_CCMP 5：CIPHER_TKIP_CCMP 6：CIPHER_UNKNOWN : 定义与 相同 : bit0 代表 b 模式; bit1 代表 g 模式; bit2 代表 n 模式 若对应 bit 为 1，表示该模式使能；若对应 bit 为 0，则该模式未使能。 ：0，WPS 未使能；1，WPS 使能 比如： info_strs = ['4,\"ChinaNet-lot0\",-79,\"c8:50:e9:e8:21:3e\",1,-42,0,4,3,7,1', '4,\"TOPSTEP2G4\",-7 0,\"f8:e7:1e:0d:0d:f8\",1,-57,0,4,4,7,0'] 这看起来可能会比较奇怪，因为每个AP的信息都是一串字符，信息里面还有整型和字符串，字符串用双引号括起来的，所以拿到这个字符串后需要再次处理后再使用，比如： def wifi_deal_ap_info(info): res = [] for ap_str in info: ap_str = ap_str.split(\",\") info_one = [] for node in ap_str: if node.startswith('\"'): info_one.append(node[1:-1]) else: info_one.append(int(node)) res.append(info_one) return res info_strs = ['4,\"ChinaNet-lot0\",-79,\"c8:50:e9:e8:21:3e\",1,-42,0,4,3,7,1', '4,\"TOPSTEP2G4\",-70,\"f8:e7:1e:0d:0d:f8\",1,-57,0,4,4,7,0'] info = wifi_deal_ap_info(info_strs) print(info) 输出是： [[4, 'ChinaNet-lot0', -79, 'c8:50:e9:e8:21:3e', 1, -42, 0, 4, 3, 7, 1], [4, 'TOPSTEP2G4', -70, 'f8:e7:1e:0d:0d:f8', 1, -57, 0, 4, 4, 7, 0]] 然后比如我们需要获得所有AP的SSID只需要使用 for ap_info in info: print(ap_info[1]) enable_ap(ssid, key, chl=5, ecn=3) 警告：截止 2020年11月26日前， MaixPy 的 socket 还未实现 listen / bind / accpet 等函数操作。 打开热点 参数 ssid: SSID key： 密码 chl： WiFi信号的通道号 ecn： 加密方法， 有OPEN``WPA2_PSK等，参考本页ESP8285的常量部分， 默认值是3， 也就是ESP8285.WPA2_PSK，比如nic = network.ESP8285(uart) nic.enable_ap(\"maixpy\", \"12345678\", 5, nic.OPEN) 或者nic.enable_ap(\"maixpy\", \"12345678\", 5, network.ESP8285.OPEN) disable_ap() 关闭热点 常量 OPEN 热点的加密方式为不需要密码 WPA_PSK 热点的加密方式为 WPA_PSK WPA2_PSK 热点的加密方式为 WPA2_PSK WPA_WPA2_PSK 热点的加密方式为 WPA_WPA2_PSK 例程 参考network目录下的例程 ESP32_Module network.ESP32_SPI(cs,rst,rdy,mosi,miso,sclk) 构造一个ESP32_SPI网卡对象，需要传入对应的GPIOHS FUNC 如果传入参数数量不对，会返回错误 注意 想要在 maixduino 上 SPI 和 SD 不冲突，需要设置 ESP32_SPI 为硬件 SPI 配置。 参数 对应引脚功能的 fpioa_func 返回值 ESP32_SPI 网卡对象 ESP32_SPI adc 读取esp32模块的adc值 参数 无 返回值 tunple，5个通道的adc值顺序是\"PIN36\", \"PIN39\", \"PIN34\", \"PIN35\", \"PIN32\" 例程 demo_esp32_read_adc.py powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/Maix/":{"url":"api_reference/Maix/","title":"Maix","keywords":"","body":"Maix库 FPIOA GPIO KPU FFT I2S Audio freq utils powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/Maix/fpioa.html":{"url":"api_reference/Maix/fpioa.html","title":"FPIOA","keywords":"","body":"FPIOA (现场可编程 IO 阵列， Field Programmable Input and Output Array) K210 支持每个外设随意映射到任意引脚， 使用 FPIOA 功能来实现。 注意: 以下 GPIOHS 默认已经被使用， 程序中如非必要尽量不要使用： GPIOHS 功能 描述 GPIOHS5 LCD_DC LCD 读写信号引脚 GPIOHS4 LCD_RST LCD 复位芯片脚 GPIOHS29 SD_CS SD 卡 SPI 片选 GPIOHS28 MIC_LED_CLK SK9822_DAT GPIOHS27 MIC_LED_DATA SK9822_CLK 类 FPIOA 方法 help(func) 显示外设及其简要描述 参数 func： 外设名（功能/编号），可以不传参， 则以表格的形式显示所有外设名即简要描述，这个表格也可以在本页的末尾找到（附录：外设表）； 如果传参，则传一个整型值， 找到该编号对应的外设后会打印外设名和描述， 比如 FPIOA.JTAG_TCLK 或者 fm.fpioa.JTAG_TCLK（fm在本页后面介绍） 或者 0 比如： from Maix import FPIOA fpioa = FPIOA() fpioa.help() fpioa.help(0) fpioa.help(fpioa.JTAG_TCLK) fm.fpioa.help() fm.fpioa.help(fm.fpioa.JTAG_TCLK) 返回 外设名及其简要描述 set_function(pin, func) 设置引脚对应的外设功能， 即引脚映射 参数 pin： 引脚编号，取值 [0, 47]， 具体的引脚连接请看电路图， 也可以使用 board_info. 然后按 TAB 按键补全来获得板子的常用引脚，比如 board_info.LED_G func： 外设功能，传一个整型值，可以通过 fm.fpioa.help()或者查本页末尾的 附录： 外设表 表得到 比如 需要将连接 绿色 LED 的引脚映射到 高速 GPIO0 上： fpioa = FPIOA() fpioa.set_function(board_info.LED_G, fm.fpioa.GPIOHS0) get_Pin_num(func) 获取外设映射到哪个引脚上了 参数 func： 外设功能，传一个整型值，可以通过 fm.fpioa.help()或者查本页末尾的 附录： 外设表 表得到 比如： fpioa = FPIOA() fpioa.set_function(board_info.LED_G, fm.fpioa.GPIOHS0) pin = fpioa.get_Pin_num(fm.fpioa.GPIOHS0) if pin == board_info.LED_G: print(\"set function ok\") 附录： 外设表 外设功能（func） 简要描述 JTAG_TCLK JTAG Test Clock JTAG_TDI JTAG Test Data In JTAG_TMS JTAG Test Mode Select JTAG_TDO JTAG Test Data Out SPI0_D0 SPI0 Data 0 SPI0_D1 SPI0 Data 1 SPI0_D2 SPI0 Data 2 SPI0_D3 SPI0 Data 3 SPI0_D4 SPI0 Data 4 SPI0_D5 SPI0 Data 5 SPI0_D6 SPI0 Data 6 SPI0_D7 SPI0 Data 7 SPI0_SS0 SPI0 Chip Select 0 SPI0_SS1 SPI0 Chip Select 1 SPI0_SS2 SPI0 Chip Select 2 SPI0_SS3 SPI0 Chip Select 3 SPI0_ARB SPI0 Arbitration SPI0_SCLK SPI0 Serial Clock UARTHS_RX UART High speed Receiver UARTHS_TX UART High speed Transmitter RESV6 Reserved function RESV7 Reserved function CLK_SPI1 Clock SPI1 CLK_I2C1 Clock I2C1 GPIOHS0 GPIO High speed 0 GPIOHS1 GPIO High speed 1 GPIOHS2 GPIO High speed 2 GPIOHS3 GPIO High speed 3 GPIOHS4 GPIO High speed 4 GPIOHS5 GPIO High speed 5 GPIOHS6 GPIO High speed 6 GPIOHS7 GPIO High speed 7 GPIOHS8 GPIO High speed 8 GPIOHS9 GPIO High speed 9 GPIOHS10 GPIO High speed 10 GPIOHS11 GPIO High speed 11 GPIOHS12 GPIO High speed 12 GPIOHS13 GPIO High speed 13 GPIOHS14 GPIO High speed 14 GPIOHS15 GPIO High speed 15 GPIOHS16 GPIO High speed 16 GPIOHS17 GPIO High speed 17 GPIOHS18 GPIO High speed 18 GPIOHS19 GPIO High speed 19 GPIOHS20 GPIO High speed 20 GPIOHS21 GPIO High speed 21 GPIOHS22 GPIO High speed 22 GPIOHS23 GPIO High speed 23 GPIOHS24 GPIO High speed 24 GPIOHS25 GPIO High speed 25 GPIOHS26 GPIO High speed 26 GPIOHS27 GPIO High speed 27 GPIOHS28 GPIO High speed 28 GPIOHS29 GPIO High speed 29 GPIOHS30 GPIO High speed 30 GPIOHS31 GPIO High speed 31 GPIO0 GPIO pin 0 GPIO1 GPIO pin 1 GPIO2 GPIO pin 2 GPIO3 GPIO pin 3 GPIO4 GPIO pin 4 GPIO5 GPIO pin 5 GPIO6 GPIO pin 6 GPIO7 GPIO pin 7 UART1_RX UART1 Receiver UART1_TX UART1 Transmitter UART2_RX UART2 Receiver UART2_TX UART2 Transmitter UART3_RX UART3 Receiver UART3_TX UART3 Transmitter SPI1_D0 SPI1 Data 0 SPI1_D1 SPI1 Data 1 SPI1_D2 SPI1 Data 2 SPI1_D3 SPI1 Data 3 SPI1_D4 SPI1 Data 4 SPI1_D5 SPI1 Data 5 SPI1_D6 SPI1 Data 6 SPI1_D7 SPI1 Data 7 SPI1_SS0 SPI1 Chip Select 0 SPI1_SS1 SPI1 Chip Select 1 SPI1_SS2 SPI1 Chip Select 2 SPI1_SS3 SPI1 Chip Select 3 SPI1_ARB SPI1 Arbitration SPI1_SCLK SPI1 Serial Clock SPI_SLAVE_D0 SPI Slave Data 0 SPI_SLAVE_SS SPI Slave Select SPI_SLAVE_SCLK SPI Slave Serial Clock I2S0_MCLK I2S0 Master Clock I2S0_SCLK I2S0 Serial Clock(BCLK) I2S0_WS I2S0 Word Select(LRCLK) I2S0_IN_D0 I2S0 Serial Data Input 0 I2S0_IN_D1 I2S0 Serial Data Input 1 I2S0_IN_D2 I2S0 Serial Data Input 2 I2S0_IN_D3 I2S0 Serial Data Input 3 I2S0_OUT_D0 I2S0 Serial Data Output 0 I2S0_OUT_D1 I2S0 Serial Data Output 1 I2S0_OUT_D2 I2S0 Serial Data Output 2 I2S0_OUT_D3 I2S0 Serial Data Output 3 I2S1_MCLK I2S1 Master Clock I2S1_SCLK I2S1 Serial Clock(BCLK) I2S1_WS I2S1 Word Select(LRCLK) I2S1_IN_D0 I2S1 Serial Data Input 0 I2S1_IN_D1 I2S1 Serial Data Input 1 I2S1_IN_D2 I2S1 Serial Data Input 2 I2S1_IN_D3 I2S1 Serial Data Input 3 I2S1_OUT_D0 I2S1 Serial Data Output 0 I2S1_OUT_D1 I2S1 Serial Data Output 1 I2S1_OUT_D2 I2S1 Serial Data Output 2 I2S1_OUT_D3 I2S1 Serial Data Output 3 I2S2_MCLK I2S2 Master Clock I2S2_SCLK I2S2 Serial Clock(BCLK) I2S2_WS I2S2 Word Select(LRCLK) I2S2_IN_D0 I2S2 Serial Data Input 0 I2S2_IN_D1 I2S2 Serial Data Input 1 I2S2_IN_D2 I2S2 Serial Data Input 2 I2S2_IN_D3 I2S2 Serial Data Input 3 I2S2_OUT_D0 I2S2 Serial Data Output 0 I2S2_OUT_D1 I2S2 Serial Data Output 1 I2S2_OUT_D2 I2S2 Serial Data Output 2 I2S2_OUT_D3 I2S2 Serial Data Output 3 RESV0 Reserved function RESV1 Reserved function RESV2 Reserved function RESV3 Reserved function RESV4 Reserved function RESV5 Reserved function I2C0_SCLK I2C0 Serial Clock I2C0_SDA I2C0 Serial Data I2C1_SCLK I2C1 Serial Clock I2C1_SDA I2C1 Serial Data I2C2_SCLK I2C2 Serial Clock I2C2_SDA I2C2 Serial Data CMOS_XCLK DVP System Clock CMOS_RST DVP System Reset CMOS_PWDN DVP Power Down Mode CMOS_VSYNC DVP Vertical Sync CMOS_HREF DVP Horizontal Reference output CMOS_PCLK Pixel Clock CMOS_D0 Data Bit 0 CMOS_D1 Data Bit 1 CMOS_D2 Data Bit 2 CMOS_D3 Data Bit 3 CMOS_D4 Data Bit 4 CMOS_D5 Data Bit 5 CMOS_D6 Data Bit 6 CMOS_D7 Data Bit 7 SCCB_SCLK SCCB Serial Clock SCCB_SDA SCCB Serial Data UART1_CTS UART1 Clear To Send UART1_DSR UART1 Data Set Ready UART1_DCD UART1 Data Carrier Detect UART1_RI UART1 Ring Indicator UART1_SIR_IN UART1 Serial Infrared Input UART1_DTR UART1 Data Terminal Ready UART1_RTS UART1 Request To Send UART1_OUT2 UART1 User-designated Output 2 UART1_OUT1 UART1 User-designated Output 1 UART1_SIR_OUT UART1 Serial Infrared Output UART1_BAUD UART1 Transmit Clock Output UART1_RE UART1 Receiver Output Enable UART1_DE UART1 Driver Output Enable UART1_RS485_EN UART1 RS485 Enable UART2_CTS UART2 Clear To Send UART2_DSR UART2 Data Set Ready UART2_DCD UART2 Data Carrier Detect UART2_RI UART2 Ring Indicator UART2_SIR_IN UART2 Serial Infrared Input UART2_DTR UART2 Data Terminal Ready UART2_RTS UART2 Request To Send UART2_OUT2 UART2 User-designated Output 2 UART2_OUT1 UART2 User-designated Output 1 UART2_SIR_OUT UART2 Serial Infrared Output UART2_BAUD UART2 Transmit Clock Output UART2_RE UART2 Receiver Output Enable UART2_DE UART2 Driver Output Enable UART2_RS485_EN UART2 RS485 Enable UART3_CTS UART3 Clear To Send UART3_DSR UART3 Data Set Ready UART3_DCD UART3 Data Carrier Detect UART3_RI UART3 Ring Indicator UART3_SIR_IN UART3 Serial Infrared Input UART3_DTR UART3 Data Terminal Ready UART3_RTS UART3 Request To Send UART3_OUT2 UART3 User-designated Output 2 UART3_OUT1 UART3 User-designated Output 1 UART3_SIR_OUT UART3 Serial Infrared Output UART3_BAUD UART3 Transmit Clock Output UART3_RE UART3 Receiver Output Enable UART3_DE UART3 Driver Output Enable UART3_RS485_EN UART3 RS485 Enable TIMER0_TOGGLE1 TIMER0 Toggle Output 1 TIMER0_TOGGLE2 TIMER0 Toggle Output 2 TIMER0_TOGGLE3 TIMER0 Toggle Output 3 TIMER0_TOGGLE4 TIMER0 Toggle Output 4 TIMER1_TOGGLE1 TIMER1 Toggle Output 1 TIMER1_TOGGLE2 TIMER1 Toggle Output 2 TIMER1_TOGGLE3 TIMER1 Toggle Output 3 TIMER1_TOGGLE4 TIMER1 Toggle Output 4 TIMER2_TOGGLE1 TIMER2 Toggle Output 1 TIMER2_TOGGLE2 TIMER2 Toggle Output 2 TIMER2_TOGGLE3 TIMER2 Toggle Output 3 TIMER2_TOGGLE4 TIMER2 Toggle Output 4 CLK_SPI2 Clock SPI2 CLK_I2C2 Clock I2C2 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/Maix/gpio.html":{"url":"api_reference/Maix/gpio.html","title":"GPIO","keywords":"","body":"GPIO General Purpose Input Output （通用输入/输出）简称为 GPIO，或总线扩展器。 K210上有高速 GPIO(GPIOHS) 和通用 GPIO 在 K210 上， GPIO 有一下特征： 高速 GPIO： 高速 GPIO 为 GPIOHS，共 32 个。具有如下特点： 可配置输入输出信号 每个 IO 具有独立中断源 中断支持边沿触发和电平触发 每个 IO 可以分配到 FPIOA 上 48 个管脚之一 可配置上下拉，或者高阻 通用 GPIO： 通用 GPIO 共 8 个，具有如下特点: 8 个 IO 使用一个中断源 可配置输入输出信号 可配置触发 IO 总中断，边沿触发和电平触发 每个 IO 可以分配到 FPIOA 上 48 个管脚之一 注意: 一下 GPIOHS 默认已经被使用， 程序中如非必要尽量不要使用： GPIOHS 功能 GPIOHS31 LCD_DC GPIOHS30 LCD_RST GPIOHS29 SD_CS GPIOHS28 MIC_LED_CLK GPIOHS27 MIC_LED_DATA 构造函数 class GPIO(ID, MODE, PULL, VALUE) 通过指定的参数新建一个 SPI 对象 参数 ID： 使用的 GPIO 引脚(一定要使用 GPIO 里带的常量来指定) MODE： GPIO模式 • GPIO.IN就是输入模式 • GPIO.OUT就是输出模式 PULL： GPIO上下拉模式 • GPIO.PULL_UP 上拉 ​• GPIO.PULL_DOWN 下拉 ​• GPIO.PULL_NONE 即不上拉也不下拉 方法 value 修改/读取 GPIO 引脚状态 GPIO.value([value]) 参数 [value]： 可选参数，如果此参数不为空，则返回当前 GPIO 引脚状态 返回值 如果 [value] 参数不为空，则返回当前 GPIO 引脚状态 irq 配置一个中断处理程序，当 pin 的触发源处于活动状态时调用它。如果管脚模式为 pin.in，则触发源是管脚上的外部值。 GPIO.irq(CALLBACK_FUNC,TRIGGER_CONDITION,GPIO.WAKEUP_NOT_SUPPORT,PRORITY) 参数 CALLBACK_FUNC：中断回调函数，当中断触发的时候被调用，一个入口函数 pin_num ​• PIN_NUM 返回的是触发中断的 GPIO 引脚号(只有GPIOHS支持中断，所以这里的引脚号也是GPIOHS的引脚号) TRIGGER_CONDITION：GPIO 引脚的中断触发模式 ​• GPIO.IRQ_RISING 上升沿触发 ​• GPIO.IRQ_FALLING 下降沿触发 ​• GPIO.IRQ_BOTH 上升沿和下降沿都触发 返回值 无 disirq 关闭中断 GPIO.disirq() 参数 无 返回值 无 mode GPIO模式 GPIO.mode(MODE) 参数 MODE • GPIO.IN 就是输入模式 • GPIO.OUT 就是输出模式 返回值 无 pull GPIO上下拉模式 GPIO.pull(PULL) 参数 PULL • GPIO.IRQ_RISING 上升沿触发 • GPIO.IRQ_FALLING 下降沿触发 • GPIO.IRQ_BOTH 上升沿和下降沿都触发 返回值 无 常量 GPIO0: GPIO0 GPIO1: GPIO1 GPIO2: GPIO2 GPIO3: GPIO3 GPIO4: GPIO4 GPIO5: GPIO5 GPIO6: GPIO6 GPIO7: GPIO7 GPIOHS0: GPIOHS0 GPIOHS1: GPIOHS1 GPIOHS2: GPIOHS2 GPIOHS3: GPIOHS3 GPIOHS4: GPIOHS4 GPIOHS5: GPIOHS5 GPIOHS6: GPIOHS6 GPIOHS7: GPIOHS7 GPIOHS8: GPIOHS8 GPIOHS9: GPIOHS9 GPIOHS10: GPIOHS10 GPIOHS11: GPIOHS11 GPIOHS12: GPIOHS12 GPIOHS13: GPIOHS13 GPIOHS14: GPIOHS14 GPIOHS15: GPIOHS15 GPIOHS16: GPIOHS16 GPIOHS17: GPIOHS17 GPIOHS18: GPIOHS18 GPIOHS19: GPIOHS19 GPIOHS20: GPIOHS20 GPIOHS21: GPIOHS21 GPIOHS22: GPIOHS22 GPIOHS23: GPIOHS23 GPIOHS24: GPIOHS24 GPIOHS25: GPIOHS25 GPIOHS26: GPIOHS26 GPIOHS27: GPIOHS27 GPIOHS28: GPIOHS28 GPIOHS29: GPIOHS29 GPIOHS30: GPIOHS30 GPIOHS31: GPIOHS31 GPIO.IN: 输入模式 GPIO.OUT: 输出模式 GPIO.PULL_UP: 上拉 GPIO.PULL_DOWN: 下拉 GPIO.PULL_NONE: 即不上拉也不下拉 GPIO.IRQ_RISING: 上升沿触发 GPIO.IRQ_FALLING:下降沿触发 GPIO.IRQ_BOTH: 上升沿和下降沿都触发 DEMO1: 点亮 LED import utime from Maix import GPIO from board import board_info from fpioa_manager import fm fm.register(board_info.LED_R,fm.fpioa.GPIO0) led_r=GPIO(GPIO.GPIO0,GPIO.OUT) utime.sleep_ms(500) led_r.value() fm.unregister(board_info.LED_R,fm.fpioa.GPIO0) DEMO2: 按键按下点亮 LED import utime from Maix import GPIO from board import board_info from fpioa_manager import fm fm.register(board_info.LED_R,fm.fpioa.GPIO0) led_b = GPIO(GPIO.GPIO0,GPIO.OUT) led_b.value(1) fm.register(board_info.BOOT_KEY, fm.fpioa.GPIOHS1) key = GPIO(GPIO.GPIOHS1, GPIO.IN) utime.sleep_ms(100) while True: if key.value() == 0: # 等待按键按下 led_b.value(0) utime.sleep_ms(1000) break utime.sleep_ms(10) led_b.value(1) fm.unregister(board_info.LED_R,fm.fpioa.GPIOHS0) fm.unregister(board_info.BOOT_KEY,fm.fpioa.GPIOHS1) DEMO3: 在 3 秒内等待按键触发中断 import utime from Maix import GPIO from board import board_info from fpioa_manager import fm def test_irq(pin_num): print(\"key\", pin_num, \"\\n\") fm.register(board_info.BOOT_KEY, fm.fpioa.GPIOHS0) key = GPIO(GPIO.GPIOHS0, GPIO.IN, GPIO.PULL_NONE) utime.sleep_ms(100) key.irq(test_irq, GPIO.IRQ_BOTH, GPIO.WAKEUP_NOT_SUPPORT,7) utime.sleep_ms(3000) # 在 3 秒内等待触发 key.disirq() # 禁用中断 fm.unregister(board_info.BOOT_KEY,fm.fpioa.GPIOHS0) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/Maix/kpu.html":{"url":"api_reference/Maix/kpu.html","title":"KPU","keywords":"","body":"KPU KPU是通用的神经网络处理器，它可以在低功耗的情况下实现卷积神经网络计算，时时获取被检测目标的大小、坐标和种类，对人脸或者物体进行检测和分类。 KPU 具备以下几个特点： 支持主流训练框架按照特定限制规则训练出来的定点化模型 对网络层数无直接限制，支持每层卷积神经网络参数单独配置，包括输入输出通道数目、输入输 出行宽列高 支持两种卷积内核 1x1 和 3x3 支持任意形式的激活函数 实时工作时最大支持神经网络参数大小为 5.5MiB 到 5.9MiB 非实时工作时最大支持网络参数大小为（Flash 容量-软件体积） 例程 运行人脸检测 模型下载地址：http://dl.sipeed.com/MAIX/MaixPy/model , 下载face_model_at_0x300000.kfpkg 完整例程： face_find 运行特征图 模型下载地址：http://dl.sipeed.com/MAIX/MaixPy/model , 下载face_model_at_0x300000.kfpkg 该模型是8bit定点模型，约380KB大小，层信息为： 1 2 :160x120 3 4 5 6 :80x60 7 8 9 10 :40x30 11~16 :20x15 import sensor import image import lcd import KPU as kpu index=3 lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) task=kpu.load(0x300000) img=image.Image() info=kpu.netinfo(task) layer=info[index] w=layer.wo() h=layer.ho() num=int(320*240/w/h) list=[None]*num x_step=int(320/w) y_step=int(240/h) img_lcd=image.Image() while True: img=sensor.snapshot() fmap=kpu.forward(task,img,index) for i in range(0,num): list[i]=kpu.fmap(fmap,i) for i in range(0,num): list[i].stretch(64,255) for i in range(0,num): a=img_lcd.draw_image(list[i],((i%x_step)*w,(int(i/x_step))*h)) lcd.display(img_lcd) kpu.fmap_free(fmap) 模块方法 load 从flash或者文件系统中加载模型 KPU.load(offset, file_path) 参数 offset 和 file_path 参数只能二选一，不需要关键词，直接传参即可 offset: 模型在 flash 中的偏移大小，如 0xd00000 表示模型烧录在13M起始的地方, 0x300000表示在 Flash 3M的地方 file_path: 模型在文件系统中为文件名， 如 “/sd/xxx.kmodel” 返回 如果正确加载，会返回返回值， 否则会抛出错误， 请看抛出的错误提示， 另外错误代码参考这里 如果发现错误代码是小于 2000 的值， 则是固件版本太低，需要更新固件版本 kpu_net: kpu 网络对象 init_yolo2 为yolo2网络模型传入初始化参数， 只有使用yolo2时使用 KPU.init_yolo2(kpu_net, threshold, nms_value, anchor_num, anchor) 比如： import KPU as kpu task = kpu.load(0x300000) anchor = (1.889, 2.5245, 2.9465, 3.94056, 3.99987, 5.3658, 5.155437, 6.92275, 6.718375, 9.01025) kpu.init_yolo2(task, 0.5, 0.3, 5, anchor) 参数 kpu_net: kpu 网络对象, 即加载的模型对象, KPU.load()的返回值 threshold: 概率阈值， 只有是这个物体的概率大于这个值才会输出结果， 取值范围：[0, 1] nms_value: box_iou 门限, 为了防止同一个物体被框出多个框，当在同一个物体上框出了两个框，这两个框的交叉区域占两个框总占用面积的比例 如果小于这个值时， 就取其中概率最大的一个框 anchor_num: anchor 的锚点数， 这里固定为 len(anchors)//2 anchor: 锚点参数与模型参数一致，同一个模型这个参数是固定的，和模型绑定的（训练模型时即确定了）， 不能改成其它值。 返回值 success： bool类型， 是否成功 deinit 释放模型占用的内存， 立即释放， 但是变量还在，可以使用del kpu_net_object 的方式删除， 另外也可以直接只使用del kpu_net_object来标记对象已被删除，下一次GC进行内存回收或者手动调用gc.collect()时，会自动释放内存 KPU.deinit(kpu_net) 比如： import KPU as kpu import gc task = kpu.load(0x300000) kpu.deinit(task) del task gc.collect() 或者： import KPU as kpu import gc task = kpu.load(0x300000) del task gc.collect() 参数 kpu_net: KPU.load() 返回的 kpu_net 对象 返回值 success： bool 类型， 是否成功 init_yolo2 import KPU as kpu import image task = kpu.load(offset or file_path) anchor = (1.889, 2.5245, 2.9465, 3.94056, 3.99987, 5.3658, 5.155437, 6.92275, 6.718375, 9.01025) kpu.init_yolo2(task, 0.5, 0.3, 5, anchor) img = image.Image() kpu.run_yolo2(task, img) #此处不对，请参考例程 参数 kpu_net: kpu_load 返回的 kpu_net 对象 image_t：从 sensor 采集到的图像 返回 list: kpu_yolo2_find 的列表 forward 计算已加载的网络模型到指定层数，输出目标层的特征图 fmap=KPU.forward(kpu_net, img, end_layer) import KPU as kpu task = kpu.load(offset or file_path) …… fmap=kpu.forward(task,img, 3) 参数 kpu_net: kpu_net 对象 img: 图像 image.Image 对象 end_layer: 指定计算到网络的第几层， 取值从0开始 返回 fmap: 特征图对象，内含当前层所有通道的特征图 fmap 取特征图的指定通道数据到image.Image对象 img=KPU.fmap(fmap, channel) 参数 fmap: 特征图 对象 channel: 指定特征图的通道号, 从0开始 返回 img: 特征图对应通道生成的灰度图，类型image.Image fmap_free 释放特征图对象 KPU.fmap_free(fmap) 参数 fmap: 特征图 对象 返回 无 netinfo 获取模型的网络结构信息 info_list = kpu.netinfo(task) 参数 kpu_net: kpu_net 对象, KPU.load()返回值 返回 info_list：所有层的信息list, 包含信息为： index：当前层在网络中的层数 wi：输入宽度 hi：输入高度 wo：输出宽度 ho：输出高度 chi：输入通道数 cho：输出通道数 dw：是否为depth wise layer kernel_type：卷积核类型，0为1x1， 1为3x3 pool_type：池化类型，0不池化; 1：2x2 max pooling; 2:... para_size：当前层的卷积参数字节数 set_outputs success = set_outputs(kput_net, out_idx, width, height, channel) 手动设置输出层形状， 对于 nncase v0.2.0 转换出来的 V4 的 kmodel 模型， 在 load 之后需要调用此函数手动设置输出层形状， V3 模型不需要 参数 kpu_net: kpu_net 对象 out_idx: 输出层下表， 从 0 开始， 比如第一层输出层是0 width： 层宽度， 如果是一维输出，则为1 height: 层高度， 如果是一维输出，则为1 channnel： 层通道数，如果是一维输出，则这里为一维输出的长度 返回 success： 是否设置成功， 如果不成功，注意看输出的提示信息， 参考错误代码 memtest 打印内存使用情况，包括GC内存和系统堆内存 注意执行这个函数会自动先执行gc.collect()进行内存回收一次，再打印GC剩余内存 系统堆内存只做参考，不一定准确，有时可能出现已经释放了内存，但是显示依然没有释放，以实际能不能分配到内存为准 KPU.memtest() powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/Maix/fft.html":{"url":"api_reference/Maix/fft.html","title":"FFT","keywords":"","body":"FFT运算 FFT快速傅里叶变换模块，对输入数据进行傅里叶变换并返回相应的频率幅值, FFT快速傅里叶运算可以将时域信号转换为频域信号 模块函数 运算函数 输入时域数据并进行傅里叶变换 import FFT res = FFT.run(data, points, shift) 参数 data: 输入的时域数据，bytearray 类型 points: FFT运算点数，仅支持64, 128，256和512点 shift: 偏移，默认为0 返回值 res: 返回计算后的频域数据，以 list 类型呈现，该列表有 points 个元组，每个元组有 2 个元素，第一个元素为实部，第二个为虚部 频率函数 FFT res = FFT.freq(points, sample_rate) 参数 points: 计算点数 sample_rate: 采样率 返回值 res : 返回一个列表，该列表存放的进行运算后后所有频率点的频率值 幅值函数 用于计算 FFT 运算后的各个频率点的幅值，目前用作测试，用户可以自己在python自行写幅值处理函数 amp = FFT.amplitude(FFT_res) 参数 FFT_res: 函数 run 运行后的结果 返回值 res : 返回一个列表，该列表存放了各个频率点的幅值 例程 采集声音并进行FFT运算，将运算后的数据在屏幕上显示为柱状图 例示代码： https://github.com/sipeed/MaixPy_scripts/blob/master/hardware/demo_fft_spectrum.py powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/Maix/i2s.html":{"url":"api_reference/Maix/i2s.html","title":"I2S","keywords":"","body":"I2S I2S模块主要用于驱动I2S设备，k210一共有3个I2S设备，每个设备一共有4个通道，在使用前需要对引脚进行映射管理 模块函数 构造函数 新建一个 I2S 对象 from Maix import I2S i2s_dev = I2S(device_num) 参数 device_num UART号，使用指定的 I2S，可以通过 I2S. 按tab键来补全 返回值 返回一个I2S 对象 通道配置函数 用于配置 I2S 通道，在此之前需要对引脚进行映射 i2s_dev.channel_config(channel, mode, resolution, cycles, align_mode) 参数 channel: I2S通道编号 mode: 通道传输模式，一共有接收和发送模式，录音为接受，播放为发送 resolution: 通道分辨率，即接收数据位数 cycles: 单个数据时钟数 align_mode: 通道对齐模式 返回值 无 设置采样率 用于配置 I2S 采样率 i2s_dev.set_sample_rate(sample_rate) 参数 sample_rate: 返回值 无 接收音频 使用I2S接收音频数据 audio = i2s_dev.record(points) 参数 points: 一次采集的音频点数 返回值 audio: 一个audio音频对象 发送音频 使用I2S发送音频数据 i2s_dev.play(audio) 参数 audio: 发送的音频对象 返回值 无 例程 例程1 from Maix import I2S import time fm.register(20,fm.fpioa.I2S0_IN_D0)#GO fm.register(19,fm.fpioa.I2S0_WS) fm.register(18,fm.fpioa.I2S0_SCLK) fm.register(34,fm.fpioa.I2S2_OUT_D1) fm.register(35,fm.fpioa.I2S2_SCLK) fm.register(33,fm.fpioa.I2S2_WS) sample_rate = 44*1000 rx = I2S(I2S.DEVICE_0) rx.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode = I2S.STANDARD_MODE) rx.set_sample_rate(sample_rate) tx = I2S(I2S.DEVICE_2) tx.channel_config(tx.CHANNEL_1, tx.TRANSMITTER, align_mode = I2S.RIGHT_JUSTIFYING_MODE) tx.set_sample_rate(sample_rate) while True: audio = rx.record(256)#sampling points number must be smaller than 256 tx.play(audio) 例程2 from Maix import I2S from Maix import Audio from Maix import FFT import time fm.register(20,fm.fpioa.I2S0_IN_D0) fm.register(19,fm.fpioa.I2S0_WS) fm.register(18,fm.fpioa.I2S0_SCLK) fm.register(34,fm.fpioa.I2S2_OUT_D1) fm.register(35,fm.fpioa.I2S2_SCLK) fm.register(33,fm.fpioa.I2S2_WS) rx = I2S(I2S.DEVICE_0) rx.channel_config(rx.CHANNEL_0, rx.RECEIVER, align_mode = I2S.STANDARD_MODE) rx.set_sample_rate(16000) tx = I2S(I2S.DEVICE_2) tx.channel_config(tx.CHANNEL_1, tx.TRANSMITTER, align_mode = I2S.RIGHT_JUSTIFYING_MODE) tx.set_sample_rate(16000) while True: audio = rx.record(256) audio_data = audio.to_bytes() play_audio = Audio(audio_data) tx.play(play_audio) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/Maix/freq.html":{"url":"api_reference/Maix/freq.html","title":"freq","keywords":"","body":"Maix.freq 频率模块，支持程序修改 cpu 和 kpu 频率 方法 freq.set(cpu, pll1, kpu_div) 设置 cpu 或者 kpu 频率，设置完后会自动重启生效 请注意在频率设置完毕后可能会导致某些外设性能改变 from Maix import freq freq.set(cpu = 400, kpu = 400) 配置文件将会保存在文件系统的/flash/freq.conf文件下，请勿修改这个文件，如果文件不存在则会自动创建 参数 不设置的参数会保持之前的值 注意： 如果cpu频率设置小于60MHz， 默认的REPL串口波特率会设置为9600 cpu： 想要设置的cpu频率，范围[26,600]（芯片最高800但对电压有要求，MaixPy支持的系列不支持最高到800，默认400, 不同的板子可能表现不同，为了稳定性不建议过高 pll1: pll1输出的频率，取值范围[26,1200]（芯片最高1800，MaixPy限制到1200），默认 400 kpu_div：kpu时钟频率分频，取值范围[1,16]，默认1。 kpu频率=pll1/kpu_div， 比如想设置kpu频率为400，则只需设置pll1为400， kpu_div为1即可。 注意kpu频率范围：[26,600] 返回值 如果频率没有变化，则返回空。 如果频率有变化，将会自动重启机器。在使用该接口之前请确认当前情况能能否重启 freq.get() 获取当前设置的频率参数 返回值 cpu频率和kpu的频率，一个元组的形式返回，比如(400,400) freq.get_cpu() 获取当前cpu的频率 返回值 cpu频率 freq.get_kpu() 获取当前设置的 kpu 频率 返回值 当前kpu频率 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/Maix/utils.html":{"url":"api_reference/Maix/utils.html","title":"utils","keywords":"","body":"Maix.utils gc_heap_size([size]) 获取或者设置 GC 堆大小，如果报内存不够时可以考虑设置大一点 参数 无 或者 传入新的 GC 堆大小. 如果没有参数就只是获取堆大小； 如果有参数则设置堆大小，然后会自动重启 返回值 GC 堆大小 使用实例 import Maix # Maix.utils.gc_heap_size(0x80000) # 固件默认配置为 500KB Maix.utils.gc_heap_size(0x96000) # 600KB flash_read(flash_offset, size) 从内部 flash 读取 size 指定大小(字节数) 数据 参数 flash_offset: flash 地址偏移 flash_offset: flash 地址偏移 heap_free() >>> Maix.utils.gc_heap_size() 524288 >>> Maix.utils.heap_free() 4374528 文章中脚本测试条件为: MaixDock MaixPy v0.5.0_246(标准版固件) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/builtin_py/":{"url":"api_reference/builtin_py/","title":"helper","keywords":"","body":"内置类（builtin_py） 内置类 库（builtin_py）是对 MaixPy 底层的类进行封装的用户层接口，方便用户使用 MaixPy 它包括以下： fpioa_manager board_info pye from board import board_info from fpioa_manager import fm powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/builtin_py/fm.html":{"url":"api_reference/builtin_py/fm.html","title":"fpioa_manager","keywords":"","body":"fpioa_manager 本文档在 MaixPy 0.5.1-128 版本测试通过。 fpioa_manager：简称fm，该模块用于注册芯片内部功能和引脚，帮助用户管理内部功能和引脚映射关系的功能模块。 如何理解【引脚]映射[内部功能]？ K210 芯片上的 外部引脚 和 内部功能 是彼此独立的，引脚是指从芯片上引出的许多金属触点，也就是我们俗称的功能引脚，它可以是 GPIO / PWM / ADC / I2C 等内部功能引脚，传统的认知是引脚对应的内部功能是不可改变的，但可以复用的，而 K210 是可以通过映射来改变引脚功能的，看如下示意图理解具体的映射功能。 首先可以将 I2C 的 SCL/SDA 映射（MAP）到 IO6/IO7 引脚，从而在此引脚上进行 I2C 的读写操作。 +------------------------------+ | | | +---+ | 接着还可以将 SPI 的 SCLK/MOSI/MISO/CS 映射（MAP）到 IO6/IO7/IO8/IO9 引脚，也就可以在此引脚上进行 SPI 的读写操作。 +------------------------------+ | | | +---+ | 使用方法 调用 register 函数将 pin 引脚与具体的硬件功能(GPIO/I2C/UART/I2S/SPI)绑定起来，在不使用的时候调用 unregister 释放引脚所绑定的硬件功能（或称 function ），这不同于传统单片机的理解， K210 可以将一定范围内的引脚映射到具体的硬件功能。 如下代码所示： from fpioa_manager import fm fm.register(11, fm.fpioa.GPIO0, force=True) fm.register(12, fm.fpioa.GPIOHS0, force=True) fm.register(13, fm.fpioa.UART2_TX) fm.register(14, fm.fpioa.UART2_RX) # other code fm.unregister(11) fm.unregister(12) fm.unregister(13) fm.unregister(14) 注意事项: 以下 GPIOHS 已经在 MaixPy 中默认使用，程序中如非必要请不要使用。 GPIOHS 功能 描述 GPIOHS5 LCD_DC LCD 读写信号引脚 GPIOHS4 LCD_RST LCD 复位芯片脚 GPIOHS29 SD_CS SD 卡 SPI 片选 GPIOHS28 MIC_LED_CLK SK9822_DAT GPIOHS27 MIC_LED_DATA SK9822_CLK 另外以下引脚已经在 MaxiPy 开机启动时注册，请注意。 SD卡 功能：SPI1_SCLK/SPI1_D0/SPI1_D1/GPIOHS29/SPI0_SS1 引脚：PIN25/PIN26/PIN27/PIN28/PIN29 LCD 功能：SPI0_SS3/SPI0_SCLK/GPIOHS30/GPIOHS31 引脚：PIN36/PIN37/PIN38/PIN39 sensor 功能：SCCB_SDA/SCCB_SCLK/CMOS_RST/CMOS_VSYNC/CMOS_PWDN/CMOS_HREF/CMOS_XCLK/CMOS_PCLK 引脚：PIN40/PIN41/PIN42/PIN43/PIN44/PIN45/PIN46/PIN47 REPL 功能：UARTHS_RX/UARTHS_TX 引脚：PIN4/PIN5 class fm register(pin, func, force=True) pin: 功能映射引脚 function : 芯片功能 force: 强制分配，如果为True，则可以多次对同一个引脚注册;False则不允许同一引脚多次注册。默认为True是为了方便IDE多次运行程序使用 设置引脚（pin）对应的外设功能（func），默认启用强制绑定参数（force=True），它将强制更换指定的引脚功能，如果发现存在上一个绑定的引脚，则会发出一个警告，但不影响代码继续执行。 如果设置 force=False ，则会在 register 发现硬件功能已经被使用了，此时就会弹出异常，方便深度开发的时候不清楚 GPIO/HS 的分配情况，常见于运行某个代码的按键在访问某些功能的时候不能使用了的场合。 使用方法 from fpioa_manager import fm fm.register(16, fm.fpioa.GPIO2) fm.register(13, fm.fpioa.GPIO2) fm.register(12, fm.fpioa.GPIO2, force=False) 可见提示了 fm.fpioa.GPIO2(pin:16) 和 fm.fpioa.GPIO2(pin:13) 的占用情况。 [Warning] function is used by fm.fpioa.GPIO2(pin:16) Traceback (most recent call last): File \"\", line 5, in File \"fpioa_manager.py\", line 20, in register Exception: [Warning] function is used by fm.fpioa.GPIO2(pin:13) unregister(pin) 释放引脚（pin）上的硬件功能（GPIO/I2C/SPI/I2S/UART）。 get_pin_by_function(pin) 获取引脚（pin）上绑定的硬件功能。 get_gpio_used() 获取所有 gpio 的使用情况，它只查询 GPIOHS / GPIO 的引脚分配情况, None 表示该硬件功能未被使用。 使用方法 from fpioa_manager import fm for item in fm.get_gpio_used(): print(item) 注意：每个引脚都会有默认状态 ('fm.fpioa.GPIOHS0', 16) ('fm.fpioa.GPIOHS1', 17) ('fm.fpioa.GPIOHS2', 18) ('fm.fpioa.GPIOHS3', 19) ('fm.fpioa.GPIOHS4', 37) ('fm.fpioa.GPIOHS5', 38) ('fm.fpioa.GPIOHS6', 22) ('fm.fpioa.GPIOHS7', 23) ('fm.fpioa.GPIOHS8', 24) ('fm.fpioa.GPIOHS9', 25) ('fm.fpioa.GPIOHS10', None) ('fm.fpioa.GPIOHS11', 27) ('fm.fpioa.GPIOHS12', 28) ('fm.fpioa.GPIOHS13', 29) ('fm.fpioa.GPIOHS14', 30) ('fm.fpioa.GPIOHS15', 31) ('fm.fpioa.GPIOHS16', 32) ('fm.fpioa.GPIOHS17', 33) ('fm.fpioa.GPIOHS18', 34) ('fm.fpioa.GPIOHS19', 35) ('fm.fpioa.GPIOHS20', None) ('fm.fpioa.GPIOHS21', None) ('fm.fpioa.GPIOHS22', None) ('fm.fpioa.GPIOHS23', None) ('fm.fpioa.GPIOHS24', 40) ('fm.fpioa.GPIOHS25', 41) ('fm.fpioa.GPIOHS26', 42) ('fm.fpioa.GPIOHS27', 43) ('fm.fpioa.GPIOHS28', 44) ('fm.fpioa.GPIOHS29', 26) ('fm.fpioa.GPIOHS30', 46) ('fm.fpioa.GPIOHS31', 47) ('fm.fpioa.GPIO0', 8) ('fm.fpioa.GPIO1', 9) ('fm.fpioa.GPIO2', None) ('fm.fpioa.GPIO3', None) ('fm.fpioa.GPIO4', 12) ('fm.fpioa.GPIO5', 13) ('fm.fpioa.GPIO6', 14) ('fm.fpioa.GPIO7', 15) help() 调用它会打印出如下『附录： 外设表』帮助说明。 详细看 FPIOA 。 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/builtin_py/board_info.html":{"url":"api_reference/builtin_py/board_info.html","title":"board_info","keywords":"","body":"Board 本文档在 MaixPy 0.5.1-128 版本测试通过。 这是一个 MaixPy 板级配置模块，它可以在用户层统一 Python 代码，从而屏蔽许多硬件的引脚差异。 效果如下： from Maix import GPIO from fpioa_manager import fm from board import board_info print(board_info.LED_R) fm.register(board_info.LED_R, fm.fpioa.GPIO0, force=True) led_r = GPIO(GPIO.GPIO0, GPIO.OUT) led_r.value(0) 而这份代码同时支持 MaixPy 所有硬件运行，并且打印的 board_info.LED_R 都不尽相同，通过它保证示例代码的一致性。 board 的配置方法 调用『指定硬件』的配置代码，完成对『指定硬件』配置项（config.json）的导入。 Maix Bit config_maix_bit.py Maix Dock config_maix_dock.py Maix Go config_maix_go.py Maix Duino config_maix_duino.py Maix Cube config_maix_cube.py Maix Amigo config_maix_amigo.py Maix Nano 这个没有硬件外设.....所以不要问为什么没有它的配置代码了。 你的专属硬件 你可以借助该接口代码适配你的硬件，配置方法参考 MaixPy_scripts/board 里面有供你参考的配置文件。 board 的使用方法 导入配置： from board import board_info board_info.load({ 'PIN10': 10, 'BOOT_KEY': 16, 'WIFI_TX': 6, 'WIFI_RX': 7, 'WIFI_EN': 8, }) print('PIN10:', board_info.PIN10) print('BOOT_KEY:', board_info.BOOT_KEY) print('WIFI_TX:', board_info.WIFI_TX) print('WIFI_RX:', board_info.WIFI_RX) print('WIFI_EN:', board_info.WIFI_EN) 调用结果： PIN10: 10 BOOT_KEY: 16 WIFI_TX: 6 WIFI_RX: 7 WIFI_EN: 8 就这样。 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/machine_vision/":{"url":"api_reference/machine_vision/","title":"media","keywords":"","body":"机器视觉/听觉 主要包含了了与图像、显示、语音相关的类，包括： lcd sensor image image video isolated_word maix_asr powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/machine_vision/lcd.html":{"url":"api_reference/machine_vision/lcd.html","title":"lcd","keywords":"","body":"lcd 屏幕显示驱动 函数 lcd.init(type=1, freq=15000000, color=lcd.BLACK) 初始化 LCD 屏幕显示 参数 type： LCD 的类型（保留给未来使用）: 0: None 1: lcd shield（默认值） type 是键值参数，必须在函数调用中通过写入 type= 来显式地调用 freq： LCD （实际上指 SPI 的通讯速率） 的频率 color： LCD 初始化的颜色， 可以是 16 位的 RGB565 颜色值，比如 0xFFFF； 或者 RGB888 元组， 比如 (236, 36, 36)， 默认 lcd.BLACK lcd.deinit() 注销 LCD 驱动，释放I/O引脚 lcd.width() 返回 LCD 的宽度（水平分辨率） lcd.height() 返回 LCD 的高度（垂直分辨率）。 lcd.type() 返回 LCD 的类型（保留给未来使用）： 0: None 1: lcd Shield lcd.freq(freq) 设置或者获取 LCD （SPI） 的频率 Paremeters freq: LCD (SPI) 的频率 Return LCD 的频率 lcd.set_backlight(state) 设置 LCD 的背光状态， 关闭背光会大大降低lcd扩展板的能耗 //TODO: 未实现 参数 state： 背光亮度， 取值 [0,100] lcd.get_backlight() 返回背光状态 返回值 背光亮度， 取值 [0,100] lcd.display(image, roi=Auto) 在液晶屏上显示一张 image（GRAYSCALE或RGB565）。 roi 是一个感兴趣区域的矩形元组(x, y, w, h)。若未指定，即为图像矩形 若 roi 宽度小于lcd宽度，则用垂直的黑色边框使 roi 居于屏幕中心（即用黑色填充未占用区域）。 若 roi 宽度大于lcd宽度，则 roi 居于屏幕中心，且不匹配像素不会显示（即液晶屏以窗口形态显示 roi 的中心）。 若 roi 高度小于lcd高度，则用垂直的黑色边框使 roi 居于屏幕中心（即用黑色填充未占用区域）。 若 roi 高度大于lcd高度，则 roi 居于屏幕中心，且不匹配像素不会显示（即液晶屏以窗口形态显示 roi 的中心）。 roi 是键值参数，必须在函数调用中通过写入 roi= 来显式地调用。 lcd.clear() 将液晶屏清空为黑色或者指定的颜色。 参数 color： LCD 初始化的颜色， 可以是 16 位的 RGB565 颜色值，比如 0xFFFF； 或者 RGB888 元组， 比如 (236, 36, 36) lcd.direction(dir) 在 v0.3.1 之后已经被舍弃， 请使用lcd.rotation 和 lcd.invert代替， 如非必要请勿使用， 接口仍会被保留用于调试使用 设置屏幕方向， 以及是否镜像等 参数 dir： 正常情况下推荐 lcd.YX_LRUD 和 lcd.YX_RLDU， 另外还有其它值，交换 XY 或者 LR 或者 DU即可 lcd.rotation(dir) 设置 LCD 屏幕方向 参数 dir: 取值范围 [0,3]， 从0到3依次顺时针旋转 返回值 当前方向，取值[0,3] lcd.mirror(invert) 设置 LCD 是否镜面显示 参数 invert： 是否镜面显示， True 或者 False 返回值 当前设置，是否镜面显示，返回True或者False 例程 例程 1： 显示英文 import lcd lcd.init() lcd.draw_string(100, 100, \"hello maixpy\", lcd.RED, lcd.BLACK) 例程 2： 显示图片 import lcd import image img = image.Image(\"/sd/pic.bmp\") lcd.display(img) 例程 3： 利用显示图片的方式显示英文 import lcd import image img = image.Image() img.draw_string(60, 100, \"hello maixpy\", scale=2) lcd.display(img) 例程 4： 实时显示摄像头捕捉到的图像 import sensor, lcd sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) sensor.skip_frames() lcd.init() while(True): lcd.display(sensor.snapshot()) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/machine_vision/sensor.html":{"url":"api_reference/machine_vision/sensor.html","title":"sensor","keywords":"","body":"sensor sensor 传感器模块(这里特指摄像头模块)，进行摄像头配置及图像抓取等，用于控制开发板摄像头完成摄像任务。 方法 初始化单目摄像头 重置并初始化单目摄像头 sensor.reset([, freq=24000000[, set_regs=True[, dual_buff=False]]]) 参数 freq: 设置摄像头时钟频率，频率越高帧率越高，但是画质可能更差。默认 24MHz， 如果摄像头有彩色斑点(ov7740)，可以适当调低比如 20MHz set_regs: 允许程序写摄像头寄存器，默认为 True。 如果需要自定义复位序列，可以设置为False，然后使用sensor.__write_reg(addr, value) 函数自定义写寄存器序列 dual_buff: 默认为False。允许使用双缓冲，会增高帧率，但是内存占用也会增加(大约为384KiB) 返回值 无 重置双目摄像头 重置并初始化双目摄像头 K210 只有一个 DVP 接口，同一时间只能控制一个 Sensor。但是我们可以借助 shudown 方法控制 PWDN 引脚以选择特定的 Sensor。 指定 Sensor 后其余操作不变。详见 例程 2 sensor.binocular_reset() 参数 无 返回值 无 设置帧大小 用于设置摄像头输出帧大小，k210最大支持VGA格式，大于VGA将无法获取图像 MaixPy开发板配置的屏幕是320*240分辨率，推荐设置为QVGA格式 sensor.set_framesize(framesize[, set_regs=True]) 参数 framesize: 帧大小 set_regs: 允许程序写摄像头寄存器，默认为 True。 如果需要自定义设置帧大小的序列，可以设置为False，然后使用sensor.__write_reg(addr, value) 函数自定义写寄存器序列 返回值 True : 设置成功 False: 设置错误 设置帧格式 用于设置摄像头输出格式 MaixPy开发板配置的屏幕使用的是RGB565，推荐设置为RGB565格式 sensor.set_pixformat(format[, set_regs=True]) 参数 format: 帧格式 set_regs: 允许程序写摄像头寄存器，默认为 True。 如果需要自定义设置像素格式的序列，可以设置为False，然后使用sensor.__write_reg(addr, value) 函数自定义写寄存器序列 可选的帧格式有GRAYSCALE, RGB565, YUV422 返回值 True : 设置成功 False: 设置错误 图像捕捉控制 图像捕捉功能控制 sensor.run(enable) 参数 enable: 1 表示开始抓取图像 0 表示停止抓取图像 返回值 True : 设置成功 False: 设置错误 拍摄图像 使用摄像头拍摄一张照片 sensor.snapshot() 参数 无 返回值 img: 返回的图像对象 摄像头控制 关闭摄像头/切换摄像头 sensor.shutdown(enable/select) 参数 单目摄像头 enable: True 表示开启摄像头 False 表示关闭摄像头 双目摄像头 select: 通过写入 0 或 1 来切换摄像头 返回值 无 跳帧 跳过指定帧数或者跳过指定时间内的图像，让相机图像在改变相机设置后稳定下来 sensor.skip_frames(n, [, time]) 参数 n: 跳过 n 帧图像 time: 跳过指定时间，单位为ms 若 n 和 time 皆未指定，该方法跳过300毫秒的帧；若二者皆指定，该方法会跳过 n 数量的帧，但将在 time 毫秒后返回 返回值 无 分辨率宽度 获取摄像头分辨率宽度 sensor.width() 参数 无 返回值 int类型的摄像头分辨率宽度 分辨率高度 获取摄像头分辨率高度 sensor.height() 参数 无 返回值 int类型的摄像头分辨率高度 获取帧缓冲 获取当前帧缓冲区 sensor.get_fb() 参数 无 返回值 image类型的对象 获取ID 获取当前摄像头ID sensor.get_id() 参数 无 返回值 int类型的ID 设置彩条测试模式 将摄像头设置为彩条测试模式 开启彩条测试模式后，摄像头会输出一彩条图像，常用来检测摄像机总线是否连接正确。 sensor.set_colorbar(enable) 参数 enable: 1 表示开启彩条测试模式 0 表示关闭彩条测试模式 返回值 无 设置对比度 设置摄像头对比度 sensor.set_contrast(contrast) 参数 constrast: 摄像头对比度，范围为[-2,+2] 返回值 True : 设置成功 False: 设置错误 设置亮度 设置摄像头亮度 sensor.set_brightness(brightness) 参数 constrast: 摄像头亮度，范围为[-2,+2] 返回值 True : 设置成功 False: 设置错误 设置饱和度 设置摄像头饱和度 sensor.set_saturation(saturation) 参数 constrast: 摄像头饱和度，范围为[-2,+2] 返回值 True : 设置成功 False: 设置错误 设置自动增益 设置摄像自动增益模式 sensor.set_auto_gain(enable,gain_db) 参数 enable: 1 表示开启自动增益 0 表示关闭自动增益 gain_db: 关闭自动增益时，设置的摄像头固定增益值，单位为dB 如果需要追踪颜色，需要关闭自动增益 返回值 无 获取增益值 获取摄像头增益值 sensor.get_gain_db() 参数 无 返回值 float类型的增益值 设置水平镜像 设置摄像头水平镜像 sensor.set_hmirror(enable) 参数 enable: 1 表示开启水平镜像 0 表示关闭水平镜像 返回值 无 设置摄像头垂直翻转 设置摄像头垂直翻转 sensor.set_vflip(enable) 参数 enable: 1 表示开启垂直翻转 0 表示关闭垂直翻转 返回值 无 写入寄存器 往摄像头寄存器写入指定值 sensor.__write_reg(address, value) 参数 address: 寄存器地址 value ： 写入值 返回值 无 请参阅摄像头数据手册以获取详细信息 读取寄存器 读取摄像头寄存器值 sensor.__read_reg(address) 参数 address: 寄存器地址 返回值 int类型的寄存器值 请参阅摄像头数据手册以获取详细信息 例程 例程 1 # 单目摄像头 import sensor import lcd lcd.init() sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) while True: img = sensor.snapshot() lcd.display(img) 例程 2 # 双目摄像头 import sensor import image import lcd import time lcd.init() sensor.binocular_reset() sensor.shutdown(0) # 选中sensor 0 sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.shutdown(1) # 选中sensor 1 sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.run(1) while True: sensor.shutdown(0) # 选中sensor 0 img = sensor.snapshot() lcd.display(img) time.sleep_ms(100) sensor.shutdown(1) # 选中sensor 1 img = sensor.snapshot() lcd.display(img) time.sleep_ms(100) powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/extend/":{"url":"api_reference/extend/","title":"extend","keywords":"","body":"外设模块 这里的外设模块主要指片外外设（相对于片上外设，比如GPIO、I2C等），比如 LCD、 摄像头、 触摸屏等等 关于图像相关的暂时放在了 机器视觉 分类， 包括以下外设模块 lcd： 显示图像 sensor： 获取摄像头数据， 取名叫 sensor 是兼容 openmv， 当然也不完全一样，请阅读文档 其它外设模块包括： touchscreen： 触摸屏相关操作，读取触摸屏点击状态以及获取点击的坐标等 ws2812: WS2812单总线灯带 热红外温度传感器 超声波 Grove 链式 RGB LED powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/extend/touchscreen.html":{"url":"api_reference/extend/touchscreen.html","title":"touchscreen","keywords":"","body":"touchscreen 触摸屏幕 touchscreen 模块包含了基本的读取触摸屏幕操作 目前支持的触摸屏幕： ns2009（默认） 如果需要修改驱动型号，需要重新编译 MaixPy 源码修改预编译支持的型号 全局函数 init(i2c=None, cal=None) 初始化触摸屏 API 在后面可能会有所改动（主要是针对多种驱动对参数的改动） 参数 i2c： 目前支持的是 I2C 通信的触摸屏， 传入I2C实例对象， 后期这个参数可能会被重命名或者取消 cal： 校准数据， 是一个 7 个整型值的元组， 可以通过 touchscreen.calibrate() 函数得到 calibrate() 校准屏幕，使屏幕显示和触摸屏像素能够对应 返回值 返回一个 7 个整型值的元组， 可以保存到文件系统或者flash，在初始化的时候传入，这样就不用每次都校准了 read() 读取当前屏幕的状态以及按下的点的坐标值 返回值 一个由 3 个整型值组成的元组 (status, x, y)， 注意这个值会一直保持上一个状态 status： 状态， 取值有 touchscreen.STATUS_PRESS， touchscreen.STATUS_MOVE， touchscreen.STATUS_RELEASE x： x 轴坐标 y： y 轴坐标 常量 touchscreen.STATUS_PRESS 屏幕被按下， read() 函数返回的元组的第一个值 touchscreen.STATUS_MOVE 屏幕被按住并移动，即按住移动， read() 函数返回的元组的第一个值 touchscreen.STATUS_RELEASE 屏幕不再被按住，即没有点击， read() 函数返回的元组的第一个值 例程 例程 1 ： 图画板 黑底白画笔画图板， 使用boot 按键可以清除内容 取消 ts.calibrate() 的注释可以在开始运行触摸屏校准程序 import touchscreen as ts from machine import I2C import lcd, image from board import board_info from fpioa_manager import * board_info=board_info() fm.register(board_info.BOOT_KEY, fm.fpioa.GPIO1) btn_clear = GPIO(GPIO.GPIO1, GPIO.IN) lcd.init() i2c = I2C(I2C.I2C0, freq=400000, scl=30, sda=31) ts.init(i2c) #ts.calibrate() lcd.clear() img = image.Image() status_last = ts.STATUS_IDLE x_last = 0 y_last = 0 draw = False while True: (status,x,y) = ts.read() print(status, x, y) if draw: img.draw_line((x_last, y_last, x, y)) if status_last!=status: if (status==ts.STATUS_PRESS or status == ts.STATUS_MOVE): draw = True else: draw = False status_last = status lcd.display(img) x_last = x y_last = y if btn_clear.value() == 0: img.clear() ts.__del__() powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/extend/ultrasonic.html":{"url":"api_reference/extend/ultrasonic.html","title":"modules.ultrasonic","keywords":"","body":"modules.ultrasonic 超声波传感器 构造方法 ultrasonic(gpiohs) 参数 gpiohs: gpiohs 编号，需要先使用fm注册引脚,比如 ```python from fpioa_manager import * from modules import ultrasonic fm.register(board_info.D[6], fm.fpioa.GPIOHS0, force = True) device = ultrasonic(fm.fpioa.GPIOHS0) ``` 返回值 返回对象 方法 measure(unit, timeout) 参数 unit： 单位， 在下面的常数中取值 timeout: 超时时间，单位为微秒（us） 常数 ultrasonic.UNIT_CM 返回的距离的单位，厘米 ultrasonic.UNIT_INCH 返回的距离的单位，英尺 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/extend/ws2812.html":{"url":"api_reference/extend/ws2812.html","title":"modules.ws2812","keywords":"","body":"WS2812灯带 (modules.ws2812) 本模块使用K210的I2S进行模块的驱动，所以在使用的过程中需要注意是否冲突 目前最多支持12路灯带 构造函数 from modules import ws2812 class ws2812(led_pin=-1,led_num=-1,i2s_num=I2S_DEVICE_2,i2s_chn=I2S_CHANNEL_3,i2s_dma_chn=DMAC_CHANNEL1) 通过指定参数新建一个 ws2812 对象 参数 led_pin: 灯带数据线连接的引脚，比如 board_info.D[4] led_num: 灯带一共有多少颗灯珠 i2s_num: 该对象使用哪个 I2S 设备进行驱动，默认为 I2S_DEVICE_2,取值范围为 0-2 i2s_chn: 该对象使用哪个 I2S 通道，默认为 I2S_CHANNEL_3，取值范围为 0-3 i2s_dma_chn: 该对象使用的DMA通道，用户一般不考虑 方法 set_led class_ws2812.set_led(num， color) 参数 num : 第 N 颗灯珠，从 0 开始 color : 该灯珠赋值的颜色，为 tuple 类型， （R,G,B） 返回值 无 display class_ws2812.display() 参数 无 返回值 无 例程0 from modules import ws2812 class_ws2812 = ws2812(board_info.D[4],30) for i in range(30): class_ws2812.set_led(i,(0xff,0,0)) class_ws2812.display() 例程1 from modules import ws2812 class_ws2812 = ws2812(board_info.D[4],30) r=0 dir = True while True: if dir: r += 1 else: r -= 1 if r>=255: r = 255 dir = False elif r 以上例程，可见MaixPy_scripts powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/extend/htpa.html":{"url":"api_reference/extend/htpa.html","title":"modules.htpa","keywords":"","body":"HTPA 热红外测温模组(modules.htpa) 海曼 HTPA 32x32 热红外测问模组 构造方法 htpa(i2c, scl_pin, sda_pin, i2c_freq) 创建一个实例 参数 i2c: I2C编号， 比如I2C.I2C0，取值 [0, 2] (见machine.I2C) scl_pin: I2C SCL 引脚 sda_pin: I2C SDA 引脚 i2c_freq: I2C 时钟频率 返回值 htpa 对象 实例方法 temperature() 获取传感器温度值，只能被实例调用 返回值 数组，长度为传感器的宽度x高度，比如32x32 实例方法 width() 获取传感器分辨率宽度，只能被实例调用 返回值 整数，宽度 实例方法 height() 获取传感器分辨率宽度，只能被实例调用 例子 heimann_HTPA_32x32 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"api_reference/extend/grove_chainable_rgb_led.html":{"url":"api_reference/extend/grove_chainable_rgb_led.html","title":"Grove RGB LED","keywords":"","body":"Grove 链式 RGB LED 使用两跟线串行连接多个 RGB LED 灯（灯条） 使用 micropython 语法编写， 例程和资料见 MaixPy_Scripts powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"others/maixpy_faq.html":{"url":"others/maixpy_faq.html","title":"MaixPy 常见问题 FAQ","keywords":"","body":"MaixPy 常见问题 可以点击右侧 目录按钮 来查看问题目录，方便快速寻找需要的问题 MaixPy 与 C 开发有什么异同，我该怎么选择 MaixPy 是基于 Micropython 的脚本语言， 不需要编译，在运行时解析，编写起来更简单方便，只是运行时时实性不如 C 语言。 所以如果是快速验证、新手、只会 python、头发少等都可以用 MaixPy; 追求极限性能效率或者熟悉 C ，以及对 MaixPy 的长期运行的稳定性不太有信心的都可以使用 C 语言开发 MaixPy IDE 无法成功连接开发板 现象: ​ 开发板到手之后，一直无法连接 MaixPy IDE 检查固件是否支持 IDE， 早期的固件以及名字带minimum的固件都不支持 检查串口是否被占用（其它软件也打开了串口） 点击连接后，不用和终端工具同时使用，否则会出现串口占用无法打开 如果一直无法成功连接成功， 检查： 请检查是否开发板型号选择错误； 观察开发板屏幕是否有变化，如果没有反应可能是串口选择错误； 尝试升级到最新的 master 分支固件， 以及最新的 MaixPy IDE 软件 MaixPy 版本号低于 0.5.0_v0 不支持连接 MaixPy IDE 文档网页打不开，速度慢 如果遇到有些页面无法访问， 请检查一下网址（路径）是否正确， 可以回到首页 (maixpy.sipeed.com) 重新进入即可。 比如这个网址就是由于点击过快导致的： http://localhost:4000/zh/zh/get_started/how_to_read.html 正确的网址应该是： http://localhost:4000/zh/get_started/how_to_read.html 另外，可以换个网络线路试试，比如挂代理，或者换手机流量试试， 国内也可以使用cn.maixpy.sipeed.com 下载站文件下载速度慢，文件无法下载 如果遇到在 dl.sipeed.com 下载站下载速度慢，可以使用国内的同步服务器 cn.dl.sipeed.com 下载，路径相同，每天同步一次； 部分文件提供了 CDN 下载链接，速度会比较快， 比如 IDE 在 readme.txt 中有说明 Micro SD 卡读取不到 Micro SD 读取不到现象及解决方法: 确认 SD 能否在电脑上正常使用，如果不能即 SD 已损坏， 电脑能够正常使用，读取 SD，但 MaixPy 开发板无法使用： SD 卡未格式化为 MBR 分区 FAT32 格式 电脑能够正常使用 SD 卡，也确认 SD 卡的磁盘格式为 FAT32，但 MaixPy 开发板依旧无法使用： 可能存在的原因：部分 SD 出厂时，sd 中没有磁盘分区表，或者磁盘分区表类型不是 MBR 解决的方法：使用第三方磁盘管理软件，将 sd 分区表类型转换为 MBR, 并且将 sd 格式格式化为 FAT32 这里使用 Diskgenius 来转换磁盘分区表格式 SD 卡不支持 SPI 协议 目前硬件只能支持 SPI 协议读取， 尽量购买正规的卡 比如：下图左边两张卡 MaixPy 的驱动不支持， 中间和右边的都支持， 但是中间的 class10 卡速度最快（最高测过 128GB可用） 另外测试过网上购买的几张闪迪、金士顿、三星的卡，其中发现有一张三星的卡无法使用 SD 卡支持多大容量 最大测试过 128GiB 可以使用 使用 SD 加载文件、模型不成功 现象：我们在使用过程中可能遇到加载模型提示错误， 可能存在的问题原因: sd 不兼容，挂载不成功 验证 sd 卡是否挂载方法: import os print(os.listdir(\"/\")) >>['flash'] # 没有挂载 SD 卡 >>['flash', 'sd'] # 挂载 SD 卡成功 为什么连接了 IDE 帧率降低了很多 K210 没有 USB 外设， 因此只能使用串口与 IDE 通信， 速度不如 USB 设备快，因此会影响帧率， 可以关闭 IDE 的摄像头预览 为什么 IDE 上预览的摄像头图像很模糊 K210 没有 USB 外设， 因此只能使用串口与 IDE 通信， 速度不如 USB 设备快， 因此对图片进行了压缩，如果需要看清晰的图像请在开发板的屏幕上看，或者保存成图片传到电脑查看 所以 IDE 的图像预览功能主要是给教学和演示使用， 平时建议使用屏幕， 可以使用以下代码来设置预览图质量 sensor.set_jb_quality(95) 这样就将预览图的质量设置为了 95%， 但是帧率会有明显降低 怎么提高摄像头帧率 换更好的摄像头，比如 ov7740 帧率会比 ov2640 高一点。 但前提是摄像头电路必须与开发板的电路兼容 增加摄像头时钟频率(sensor.reset(freq=))，但是注意不要太高，太高会让画面变差 可以自己编译源码，打开摄像头双缓冲选项（默认打开），并且 sensor.reset(dual_buff=True)，帧率会有所增加，但是相应地，耗费的内存也会增加（大约为 384KiB ） IDE 帧缓冲区成像方向不正确，LCD 显示方向不正确 由于 MaixPy 支持的硬件型号较多，在使用 MaixPy IDE 或者 LCD 显示的时候会出现显示的方向不正确,那么这时候我们就需要对图像进行旋转了; 在修正显示方向之前,我们需要确认是 Sensor 方向旋转(MaixPy IDE 右上角的图像即为 Sensor 直接输出的图像)了，还是 LCD 方向旋转了 修正方法: sensor 方向修正： # 设置摄像头水平镜像 # `enable`: 1 表示开启水平镜像 0 表示关闭水平镜像 sensor.set_hmirror(enable) # 设置摄像头垂直镜像 # `enable`: 1 表示开启垂直镜像 0 表示关闭垂直镜像 sensor.set_vflip(enable) lcd 方向修正： # 设置 `LCD` 屏幕方向 # 参数: `dir`: 取值范围 [0,3]， 从`0`到`3`依次顺时针旋转 # 返回值: 当前方向，取值[0,3] lcd.rotation(dir) # 设置 `LCD` 是否镜面显示 # 参数: `invert`： 是否镜面显示， `True` 或者 `False` # 返回值: 当前设置，是否镜面显示，返回`True`或者`False` lcd.mirror(invert) 烧录 MaixPy 之后，MaixPy 出现无法启动 现象：我们在使用过程中可能遇到烧录 MaixPy 之后，MaixPy 出现无法启动(表象为 无法点亮屏幕，白屏 等)， 问题原因: 出现这种现象很大一部分是内部文件系统中的配置文件读取出错，或者我们设置的系统配置值(如 gc heap 值过大)出错导致系统无法启动。 解决方法：擦除文件系统(擦除全部 flash) 使用 kflash_gui 右上角选择擦除功能，然后加载MaixPy 文件系统模板，地址变成0xD00000, 长度变为3MiB 或者下载擦除固件: erase.fpkg/flash_erase_16MB.bin/erase_spiffs.kfpkg 使用 JTAG 调试器一直无法接连 K210 现象：使用裸机开发 K210, JTAG 调试器一直无法接连 K210 可能的原因： OpenOCD 调试环境搭建有问题（细节这里不说明） 烧录过 ken_gen.bin 之后，将永久禁用 K210 的 JTAG 调试功能 下载，保存脚本到 MaixPy 内部flash 之后，板子无法更新固件，无法启动运行脚本 可能现象：下载，保存脚本到 MaixPy 内部flash 之后，板子无法更新固件，板子无法启动 问题可以从硬件和软件上面去定位: 可能的硬件原因： ​ TODO: 待更新 可能的软件原因： 程序中拉高了 GPIO16, 造成了自动下载点电路无法拉低 GPIO16,使 K210 进入 ISP 模式 kflash 无法烧录/更新 MaixPy 固件 kflash_gui 配置选项 开发板型号 开发板型号选错 烧录空间(SRAM/Flash) 烧录空间选错 波特率&下载速度模式 下载波特率过高 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"others/maixhub_faq.html":{"url":"others/maixhub_faq.html","title":"MaixHub 平台 FAQ","keywords":"","body":"Maixhub 常见问题 怎么制作数据集 参考 maixhub 训练页面的帮助文档 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"course/advance/project_framework.html":{"url":"course/advance/project_framework.html","title":"源码目录结构","keywords":"","body":"代码框架结构 目录简介 目录 子目录 子目录2 子目录3 内容梗概 assets 资源文件 projects 工程文件， 每个文件夹一个工程 tools 工具 components ┐ 组件 └-boards 板级代码 └-drivers 驱动 └-micropython ┐ micropython 相关代码 └-core micropython 源码 └-port ┐ maixpy 自定义部分源码 └-builtin_py maixpy 默认内置类 └-include 移植部分头文件 └-src 功能模块源码 └-spiffs SPIFFS 文件系统 └-utils 工具类（函数） 现在的代码因为历史遗留原因在 components/micropython/port/src 目录下代码结构不是很好，以后的代码尽量按照现在的框架做到层次分明 添加代码 工程使用 CMake 进行组织， 并且工程支持多个可配置选项（Kconfig） 如果不添加文件夹和配置项，可以在现有的文件夹内添加文件编译即可 如果需要添加模块，可以修改 CMakeLists.txt 来添加内容， 可以参考内容更少的c_cpp_project_framework 如果需要添加配置项， 可以通过修改 Kconfig 文件来达到目的，所有配置项在编译时会生成宏定义添加到global_config.h(生成的文件)中去， 而且在 CmakeLists.txt 文件中都可以使用该宏定义。 比如在 Kconfig 中定义 config BOARD_M5STICK, 在 CMakeLists.txt 中可以通过判断CONFIG_BOARD_M5STICK 是否为真来决定是否编译特定的代码。 编译时就可以通过python3 project.py menuconfig来选择是否勾选了 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"course/advance/add_c_module.html":{"url":"course/advance/add_c_module.html","title":"如何添加一个 C 模块","keywords":"","body":"使用 C 添加一个 Micropython 模块 预备知识 在 python 中万物皆对象 需要先知道 module，type， function， class 分别是什么，有什么关系和区别 module（模块） 在MaixPy中，把每个类别的功能放到一个 模块 中， 比如内置的 uos,usys,machine， 另外我们自己新建的文件， 比如test.py 也可以是一个模块， 我们使用模块都这样使用： import uos import machine import test 在 C 源码中就是 mp_type_module type（类型） 用来表示一个基本的类型， 它可以包含一些方法或者变量 在 C 源码中就是 mp_type_type class（类） 一个 class 其实就是一个 type，比如 class A:pass print(type(A)) 会输出 当对A进行了实例化 class A:pass a = A() print(type(a)) 会输出 表示a是A的一个实例（对象） 在 C 中定义一个类其实就是定义一个 mp_type_type 在 C 中添加模块 我们的目标是实现在MaixPy层面可以使用以下代码： import my_lib print(my_lib.__name__) my_lib.hello() 在components/port/src目录下新建一个文件夹比如取名my_lib 然后在my_lib文件夹下新建my_lib.c文件 编辑my_lib.c添加代码 定义一个模块： #include \"obj.h\" const mp_obj_module_t my_lib_module = { .base = { &mp_type_module }, .globals = (mp_obj_dict_t*)&mp_module_my_lib_globals_dict, }; 这里my_lib_module是定义的my_lib模块对象, mp_type_module表明是一个模块， mp_module_my_lib_globals_dict是模块的全局变量和函数，是一个dict对象，有我们自己定义， 现在还没定义 定义模块的全局变量 STATIC mp_obj_t hello() { mp_printf(&mp_plat_print, \"hello from my_lib\"); return mp_const_none; } MP_DEFINE_CONST_FUN_OBJ_0(my_lib_func_hello_obj, my_lib_func_hello); STATIC const mp_map_elem_t my_lib_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_my_lib) }, { MP_OBJ_NEW_QSTR(MP_QSTR_hello), (mp_obj_t)&my_lib_func_hello_obj }, }; STATIC MP_DEFINE_CONST_DICT ( mp_module_my_lib_globals_dict, my_lib_globals_table ); 这里定义了一组键值对数组，键值对数值, mp_map_elem_t的定义如下： typedef struct _mp_map_elem_t { mp_obj_t key; mp_obj_t value; } mp_map_elem_t; 第一个值是key，类型是str对象， 即在MaixPy层面使用my_lib.key来调用。这里用了MP_OBJ_NEW_QSTR(MP_QSTR___name__)生成了一个值为__name__的str对象，你可能有疑问__name__这个c变量定义在哪里，这是在编译阶段使用工具自动生成c变量，总之记住这样可以写可以生成一个常量str对象保存在固件里就好了 第二个值是数值，类型是一个对象，可以是str/function/int/float/tuple/list/dict等， 方式如下： str: 这里同样是定义了一个str类型的值为my_lib,即在MaixPy层面使用my_lib.__name__得到结果my_lib。 其它常量对象： 可以使用mp_obj_new_xxx,比如int变量mp_obj_new_int(10)， 函数在obj.h中搜索 函数： 这里的key``hello对应的值为为(mp_obj_t)&my_lib_func_hello_obj，是一个函数对象，注意不是C函数，前面说了python中一切皆对象， 这里也是使用了一个函数对象，然后去地址强制转换成 mp_obj_t。这个函数对象使用了MP_DEFINE_CONST_FUN_OBJ_0宏定义将my_lib_func_hello这个C函数定义为my_lib_func_hello_obj这个对象，注意hello函数需要返回一个值mp_const_none,注意不能返回NULL， 因为NULL不是一个(MaixPy)对象， 这个返回值也就是MaixPy层面调用hello()函数时的返回值 除了MP_DEFINE_CONST_FUN_OBJ_0即没有参数之外，还有1/2/3/n个参数，以及带关键字参数，这些请翻阅源码举一反三学习 然后使用MP_DEFINE_CONST_DICT宏定义将my_lib_globals_table这个键值对变成MaixPy层面能理解的dict对象（mp_map_elem_t只是C层面能理解）mp_module_my_lib_globals_dict, 这个对象也被上一步中定义模块的时候使用 到此一个模块就定义完成了， 在 MaixPy层面，理论上可以使用如下语句进行使用了 import my_lib print(my_lib.__name__) my_lib.hello() 但是我们还没编译 将模块添加到固件， 并进行编译 在my_lib.c文件末尾添加: MP_REGISTER_MODULE(MP_QSTR_my_lib, my_lib_module, MODULE_MY_LIB_ENABLED); 这行代码注册这个模块，但是是否编译进固件取决与MODULE_MY_LIB_ENABLED这个宏定义在mpconfigport.h中是否定义为1 所以我们打开mpconfigport.h文件，在里面添加 #define MODULE_MY_LIB_ENABLED (1) 打开components/micropython/CMakeLists.txt编辑 找到文件中有############## Add source files ############### 的地方， 在后面添加 append_srcs_dir(MPY_PORT_SRCS \"port/src/my_lib\") 到此，项目才会将my_lib这个文件夹编译到固件 然后python project.py rebuild编译固件即可，因为新增了文件，一定要用rebuild命令而不是build，注意编译提示，如果有报错，注意修改 在模块中添加一个 type 前面定义了一个my_lib模块，现在我们希望在my_lib中定义一个类，叫A，如下 import my_lib a = my_lib.A() print(a.add(1, 2)) 这里只讲大致上的思路，然后提供样例，聪明的你一下就能理解了 定义一个mp_obj_type_t 对象，正如前面定义mp_obj_module_t一样 同样的，给这个类对象一个dict对象，作为这个类的成员，成员可以是常量或者函数甚至是另一个type对象 将这个类对象注册到前面的my_lib模块 定义mp_obj_type_t对象和成员定义可以参考port/src/standard_lib/machine/machine_i2c.c中的实现 定义mp_obj_type_t时有一个make_new成员，这个函数是用来新建对象时会被调用的函数，比如a = my_lib.A(); a.add(1,2) 如果不新建对象，直接调用类方法或变量，这个函数不会被调用A.var_a 比如我们定义了一个const mp_obj_type_t my_lib_A_type ... 然后在my_lib/my_lib.c中 my_lib_globals_table中添加这个对象，并将其映射到key A即可 { MP_ROM_QSTR(MP_QSTR_A), MP_ROM_PTR(&my_lib_A_type) }, 使用 C 语言编写固件时需要注意 mp_printf vs printk vs printf 因为IDE使用了串口通信协议，所以在C层面不要直接使用printk或者printf函数打印消息，必须使用mp_printf函数来打印，不然会导致 IDE 运行时受到不理解的数据而断开连接！！ 当然平时调试可以使用printk，因为这个函数不会触发系统中断，可以在中断函数里面调用，但是仅限调试时使用， 实际提交代码时一定要删除掉！！ powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"course/advance/pack_fs.html":{"url":"course/advance/pack_fs.html","title":"打包文件系统","keywords":"","body":"打包文件系统 将 PC 上的若干个文件打包成一个 SPIFFS 文件系统镜像，使用 kflash 烧录到 flash 特定的地址， 这些文件就能直接在开发板上(MaixPy)读取到了 详情请看使用说明： pack SPIFFS for MaixPy 操作示例 GIF： GIF 备用链接： pack_spiffs_ops.gif powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"share/recommend_articles.html":{"url":"share/recommend_articles.html","title":"精选文章","keywords":"","body":"MaixPy 精选文章 从社区精选的文章，收集一些不错的文章到这里，方便大家学习交流。 另外，如果你有经验想要分享，也欢迎参与， 写好文章后，提交 issue 请求添加 要求： 与 MaixPy 相关 文章目录层次结构清晰 文章逻辑清晰，需要写明分享的简介、效果、操作过程、总结，图文并茂 你也可以按照参与经验分享/分享模板直接在文档中添加经验分享，如果写得不错，也会被收录到本页面 模型训练 文章 简介 作者 Object detector - MobileNet and YOLOv2 on Sipeed MAix Dock 使用 Mobilenet+YOLOv2 在 Sipeed Maix Dock 开发板上进行物体检测 lemariva 30分钟训练，转换，运行MNIST于MAIX开发板 本文就将带你在30分钟内训练，转换，运行MNIST识别算法于MAIX开发板 zepan Train, Convert, Run MobileNet on Sipeed MaixPy and MaixDuino ! 使用 Mobilenet 训练在 MaixPy 上使用的分类模型 zepan K210基础入门 课程的第一部分是通过训练神经网络识别手写字符X跟O， 学会使用Tensorflow创建模型，并转换为K210的模型格式第二部分是教你用k210的SDK, 调用之前的模型，运算完成之后在LCD液晶屏上显示识别结果 mushroom-x MaixPy 基础 文章 简介 作者 K210 MaixPy 从入门到飞升--AI视觉篇--完全教程 MaixPy AI 视觉相关总结篇，只将视觉相关，从基本操作到模型训练走通一遍 neucrack MaixPy & K210 进阶 文章 简介 作者 K210 kmodel 模型储存数据结构 k210 kmodel 模型储存结构解析 neucrack K210 从flash实时加载大模型 为了在k210的有限的内存( neucrack K210 kflash ISP 下载程序流程 K210详细的的程序下载流程解析,包括芯片侧和kflash侧 neucrack MaixPy 外设模组使用 文章 简介 作者 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"share/open_projects.html":{"url":"share/open_projects.html","title":"开源项目","keywords":"","body":"MaixPy 相关开源项目精选 这里收集了一些比较不错的 MaixPy 相关的开源项目分享，欢迎 star 如果你也有不错的 MaixPy 相关的开源项目， 欢迎提交 issue 请求添加， 要求： 与 MaixPy 相关 项目有完整清晰的README，包括简介，效果，代码，使用方法等 模型训练 项目主页 简介 作者 sipeed/maix_train 分类和检测模型训练项目 Sipeed lemariva/MaixPy_YoloV2 使用 Mobilenet+YOLOv2 在 Sipeed Maix Dock 开发板上进行物体检测, 更多说明看博客 lemariva zhen8838/K210_Yolo_framework k210 上的 yolo v3 模型训练框架 zhen8838 TonyZ1Min/yolo-for-k210 在 windows 训练 YOLO 物体检测模型 TonyZ1Min UI & System 项目主页 简介 作者 eggfly/M5StickVComputer 运行在M5StickV上的纯 Python 应用框架 eggfly powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"share/my_share/":{"url":"share/my_share/","title":"参与经验分享/分享模板","keywords":"","body":"参与经验分享 本目录下主要用于大家分享自己的经验，或者教程 要参与分享，你需要提前掌握的知识 git 和 github 的使用 github PR（pull request）的使用 在入门教程里面有简要的介绍， 详细的使用方法请自行学习 如果你没有信心掌握这些技能， 你可以到提交issue 来说明问题或者贡献经验等，我们帮助你进行添加 如何添加 克隆文档到本地 git clone https://github.com/sipeed/MaixPy_DOC cd MaixPy_DOC 新建目录 需要新建一个目录专门用于写分享的文章， 在MaixPy_DOC/zh/share/my_share/目录下建立一个文件夹， 文件夹名只能用小写英文和下划线，可以用你的英文名字命名，比如tom或者lihua, 以下用MaixPy_DOC/zh/share/my_share/tom举例 当然，如果你写的是英文文档，需要放到MaixPy_DOC/en/share/my_share/tom文件夹下 在这个文件夹内建立一个文件，命名为readme.md, 然后在里面使用markdown语法编写分享， 建立MaixPy_DOC/zh/share/my_share/tom/assets目录，用来存放图片， 文档里面引用图片使用相对路径，比如放了一张图片路径是MaixPy_DOC/zh/share/my_share/tom/assets/cover.jpg，则在MaixPy_DOC/zh/share/my_share/tom/readme.md中引用图片使用如下语法 ![封面](./assets/cover.jpg) 注意， 不要往文件夹内放大文件， 图片也不要用太大的，否则会导致文档仓库巨大无比 编写文档 为了文档看起来格式正确，更易于阅读， 编写文档必须遵循语法和格式要求： 看 文档规范 文档模板, 按照模板写文章， 可以根据自己的情况修改 MaixPy 经验分享 —— XXX ========== | 作者 | 联系方式 | 个人主页 | | ---- | --------------- | ---------- | | XXX | XXXX@XXX.com | [github/sipeed](http://github.com/sipeed) | ## 简介： 描述下本次分享的背景，最终实现的效果展示等，可以使用图片或者 GIF 或者视频进行展示，但是不要放太大的图片到`assets`文件夹，不然用户因为网速问题很久都无法加载出来，就失去了意义了 ## 准备: ### 预备知识 ### 需要准备的软硬件环境 #### 硬件 图文描述使用到的开发板， 外设模块等 #### 软件 图文描述使用到的软件工具，MaixPy 版本 如果使用到第三方软件工具，可以附加相关名称或下载链接 ## 过程，具体标题自定义 ## 过程， 具体标题自定义 ## 结果 建议添加图片展示实际运行效果 ## 总结 对本次分享进行总结 ## 问题和反馈 可以提供反馈方式 ## 参考 在这里以列表的方式注明文章中引用的文章和源码 * 引用文章1: https://www.sipeed.com 添加这篇分享到文档左边的目录栏 打开MaixPy_DOC/zh/SUMMARY.md, 在末尾添加自己的分享，比如 ## 社区 & 分享 - [精选教程](./share/recommend_articles.md) - [开源项目](./share/open_projects.md) - 大家的经验分享 * [参与经验分享/分享模板](./share/my_share/README.md) * [jerry 的模型训练教程](./share/my_share/jerry/README.md) 添加自己的卡后效果是： ## 社区 & 分享 - [精选教程](./share/recommend_articles.md) - [开源项目](./share/open_projects.md) - 大家的经验分享 * [参与经验分享/分享模板](./share/my_share/README.md) * [模型训练教程-jerry](./share/my_share/jerry/README.md) * [如何设计一个自己的模型-tom](./share/my_share/tom/README.md) 注意是*号前面是两个空格，不是tab 提交 编写完后提交修改，然后在 github 上提交 PR， PR 通过后官方文档页面就会有这篇文章了 powered by GitbookFile Modify: 2020-11-26 20:02:14 "},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"Glossary Git 分散式版本控制软件 Markdown Aaron Swartz 跟 John Gruber 共同设计的排版语言 powered by GitbookFile Modify: 2020-11-26 20:02:14 "}}